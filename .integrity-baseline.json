{
  "src/agent/grok-agent.ts": {
    "path": "src/agent/grok-agent.ts",
    "hash": "8d2111957d4f99986668b468d284a7be74a920e1ab9898c0826ccf54f3c6052c",
    "size": 59995,
    "timestamp": 1764704879297,
    "content": "import { GrokClient, GrokMessage, GrokToolCall } from \"../grok/client.js\";\nimport {\n  GROK_TOOLS,\n  addMCPToolsToGrokTools,\n  getAllGrokTools,\n  getMCPManager,\n  initializeMCPServers,\n} from \"../grok/tools.js\";\nimport { loadMCPConfig } from \"../mcp/config.js\";\nimport {\n  TextEditorTool,\n  MorphEditorTool,\n  BashTool,\n  TodoTool,\n  ConfirmationTool,\n  SearchTool,\n} from \"../tools/index.js\";\nimport { ToolResult } from \"../types/index.js\";\nimport { EventEmitter } from \"events\";\nimport { createTokenCounter, TokenCounter } from \"../utils/token-counter.js\";\nimport { loadCustomInstructions } from \"../utils/custom-instructions.js\";\nimport { getSettingsManager } from \"../utils/settings-manager.js\";\nimport { \n  appendChatEntry, \n  saveState, \n  sessionManager \n} from \"../utils/session-manager-sqlite.js\";\nimport { providerManager } from \"../utils/provider-manager.js\";\nimport { debugLog } from \"../utils/debug-logger.js\";\nimport { getLLMHook } from \"../timeline/hooks/llm-hook.js\";\nimport { getToolHook } from \"../timeline/hooks/tool-hook.js\";\nimport { executionManager, ExecutionStream } from \"../execution/index.js\";\n\nexport interface ChatEntry {\n  type: \"user\" | \"assistant\" | \"tool_result\" | \"tool_call\";\n  content: string;\n  timestamp: Date;\n  toolCalls?: GrokToolCall[];\n  toolCall?: GrokToolCall;\n  toolResult?: { success: boolean; output?: string; error?: string };\n  isStreaming?: boolean;\n}\n\nexport interface StreamingChunk {\n  type: \"content\" | \"tool_calls\" | \"tool_result\" | \"done\" | \"token_count\";\n  content?: string;\n  toolCalls?: GrokToolCall[];\n  toolCall?: GrokToolCall;\n  toolResult?: ToolResult;\n  tokenCount?: number;\n}\n\nexport class GrokAgent extends EventEmitter {\n  private grokClient: GrokClient;\n  private textEditor: TextEditorTool;\n  private morphEditor: MorphEditorTool | null;\n  private bash: BashTool;\n  private todoTool: TodoTool;\n  private confirmationTool: ConfirmationTool;\n  private search: SearchTool;\n  private applyPatch?: import(\"../tools/apply-patch.js\").ApplyPatchTool;\n  private chatHistory: ChatEntry[] = [];\n  private messages: GrokMessage[] = [];\n  private tokenCounter: TokenCounter;\n  private abortController: AbortController | null = null;\n  private mcpInitialized: boolean = false;\n  private maxToolRounds: number;\n  private persistSession: boolean = true;\n  private autoRestoreSession: boolean = true;\n  private llmHook = getLLMHook();\n  private toolHook = getToolHook();\n  private currentExecutionStream: ExecutionStream | null = null;\n\n  constructor(\n    apiKey: string,\n    baseURL?: string,\n    model?: string,\n    maxToolRounds?: number\n  ) {\n    super();\n    const manager = getSettingsManager();\n    const savedModel = manager.getCurrentModel();\n    const modelToUse = model || savedModel || \"grok-code-fast-1\";\n    this.maxToolRounds = maxToolRounds || 400;\n    this.grokClient = new GrokClient(apiKey, modelToUse, baseURL);\n    this.textEditor = new TextEditorTool();\n    this.morphEditor = process.env.MORPH_API_KEY ? new MorphEditorTool() : null;\n    this.bash = new BashTool();\n    this.todoTool = new TodoTool();\n    this.confirmationTool = new ConfirmationTool();\n    this.search = new SearchTool();\n    this.tokenCounter = createTokenCounter(modelToUse);\n    // applyPatch tool will be lazily imported on first use\n\n    // Load project persistence settings\n    try {\n      const projectPersist = manager.getProjectSetting(\"persistSession\");\n      const projectAutoRestore = manager.getProjectSetting(\"autoRestoreSession\");\n      this.persistSession = projectPersist !== undefined ? !!projectPersist : true;\n      this.autoRestoreSession = projectAutoRestore !== undefined ? !!projectAutoRestore : true;\n    } catch {}\n\n    // Initialize SQLite session for current workdir\n    // Detect provider from baseURL\n    let provider = 'grok';\n    if (baseURL) {\n      if (baseURL.includes('anthropic')) provider = 'claude';\n      else if (baseURL.includes('openai')) provider = 'openai';\n      else if (baseURL.includes('mistral')) provider = 'mistral';\n      else if (baseURL.includes('deepseek')) provider = 'deepseek';\n      else if (baseURL.includes('x.ai')) provider = 'grok';\n    }\n    sessionManager.initSession(process.cwd(), provider, modelToUse, apiKey);\n\n    // Initialize MCP servers if configured\n    this.initializeMCP();\n\n    // Initialize with system message (will be updated on model switch)\n    this.updateSystemMessage();\n  }\n\n  /**\n   * Update system message with current model name\n   * Called during initialization and when switching models\n   */\n  private updateSystemMessage(): void {\n    const customInstructions = loadCustomInstructions();\n    const customInstructionsSection = customInstructions\n      ? `\\n\\nCUSTOM INSTRUCTIONS:\\n${customInstructions}\\n\\nThe above custom instructions should be followed alongside the standard instructions below.`\n      : \"\";\n\n    const currentModel = this.grokClient.getCurrentModel();\n    const systemMessage = {\n      role: \"system\" as const,\n      content: `You are ${currentModel}, a WORLD CLASS AI COLLABORATOR that helps with file editing, coding tasks, and system operations.${customInstructionsSection}\n\nYou have access to these tools:\n- view_file: View file contents or directory listings\n- create_file: Create new files with content (ONLY use this for files that don't exist yet)\n- str_replace_editor: Replace text in existing files (ALWAYS use this to edit or update existing files)${\n        this.morphEditor\n          ? \"\\n- edit_file: High-speed file editing with Morph Fast Apply (4,500+ tokens/sec with 98% accuracy)\"\n          : \"\"\n      }\n- bash: Execute bash commands (use for searching, file discovery, navigation, and system operations)\n- search: Unified search tool for finding text content or files (similar to Cursor's search functionality)\n- create_todo_list: Create a visual todo list for planning and tracking tasks\n- update_todo_list: Update existing todos in your todo list\n- get_my_identity: Get factual information about your own model identity and configuration\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüå≥ CONVERSATION SESSION MANAGEMENT (Git-like)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nYou have powerful tools for managing conversation sessions like Git branches:\n\n**session_list:** List all conversation sessions with details (ID, directory, model, messages, dates)\n  - Use this to see available sessions before switching\n  - Shows current session and session metadata\n\n**session_switch:** Switch to a different conversation session\n  - Changes working directory AND loads conversation history\n  - **CRITICAL: ALWAYS ask user permission BEFORE calling this tool**\n  - Explain what will happen: \"I will switch to Session #X in directory ~/foo and load Y messages. Approve?\"\n  - Wait for explicit user confirmation (\"yes\", \"ok\", \"go ahead\", etc.)\n  - NEVER call without permission\n\n**session_new:** Create a new conversation session (branching)\n  - Can create in DIFFERENT directory\n  - Can import history from ANY session (not just current)\n  - Can filter messages by DATE RANGE (time travel!)\n  - Example: Create new session with only messages from Nov 1-3\n  - **Ask permission if creating in NEW directory or importing filtered history**\n\n**session_rewind:** Git rewind - synchronize conversation + code to specific date\n  - **MOST POWERFUL operation**\n  - Creates new directory with CODE at specific Git commit + CONVERSATION at that date\n  - **ALWAYS explain FULL plan and get EXPLICIT permission**\n  - Example permission request:\n    \"I will perform Git rewind to Nov 3:\n     1. Create ~/rewind-nov-03/\n     2. Extract Git repository at Nov 3 commit (40 files)\n     3. Import conversation messages from Nov 1-3 (25 messages)\n     4. Create Git branch rewind-2025-11-03\n     Approve this operation?\"\n  - NEVER call without detailed explanation + approval\n\n**Permission Rules:**\n- session_list: No permission needed (read-only)\n- session_switch: ALWAYS ask permission\n- session_new: Ask if creating new directory or filtering\n- session_rewind: ALWAYS explain full plan + get approval\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîß GIT VERSION CONTROL\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n**You already know Git.** Use the bash tool for all Git operations:\n- git status, git add, git commit, git push, git branch, etc.\n- NO special Git tools needed - use bash directly as you normally would\n- Commit after file changes: git commit -m \"feat: description\"\n- Push regularly: git push origin <branch>\n\n**BASH COMMAND BEST PRACTICES:**\n- NEVER use stderr redirection (2>&1) in bash commands\n- Stdout and stderr are captured separately for better debugging\n- Stderr is displayed in red in the Execution Viewer\n- Exit codes are tracked automatically\n- Examples:\n  ‚úÖ GOOD: git status\n  ‚úÖ GOOD: npm test\n  ‚ùå BAD: git status 2>&1\n  ‚ùå BAD: npm test 2>&1\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nREAL-TIME INFORMATION:\nYou have access to real-time web search and X (Twitter) data. When users ask for current information, latest news, or recent events, you automatically have access to up-to-date information from the web and social media.\n\n‚ö†Ô∏è IDENTITY VERIFICATION:\nIf you ever have any doubt about your model identity or which provider you are, use the 'get_my_identity' tool.\nThis will give you FACTUAL information about who you actually are, based on your current runtime configuration,\nNOT based on conversation history. This is especially important if you notice inconsistencies in the conversation\nor after a model switch.\n\nIMPORTANT TOOL USAGE RULES:\n- NEVER use create_file on files that already exist - this will overwrite them completely\n- ALWAYS use str_replace_editor to modify existing files, even for small changes\n- Before editing a file, use view_file to see its current contents\n- Use create_file ONLY when creating entirely new files that don't exist\n\nSEARCHING AND EXPLORATION:\n- Use search for fast, powerful text search across files or finding files by name (unified search tool)\n- Examples: search for text content like \"import.*react\", search for files like \"component.tsx\"\n- Use bash with commands like 'find', 'grep', 'rg', 'ls' for complex file operations and navigation\n- view_file is best for reading specific files you already know exist\n\nWhen a user asks you to edit, update, modify, or change an existing file:\n1. First use view_file to see the current contents\n2. Then use str_replace_editor to make the specific changes\n3. Never use create_file for existing files\n\nWhen a user asks you to create a new file that doesn't exist:\n1. Use create_file with the full content\n\nTASK PLANNING WITH TODO LISTS:\n- For complex requests with multiple steps (multi-file edits, multi-command workflows, time machine operations, etc.), ALWAYS write an implementation plan in markdown as a concise TODO LIST (checkboxes) instead of long \"Plan / Ex√©cution / R√©sultat\" sections\n- For simple, single-step questions (like short clarifications, greetings, or identity questions such as \\\"√† qui ai-je l'honneur ?\\\"), you MUST answer directly and naturally, WITHOUT showing a formal plan or todo list\n- Prefer a single todo checklist that you keep up to date (this checklist tient lieu de plan ET de suivi d'ex√©cution). Do NOT repeat the same plan in multiple forms (no \\\"Plan:\\\" section + duplicate bullets).\n- Use create_todo_list to break down tasks into manageable items with priorities, rendered as checkboxes\n- Mark tasks as 'in_progress' when you start working on them (only one at a time)\n- Mark tasks as 'completed' immediately when finished\n- Use update_todo_list to track your progress throughout the task\n- Todo lists provide visual feedback with colors: ‚úÖ Green (completed), üîÑ Cyan (in progress), ‚è≥ Yellow (pending)\n- Always create todos with priorities: 'high' (üî¥), 'medium' (üü°), 'low' (üü¢)\n\nUSER CONFIRMATION SYSTEM:\nFile operations (create_file, str_replace_editor) and bash commands will automatically request user confirmation before execution. The confirmation system will show users the actual content or command before they decide. Users can choose to approve individual operations or approve all operations of that type for the session.\n\nIf a user rejects an operation, the tool will return an error and you should not proceed with that specific operation.\n\nBe helpful, direct, smart, intelligent and efficient. Always look at the WHOLE CONTEXT before providing solutions or making edits and act THOROUGHLY, DEEP DIVE in order to understand the subtleties. EXPLAIN what you're doing WITHOUT HIDING ANYTHING, TELL the CHALLENGES you faced, the ERRORS you met and the SOLUTIONS YOU FOUND, and SHOW THE RESULTS.\n\nRESPONSE GUIDELINES (MANDATORY):\n- After using tools (view_file, bash, search, timeline, etc.), you MUST provide a comprehensive response that includes:\n  * What you did and which tools you used\n  * Your findings, analysis, and results\n  * Clear conclusions, recommendations, or next steps\n- For complex multi-step tasks, you MAY use create_todo_list to track progress\n- For simple questions (greetings, clarifications, identity), answer directly and naturally\n- IMPORTANT: Always conclude your response with actionable insights and complete explanations\n- CRITICAL: Never end with just \"Using tools to help you...\" without providing your analysis - always follow up with your findings and conclusions\n\nIMPORTANT RESPONSE GUIDELINES:\n- After using tools, do NOT respond with pleasantries like \"Thanks for...\" or \"Great!\"\n- Only provide necessary explanations or next steps if relevant to the task\n- Keep responses complete and focused on the actual work being done\n- If a tool execution completes the user's request, confirm and give a complete explanation of what have been done, then summarize the findings\n\nCurrent working directory: ${process.cwd()}`,\n    };\n\n    // ‚úÖ PURGE ALL old system messages (critical when switching models)\n    // Remove all existing system messages to avoid confusion\n    const oldSystemCount = this.messages.filter(m => m.role === 'system').length;\n    debugLog.log(`üóëÔ∏è  BEFORE purge: ${oldSystemCount} system message(s), total: ${this.messages.length} messages`);\n    \n    this.messages = this.messages.filter(m => m.role !== 'system');\n    debugLog.log(`üóëÔ∏è  AFTER purge: ${this.messages.length} messages remaining (no system)`);\n    \n    // Add the new system message at the beginning\n    this.messages.unshift(systemMessage);\n    \n    const newSystemCount = this.messages.filter(m => m.role === 'system').length;\n    debugLog.log(`‚úÖ System message added: model=\"${currentModel}\", now ${newSystemCount} system message(s), total: ${this.messages.length} messages`);\n  }\n\n  private async persist(entry: ChatEntry) {\n    if (!this.persistSession) return;\n    try {\n      await appendChatEntry(entry);\n    } catch {}\n  }\n\n  /**\n   * Restore message context from previously saved chat history\n   */\n  restoreFromHistory(entries: ChatEntry[]): void {\n    if (!entries || entries.length === 0) return;\n    for (const entry of entries) {\n      try {\n        if (entry.type === \"user\") {\n          this.messages.push({ role: \"user\", content: entry.content });\n        } else if (entry.type === \"assistant\") {\n          this.messages.push({\n            role: \"assistant\",\n            content: entry.content,\n            tool_calls: entry.toolCalls as any,\n          } as any);\n        } else if (entry.type === \"tool_result\" && entry.toolCall) {\n          // ‚úÖ For Mistral: include \"name\" field (required by their API)\n          const toolMessage: any = {\n            role: \"tool\",\n            content: entry.content,\n            tool_call_id: entry.toolCall.id,\n          };\n          \n          // Add \"name\" field for Mistral (required by their API spec)\n          const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n          if (currentProvider === 'mistral') {\n            toolMessage.name = entry.toolCall.function?.name || 'unknown';\n          }\n          \n          this.messages.push(toolMessage);\n        }\n      } catch {}\n    }\n  }\n\n  private async initializeMCP(): Promise<void> {\n    // Initialize MCP in the background without blocking\n    Promise.resolve().then(async () => {\n      try {\n        const config = loadMCPConfig();\n        if (config.servers.length > 0) {\n          await initializeMCPServers();\n        }\n      } catch (error) {\n        console.warn(\"MCP initialization failed:\", error);\n      } finally {\n        this.mcpInitialized = true;\n      }\n    });\n  }\n\n  private isGrokModel(): boolean {\n    const currentModel = this.grokClient.getCurrentModel();\n    return currentModel.toLowerCase().includes(\"grok\");\n  }\n\n  // Heuristic: enable web search only when likely needed\n  private shouldUseSearchFor(message: string): boolean {\n    const q = message.toLowerCase();\n    const keywords = [\n      \"today\",\n      \"latest\",\n      \"news\",\n      \"trending\",\n      \"breaking\",\n      \"current\",\n      \"now\",\n      \"recent\",\n      \"x.com\",\n      \"twitter\",\n      \"tweet\",\n      \"what happened\",\n      \"as of\",\n      \"update on\",\n      \"release notes\",\n      \"changelog\",\n      \"price\",\n    ];\n    if (keywords.some((k) => q.includes(k))) return true;\n    // crude date pattern (e.g., 2024/2025) may imply recency\n    if (/(20\\d{2})/.test(q)) return true;\n    return false;\n  }\n\n  private buildSummaryPrompt(lastUserMessage: string): string {\n    return [\n      \"Tu as peut-√™tre utilis√© des outils (lecture de fichiers, commandes bash, timeline, etc.)\",\n      \"pour r√©pondre √† la DERNI√àRE question de l‚Äôutilisateur.\",\n      \"\",\n      `Derni√®re question de l‚Äôutilisateur : \"${lastUserMessage}\"`,\n      \"\",\n      \"Maintenant, r√©dige une r√©ponse NATURELLE en fran√ßais qui :\",\n      \"- Explique ce que tu as fait (y compris les outils utilis√©s le cas √©ch√©ant).\",\n      \"- Pr√©sente les principaux r√©sultats et conclusions.\",\n      \"- Mentionne les difficult√©s √©ventuelles et comment tu les as r√©solues.\",\n      \"- Termine par un r√©sum√© qui met clairement en √©vidence tous les points importants de ce que tu as fait et trouv√© (longueur libre mais suffisamment exhaustive pour que l‚Äôutilisateur comprenne bien l‚Äôensemble).\",\n      \"\",\n      \"CONTRAINTES IMPORTANTES :\",\n      \"- Ne propose PAS de nouveaux tools dans cette r√©ponse.\",\n      \"- Ne repose PAS la question √† l‚Äôutilisateur.\",\n      \"- Ne commence PAS par \\\"Plan:\\\" ou par une section de plan; ne r√©p√®te PAS ton plan dans plusieurs blocs.\",\n      \"- Contente-toi d‚Äôexpliquer ce que tu as fait et ce que tu as appris.\"\n    ].join(\"\\n\");\n  }\n\n  private async generateAndAppendSummary(lastUserMessage: string): Promise<ChatEntry | null> {\n    try {\n      const prompt = this.buildSummaryPrompt(lastUserMessage);\n      const summaryMessages: GrokMessage[] = [\n        ...this.messages,\n        { role: \"user\", content: prompt }\n      ];\n\n      const response = await this.grokClient.chat(\n        summaryMessages,\n        [],\n        undefined,\n        { search_parameters: { mode: \"off\" } }\n      );\n\n      const content = response.choices?.[0]?.message?.content?.trim();\n      if (!content) {\n        return null;\n      }\n\n      const entry: ChatEntry = {\n        type: \"assistant\",\n        content,\n        timestamp: new Date(),\n      };\n\n      this.chatHistory.push(entry);\n      await this.persist(entry);\n\n      return entry;\n    } catch (error: any) {\n      debugLog.log(\"‚ö†Ô∏è  Summary phase failed:\", error?.message || String(error));\n      return null;\n    }\n  }\n\n  async processUserMessage(message: string): Promise<ChatEntry[]> {\n    // Add user message to conversation\n    const userEntry: ChatEntry = {\n      type: \"user\",\n      content: message,\n      timestamp: new Date(),\n    };\n    this.chatHistory.push(userEntry);\n    await this.persist(userEntry);\n    this.messages.push({ role: \"user\", content: message });\n    \n    // üïê Timeline: Capture user message\n    try {\n      const session = sessionManager.getCurrentSession();\n      if (session) {\n        await this.llmHook.captureUserMessage(\n          message,\n          session.id,\n          this.grokClient.getCurrentModel(),\n          providerManager.detectProvider(this.grokClient.getCurrentModel())\n        );\n      }\n    } catch (error) {\n      // Don't fail the request if timeline logging fails\n      debugLog.log('‚ö†Ô∏è  Timeline logging failed for user message:', error);\n    }\n\n    const newEntries: ChatEntry[] = [userEntry];\n    const maxToolRounds = this.maxToolRounds; // Prevent infinite loops\n    let toolRounds = 0;\n    let hadToolCalls = false;\n    let finalAssistantContent = \"\";\n\n    try {\n      const tools = await getAllGrokTools();\n      let currentResponse = await this.grokClient.chat(\n        this.messages,\n        tools,\n        undefined,\n        this.isGrokModel() && this.shouldUseSearchFor(message)\n          ? { search_parameters: { mode: \"auto\" } }\n          : { search_parameters: { mode: \"off\" } }\n      );\n\n      // Agent loop - continue until no more tool calls or max rounds reached\n      while (toolRounds < maxToolRounds) {\n        const assistantMessage = currentResponse.choices[0]?.message;\n\n        if (!assistantMessage) {\n          throw new Error(\"No response from Grok\");\n        }\n\n        // Handle tool calls\n        if (\n          assistantMessage.tool_calls &&\n          assistantMessage.tool_calls.length > 0\n        ) {\n          toolRounds++;\n          hadToolCalls = true;\n\n          // Add assistant message with tool calls\n          const assistantEntry: ChatEntry = {\n            type: \"assistant\",\n            content: assistantMessage.content || \"Using tools to help you...\",\n            timestamp: new Date(),\n            toolCalls: assistantMessage.tool_calls,\n          };\n          this.chatHistory.push(assistantEntry);\n          await this.persist(assistantEntry);\n          newEntries.push(assistantEntry);\n\n          // Add assistant message to conversation\n          this.messages.push({\n            role: \"assistant\",\n            content: assistantMessage.content || \"\",\n            tool_calls: assistantMessage.tool_calls,\n          } as any);\n\n          // Create initial tool call entries to show tools are being executed\n          assistantMessage.tool_calls.forEach((toolCall) => {\n            const toolCallEntry: ChatEntry = {\n              type: \"tool_call\",\n              content: \"Executing...\",\n              timestamp: new Date(),\n              toolCall: toolCall,\n            };\n            this.chatHistory.push(toolCallEntry);\n            newEntries.push(toolCallEntry);\n          });\n\n          // Execute tool calls and update the entries\n          for (const toolCall of assistantMessage.tool_calls) {\n            const result = await this.executeTool(toolCall);\n\n            // Update the existing tool_call entry with the result\n            const entryIndex = this.chatHistory.findIndex(\n              (entry) =>\n                entry.type === \"tool_call\" && entry.toolCall?.id === toolCall.id\n            );\n\n            if (entryIndex !== -1) {\n              const updatedEntry: ChatEntry = {\n                ...this.chatHistory[entryIndex],\n                type: \"tool_result\",\n                content: result.success\n                  ? result.output || \"Success\"\n                  : result.error || \"Error occurred\",\n                toolResult: result,\n              };\n              this.chatHistory[entryIndex] = updatedEntry;\n              await this.persist(updatedEntry);\n\n              // Also update in newEntries for return value\n              const newEntryIndex = newEntries.findIndex(\n                (entry) =>\n                  entry.type === \"tool_call\" &&\n                  entry.toolCall?.id === toolCall.id\n              );\n              if (newEntryIndex !== -1) {\n                newEntries[newEntryIndex] = updatedEntry;\n              }\n            }\n\n            // Add tool result to messages with proper format (needed for AI context)\n            // ‚úÖ For Mistral: include \"name\" field (required by their API)\n            const toolMessage: any = {\n              role: \"tool\",\n              content: result.success\n                ? result.output || \"Success\"\n                : result.error || \"Error\",\n              tool_call_id: toolCall.id,\n            };\n            \n            // Add \"name\" field for Mistral (required by their API spec)\n            const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n            if (currentProvider === 'mistral') {\n              toolMessage.name = toolCall.function.name;\n            }\n            \n            this.messages.push(toolMessage);\n          }\n\n          // Get next response - this might contain more tool calls\n          currentResponse = await this.grokClient.chat(\n            this.messages,\n            tools,\n            undefined,\n            this.isGrokModel() && this.shouldUseSearchFor(message)\n              ? { search_parameters: { mode: \"auto\" } }\n              : { search_parameters: { mode: \"off\" } }\n          );\n        } else {\n          // No more tool calls, add final response\n          const finalEntry: ChatEntry = {\n            type: \"assistant\",\n            content:\n              assistantMessage.content ||\n              \"I understand, but I don't have a specific response.\",\n            timestamp: new Date(),\n          };\n          finalAssistantContent = assistantMessage.content || \"\";\n          this.chatHistory.push(finalEntry);\n          await this.persist(finalEntry);\n          this.messages.push({\n            role: \"assistant\",\n            content: assistantMessage.content || \"\",\n          });\n          newEntries.push(finalEntry);\n          \n          // üïê Timeline: Capture assistant message\n          try {\n            const session = sessionManager.getCurrentSession();\n            if (session) {\n              await this.llmHook.captureAssistantMessage(\n                assistantMessage.content || \"\",\n                session.id,\n                this.grokClient.getCurrentModel(),\n                providerManager.detectProvider(this.grokClient.getCurrentModel())\n              );\n            }\n          } catch (error) {\n            debugLog.log('‚ö†Ô∏è  Timeline logging failed for assistant message:', error);\n          }\n          \n          break; // Exit the loop\n        }\n      }\n\n      if (toolRounds >= maxToolRounds) {\n        const warningEntry: ChatEntry = {\n          type: \"assistant\",\n          content:\n            \"Maximum tool execution rounds reached. Stopping to prevent infinite loops.\",\n          timestamp: new Date(),\n        };\n        this.chatHistory.push(warningEntry);\n        await this.persist(warningEntry);\n        newEntries.push(warningEntry);\n      }\n\n      if (hadToolCalls) {\n        const contentTrimmed = finalAssistantContent.trim();\n        \n        // Skip synth√®se pour le placeholder par d√©faut (GPT-5/o1)\n        if (contentTrimmed === \"Using tools to help you...\") {\n          debugLog.log(\"‚è≠Ô∏è  Skipping summary (placeholder message, waiting for streaming completion)\");\n          return newEntries;\n        }\n        \n        // G√©n√©rer synth√®se si :\n        // - R√©ponse vide\n        // - R√©ponse trop courte (< 150 caract√®res)\n        const needsSummary =\n          !contentTrimmed ||\n          contentTrimmed.length < 150;\n        \n        if (needsSummary) {\n          debugLog.log(\"‚ö†Ô∏è  Generating summary (insufficient LLM response detected)\");\n          const summaryEntry = await this.generateAndAppendSummary(message);\n          if (summaryEntry) {\n            newEntries.push(summaryEntry);\n          }\n        } else {\n          debugLog.log(\"‚úÖ LLM provided sufficient response, skipping summary\");\n        }\n      }\n\n      return newEntries;\n    } catch (error: any) {\n      const errorEntry: ChatEntry = {\n        type: \"assistant\",\n        content: `Sorry, I encountered an error: ${error.message}`,\n        timestamp: new Date(),\n      };\n      this.chatHistory.push(errorEntry);\n      await this.persist(errorEntry);\n      newEntries.push(errorEntry);\n      \n      // üïê Timeline: Capture LLM error\n      try {\n        const session = sessionManager.getCurrentSession();\n        if (session) {\n          await this.llmHook.captureError(\n            error,\n            session.id,\n            this.grokClient.getCurrentModel(),\n            providerManager.detectProvider(this.grokClient.getCurrentModel())\n          );\n          }\n      } catch (timelineError) {\n        debugLog.log('‚ö†Ô∏è  Timeline logging failed for LLM error:', timelineError);\n      }\n\n      return newEntries;\n    }\n  }\n\n  private messageReducer(previous: any, item: any): any {\n    const reduce = (acc: any, delta: any) => {\n      acc = { ...acc };\n      for (const [key, value] of Object.entries(delta)) {\n        if (acc[key] === undefined || acc[key] === null) {\n          acc[key] = value;\n          // Clean up index properties from tool calls\n          if (Array.isArray(acc[key])) {\n            for (const arr of acc[key]) {\n              delete arr.index;\n            }\n          }\n        } else if (typeof acc[key] === \"string\" && typeof value === \"string\") {\n          (acc[key] as string) += value;\n        } else if (Array.isArray(acc[key]) && Array.isArray(value)) {\n          const accArray = acc[key] as any[];\n          for (let i = 0; i < value.length; i++) {\n            if (!accArray[i]) accArray[i] = {};\n            accArray[i] = reduce(accArray[i], value[i]);\n          }\n        } else if (typeof acc[key] === \"object\" && typeof value === \"object\") {\n          acc[key] = reduce(acc[key], value);\n        }\n      }\n      return acc;\n    };\n\n    return reduce(previous, item.choices[0]?.delta || {});\n  }\n\n  async *processUserMessageStream(\n    message: string\n  ): AsyncGenerator<StreamingChunk, void, unknown> {\n    // Create new abort controller for this request\n    this.abortController = new AbortController();\n\n    // Add user message to conversation\n    const userEntry: ChatEntry = {\n      type: \"user\",\n      content: message,\n      timestamp: new Date(),\n    };\n    this.chatHistory.push(userEntry);\n    await this.persist(userEntry);\n    this.messages.push({ role: \"user\", content: message });\n\n    // Calculate input tokens\n    let inputTokens = this.tokenCounter.countMessageTokens(\n      this.messages as any\n    );\n    yield {\n      type: \"token_count\",\n      tokenCount: inputTokens,\n    };\n\n    const maxToolRounds = this.maxToolRounds; // Prevent infinite loops\n    let toolRounds = 0;\n    let totalOutputTokens = 0;\n    let lastTokenUpdate = 0;\n    let hadToolCalls = false;\n    let finalAssistantContent = \"\";\n\n    try {\n      // Agent loop - continue until no more tool calls or max rounds reached\n      while (toolRounds < maxToolRounds) {\n        // Check if operation was cancelled\n        if (this.abortController?.signal.aborted) {\n          yield {\n            type: \"content\",\n            content: \"\\n\\n[Operation cancelled by user]\",\n          };\n          yield { type: \"done\" };\n          return;\n        }\n\n        // Stream response and accumulate\n        const tools = await getAllGrokTools();\n        const stream = this.grokClient.chatStream(\n          this.messages,\n          tools,\n          undefined,\n          this.isGrokModel() && this.shouldUseSearchFor(message)\n            ? { search_parameters: { mode: \"auto\" } }\n            : { search_parameters: { mode: \"off\" } }\n        );\n        let accumulatedMessage: any = {};\n        let accumulatedContent = \"\";\n        let bufferedContent = \"\";\n        let lastContentFlush = 0;\n        let toolCallsYielded = false;\n\n        for await (const chunk of stream) {\n          // Check for cancellation in the streaming loop\n          if (this.abortController?.signal.aborted) {\n            yield {\n              type: \"content\",\n              content: \"\\n\\n[Operation cancelled by user]\",\n            };\n            yield { type: \"done\" };\n            return;\n          }\n\n          if (!chunk.choices?.[0]) continue;\n\n          // Accumulate the message using reducer\n          accumulatedMessage = this.messageReducer(accumulatedMessage, chunk);\n\n          // Check for tool calls - yield when we have complete tool calls with function names\n          if (!toolCallsYielded && accumulatedMessage.tool_calls?.length > 0) {\n            hadToolCalls = true;\n            // Check if we have at least one complete tool call with a function name\n            const hasCompleteTool = accumulatedMessage.tool_calls.some(\n              (tc: any) => tc.function?.name\n            );\n            if (hasCompleteTool) {\n              yield {\n                type: \"tool_calls\",\n                toolCalls: accumulatedMessage.tool_calls,\n              };\n              toolCallsYielded = true;\n            }\n          }\n\n          // Stream content as it comes (buffered to reduce flicker)\n          if (chunk.choices[0].delta?.content) {\n                  const deltaText = chunk.choices[0].delta.content;\n            bufferedContent += deltaText;\n\n            const now = Date.now();\n            if (now - lastContentFlush > 500 || bufferedContent.length > 2000) {\n              // Flush buffered content in batches\n              yield { type: \"content\", content: bufferedContent };\n              accumulatedContent += bufferedContent;\n              bufferedContent = \"\";\n              lastContentFlush = now;\n\n              // Update token count in real-time including accumulated content and any tool calls\n              const currentOutputTokens =\n                this.tokenCounter.estimateStreamingTokens(accumulatedContent) +\n                (accumulatedMessage.tool_calls\n                  ? this.tokenCounter.countTokens(\n                      JSON.stringify(accumulatedMessage.tool_calls)\n                    )\n                  : 0);\n              totalOutputTokens = currentOutputTokens;\n\n              // Emit token count update (throttled)\n              if (now - lastTokenUpdate > 2500) {\n                lastTokenUpdate = now;\n                yield {\n                  type: \"token_count\",\n                  tokenCount: inputTokens + totalOutputTokens,\n                };\n              }\n            }\n          }\n      }\n\n        // Final content flush after stream completes\n        if (bufferedContent) {\n          yield { type: \"content\", content: bufferedContent };\n          accumulatedContent += bufferedContent;\n          bufferedContent = \"\";\n        }\n\n        // Add assistant entry to history\n        const assistantEntry: ChatEntry = {\n          type: \"assistant\",\n          content: accumulatedMessage.content || \"Using tools to help you...\",\n          timestamp: new Date(),\n          toolCalls: accumulatedMessage.tool_calls || undefined,\n        };\n        finalAssistantContent = accumulatedMessage.content || \"\";\n        this.chatHistory.push(assistantEntry);\n        await this.persist(assistantEntry);\n\n        // Add accumulated message to conversation\n        this.messages.push({\n          role: \"assistant\",\n          content: accumulatedMessage.content || \"\",\n          tool_calls: accumulatedMessage.tool_calls,\n        } as any);\n\n        // Handle tool calls if present\n        if (accumulatedMessage.tool_calls?.length > 0) {\n          toolRounds++;\n\n          // Only yield tool_calls if we haven't already yielded them during streaming\n          if (!toolCallsYielded) {\n            yield {\n              type: \"tool_calls\",\n              toolCalls: accumulatedMessage.tool_calls,\n            };\n          }\n\n          // Execute tools\n          for (const toolCall of accumulatedMessage.tool_calls) {\n            // Check for cancellation before executing each tool\n            if (this.abortController?.signal.aborted) {\n              yield {\n                type: \"content\",\n                content: \"\\n\\n[Operation cancelled by user]\",\n              };\n              yield { type: \"done\" };\n              return;\n            }\n\n            const result = await this.executeTool(toolCall);\n\n            const toolResultEntry: ChatEntry = {\n              type: \"tool_result\",\n              content: result.success\n                ? result.output || \"Success\"\n                : result.error || \"Error occurred\",\n              timestamp: new Date(),\n              toolCall: toolCall,\n              toolResult: result,\n            };\n            this.chatHistory.push(toolResultEntry);\n            await this.persist(toolResultEntry);\n\n            yield {\n              type: \"tool_result\",\n              toolCall,\n              toolResult: result,\n            };\n\n            // Add tool result with proper format (needed for AI context)\n            // ‚úÖ For Mistral: include \"name\" field (required by their API)\n            const toolMessage: any = {\n              role: \"tool\",\n              content: result.success\n                ? result.output || \"Success\"\n                : result.error || \"Error\",\n              tool_call_id: toolCall.id,\n            };\n            \n            // Add \"name\" field for Mistral (required by their API spec)\n            const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n            if (currentProvider === 'mistral') {\n              toolMessage.name = toolCall.function.name;\n            }\n            \n            this.messages.push(toolMessage);\n          }\n\n          // Update token count after processing all tool calls to include tool results\n          inputTokens = this.tokenCounter.countMessageTokens(\n            this.messages as any\n          );\n          // Final token update after tools processed\n          yield {\n            type: \"token_count\",\n            tokenCount: inputTokens + totalOutputTokens,\n          };\n\n          // Continue the loop to get the next response (which might have more tool calls)\n        } else {\n          // No tool calls, we're done\n          break;\n        }\n      }\n\n      if (toolRounds >= maxToolRounds) {\n        yield {\n          type: \"content\",\n          content:\n            \"\\n\\nMaximum tool execution rounds reached. Stopping to prevent infinite loops.\",\n        };\n      }\n\n      if (hadToolCalls) {\n        const contentTrimmed = finalAssistantContent.trim();\n        \n        // Skip synth√®se pour le placeholder par d√©faut (GPT-5/o1)\n        if (contentTrimmed === \"Using tools to help you...\") {\n          debugLog.log(\"‚è≠Ô∏è  Skipping summary (placeholder message, waiting for streaming completion)\");\n          yield { type: \"done\" };\n          return;\n        }\n        \n        // G√©n√©rer synth√®se si :\n        // - R√©ponse vide\n        // - R√©ponse trop courte (< 150 caract√®res)\n        const needsSummary =\n          !contentTrimmed ||\n          contentTrimmed.length < 150;\n        \n        if (needsSummary) {\n          debugLog.log(\"‚ö†Ô∏è  Generating summary (insufficient LLM response detected)\");\n          const summaryEntry = await this.generateAndAppendSummary(message);\n          if (summaryEntry) {\n            yield {\n              type: \"content\",\n              content: \"\\n\\n\" + summaryEntry.content,\n            };\n          }\n        } else {\n          debugLog.log(\"‚úÖ LLM provided sufficient response, skipping summary\");\n        }\n      }\n\n      yield { type: \"done\" };\n    } catch (error: any) {\n      // Check if this was a cancellation\n      if (this.abortController?.signal.aborted) {\n        yield {\n          type: \"content\",\n          content: \"\\n\\n[Operation cancelled by user]\",\n        };\n        yield { type: \"done\" };\n        return;\n      }\n\n      const errorEntry: ChatEntry = {\n        type: \"assistant\",\n        content: `Sorry, I encountered an error: ${error.message}`,\n        timestamp: new Date(),\n      };\n      this.chatHistory.push(errorEntry);\n      await this.persist(errorEntry);\n      yield {\n        type: \"content\",\n        content: errorEntry.content,\n      };\n      yield { type: \"done\" };\n    } finally {\n      // Clean up abort controller\n      this.abortController = null;\n    }\n  }\n\n  private async executeTool(toolCall: GrokToolCall): Promise<ToolResult> {\n    const startTime = Date.now();\n    let startEventId: string = '';\n    \n    // üì∫ ExecutionViewer: Create execution stream\n    const executionStream = executionManager.createExecution(toolCall.function.name);\n    this.currentExecutionStream = executionStream;\n    \n    // üì∫ COT: Initial thinking\n    executionStream.emitCOT('thinking', `Executing tool: ${toolCall.function.name}`);\n    \n    // üïê Timeline: Capture tool call started\n    try {\n      const session = sessionManager.getCurrentSession();\n      if (session) {\n        const args = JSON.parse(toolCall.function.arguments);\n        startEventId = await this.toolHook.captureToolCallStarted(\n          toolCall.function.name,\n          args,\n          session.id\n        );\n      }\n    } catch (error) {\n      debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool start:', error);\n    }\n    \n    try {\n      const args = JSON.parse(toolCall.function.arguments);\n      \n      // üì∫ COT: Action with arguments\n      const argsPreview = JSON.stringify(args, null, 2).substring(0, 200);\n      executionStream.emitCOT('action', `Arguments: ${argsPreview}${argsPreview.length >= 200 ? '...' : ''}`);\n\n      let result: ToolResult;\n      \n      switch (toolCall.function.name) {\n        case \"view_file\":\n          // üì∫ COT: Reading file\n          executionStream.emitCOT('thinking', `Reading file: ${args.path}`);\n          executionStream.emitCOT('action', `Opening file for reading`);\n          \n          const range: [number, number] | undefined =\n            args.start_line && args.end_line\n              ? [args.start_line, args.end_line]\n              : undefined;\n          \n          if (range) {\n            executionStream.emitCOT('action', `Reading lines ${range[0]}-${range[1]}`);\n          }\n          \n          result = await this.textEditor.view(args.path, range);\n          \n          // üì∫ COT: Observation with file stats\n          if (result.success) {\n            const lineCount = result.output?.split('\\n').length || 0;\n            const charCount = result.output?.length || 0;\n            executionStream.emitCOT('observation', `Read ${lineCount} lines, ${charCount} characters`);\n            executionStream.emitCOT('decision', `File content retrieved successfully`);\n          } else {\n            executionStream.emitCOT('observation', `Failed to read file: ${result.error}`);\n            executionStream.emitCOT('decision', `File reading failed`);\n          }\n          break;\n\n        case \"create_file\":\n          result = await this.textEditor.create(args.path, args.content);\n          break;\n\n        case \"str_replace_editor\":\n          result = await this.textEditor.strReplace(\n            args.path,\n            args.old_str,\n            args.new_str,\n            args.replace_all\n          );\n          break;\n\n        case \"edit_file\":\n          if (!this.morphEditor) {\n            result = {\n              success: false,\n              error:\n                \"Morph Fast Apply not available. Please set MORPH_API_KEY environment variable to use this feature.\",\n            };\n          } else {\n            result = await this.morphEditor.editFile(\n              args.target_file,\n              args.instructions,\n              args.code_edit\n            );\n          }\n          break;\n\n        case \"bash\":\n          // üì∫ ExecutionViewer: Special handling for bash to capture output streaming\n          executionStream.emitCOT('action', `Running command: ${args.command}`);\n          executionStream.startCommand(args.command);\n          \n          result = await this.bash.execute(args.command);\n          \n          // üì∫ Capture stdout lines\n          if (result.output) {\n            const lines = result.output.split('\\n');\n            lines.forEach(line => {\n              if (line.trim()) {\n                executionStream.commandOutput(line);\n              }\n            });\n          }\n          \n          // üì∫ Capture stderr lines separately (if any)\n          if (result.stderr) {\n            const stderrLines = result.stderr.split('\\n');\n            stderrLines.forEach(line => {\n              if (line.trim()) {\n                executionStream.commandOutput(`[STDERR] ${line}`);\n              }\n            });\n          }\n          \n          // üì∫ End command with actual exit code\n          executionStream.endCommand(\n            result.exitCode || (result.success ? 0 : 1),\n            result.error\n          );\n          \n          // üì∫ COT with detailed observation\n          const hasStderr = result.stderr && result.stderr.length > 0;\n          const observation = result.success \n            ? `Command succeeded (${result.output?.split('\\n').length || 0} stdout lines${hasStderr ? `, ${result.stderr.split('\\n').length} stderr lines` : ''})`\n            : `Command failed (exit ${result.exitCode || 1}): ${result.error}`;\n          \n          executionStream.emitCOT('observation', observation);\n          break;\n\n        case \"create_todo_list\":\n          result = await this.todoTool.createTodoList(args.todos);\n          break;\n\n        case \"update_todo_list\":\n          result = await this.todoTool.updateTodoList(args.updates);\n          break;\n\n        case \"search\":\n          result = await this.search.search(args.query, {\n            searchType: args.search_type,\n            includePattern: args.include_pattern,\n            excludePattern: args.exclude_pattern,\n            caseSensitive: args.case_sensitive,\n            wholeWord: args.whole_word,\n            regex: args.regex,\n            maxResults: args.max_results,\n            fileTypes: args.file_types,\n            includeHidden: args.include_hidden,\n          });\n          break;\n        case \"apply_patch\":\n          if (!this.applyPatch) {\n            const mod = await import(\"../tools/apply-patch.js\");\n            this.applyPatch = new mod.ApplyPatchTool();\n          }\n          result = await this.applyPatch.apply(args.patch, !!args.dry_run);\n          break;\n\n        case \"get_my_identity\":\n          const getMyIdentity = await import(\"../tools/get-my-identity.js\");\n          result = await getMyIdentity.get_my_identity(args, this);\n          break;\n        \n        // ============================================\n        // SESSION MANAGEMENT TOOLS\n        // ============================================\n        \n        case \"session_list\": {\n          const sessionTools = await import('../tools/session-tools.js');\n          result = await sessionTools.executeSessionList();\n          break;\n        }\n        \n        case \"session_switch\": {\n          const switchArgs = JSON.parse(toolCall.function.arguments) as { session_id: number };\n          const sessionTools = await import('../tools/session-tools.js');\n          result = await sessionTools.executeSessionSwitch(switchArgs);\n          \n          if (result.success) {\n            // Update agent's context after switch\n            const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n            const currentSession = sessionManager.getCurrentSession();\n            \n            if (currentSession) {\n              const { providerManager } = await import('../utils/provider-manager.js');\n              const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n              \n              if (providerConfig) {\n                await this.switchToModel(\n                  currentSession.default_model,\n                  this.getApiKey(),\n                  providerConfig.baseURL\n                );\n              }\n            }\n          }\n          break;\n        }\n        \n        case \"session_new\": {\n          const newArgs = JSON.parse(toolCall.function.arguments);\n          const sessionTools = await import('../tools/session-tools.js');\n          result = await sessionTools.executeSessionNew(newArgs);\n          \n          if (result.success) {\n            // Update agent's context\n            const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n            const currentSession = sessionManager.getCurrentSession();\n            \n            if (currentSession) {\n              const { providerManager } = await import('../utils/provider-manager.js');\n              const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n              \n              if (providerConfig) {\n                await this.switchToModel(\n                  currentSession.default_model,\n                  this.getApiKey(),\n                  providerConfig.baseURL\n                );\n              }\n            }\n          }\n          break;\n        }\n        \n        case \"session_rewind\": {\n          const rewindArgs = JSON.parse(toolCall.function.arguments);\n          const sessionTools = await import('../tools/session-tools.js');\n          result = await sessionTools.executeSessionRewind(rewindArgs);\n          \n          if (result.success) {\n            // Update agent's context\n            const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n            const currentSession = sessionManager.getCurrentSession();\n            \n            if (currentSession) {\n              const { providerManager } = await import('../utils/provider-manager.js');\n              const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n              \n              if (providerConfig) {\n                await this.switchToModel(\n                  currentSession.default_model,\n                  this.getApiKey(),\n                  providerConfig.baseURL\n                );\n              }\n            }\n          }\n          break;\n        }\n        \n        // ============================================\n        // TIMELINE & TIME MACHINE TOOLS\n        // ============================================\n        \n        case \"timeline_query\": {\n          const queryArgs = JSON.parse(toolCall.function.arguments);\n          const { executeTimelineQuery } = await import('../tools/timeline-query-tool.js');\n          result = await executeTimelineQuery(queryArgs);\n          break;\n        }\n        \n        case \"rewind_to\": {\n          const rewindArgs = JSON.parse(toolCall.function.arguments);\n          const { executeRewindTo } = await import('../tools/rewind-to-tool.js');\n          result = await executeRewindTo(rewindArgs);\n          break;\n        }\n        \n        case \"list_time_points\": {\n          const { getAvailableTimePoints } = await import('../tools/rewind-to-tool.js');\n          const timePoints = await getAvailableTimePoints();\n          result = { success: true, ...timePoints };\n          break;\n        }\n\n        default:\n          // Check if this is an MCP tool\n          if (toolCall.function.name.startsWith(\"mcp__\")) {\n            result = await this.executeMCPTool(toolCall);\n          } else {\n            result = {\n              success: false,\n              error: `Unknown tool: ${toolCall.function.name}`,\n            };\n          }\n      }\n      \n      // üì∫ ExecutionViewer: Final decision COT\n      executionStream.emitCOT(\n        'decision',\n        result.success \n          ? `‚úÖ Tool execution succeeded` \n          : `‚ùå Tool execution failed: ${result.error}`\n      );\n      \n      // üì∫ Complete the execution\n      executionStream.complete({\n        success: result.success,\n        output: result.output,\n        error: result.error,\n      });\n      \n      // üïê Timeline: Capture tool call success\n      try {\n        const session = sessionManager.getCurrentSession();\n        if (session) {\n          const duration = Date.now() - startTime;\n          if (result.success) {\n            await this.toolHook.captureToolCallSuccess(\n              toolCall.function.name,\n              args,\n              result.output || result.error || 'Success',\n              session.id,\n              duration,\n              startEventId\n            );\n          } else {\n            await this.toolHook.captureToolCallFailed(\n              toolCall.function.name,\n              args,\n              result.error || 'Unknown error',\n              session.id,\n              duration,\n              startEventId\n            );\n          }\n        }\n      } catch (error) {\n        debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool result:', error);\n      }\n      \n      this.currentExecutionStream = null;\n      return result;\n    } catch (error: any) {\n      const duration = Date.now() - startTime;\n      const errorResult: ToolResult = {\n        success: false,\n        error: `Tool execution error: ${error.message}`,\n      };\n      \n      // üì∫ ExecutionViewer: Fail the execution\n      if (executionStream) {\n        executionStream.emitCOT('decision', `‚ùå Exception: ${error.message}`);\n        executionStream.fail(error.message);\n      }\n      \n      // üïê Timeline: Capture tool call failed\n      try {\n        const session = sessionManager.getCurrentSession();\n        if (session) {\n          const args = JSON.parse(toolCall.function.arguments);\n          await this.toolHook.captureToolCallFailed(\n            toolCall.function.name,\n            args,\n            error.message,\n            session.id,\n            duration,\n            startEventId\n          );\n        }\n      } catch (timelineError) {\n        debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool error:', timelineError);\n      }\n      \n      this.currentExecutionStream = null;\n      return errorResult;\n    }\n  }\n\n  private async executeMCPTool(toolCall: GrokToolCall): Promise<ToolResult> {\n    try {\n      const args = JSON.parse(toolCall.function.arguments);\n      const mcpManager = getMCPManager();\n\n      const result = await mcpManager.callTool(toolCall.function.name, args);\n\n      if (result.isError) {\n        return {\n          success: false,\n          error: (result.content[0] as any)?.text || \"MCP tool error\",\n        };\n      }\n\n      // Extract content from result\n      const output = result.content\n        .map((item) => {\n          if (item.type === \"text\") {\n            return item.text;\n          } else if (item.type === \"resource\") {\n            return `Resource: ${item.resource?.uri || \"Unknown\"}`;\n          }\n          return String(item);\n        })\n        .join(\"\\n\");\n\n      return {\n        success: true,\n        output: output || \"Success\",\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        error: `MCP tool execution error: ${error.message}`,\n      };\n    }\n  }\n\n  getChatHistory(): ChatEntry[] {\n    return [...this.chatHistory];\n  }\n\n  getCurrentDirectory(): string {\n    return this.bash.getCurrentDirectory();\n  }\n\n  async executeBashCommand(command: string): Promise<ToolResult> {\n    return await this.bash.execute(command);\n  }\n\n  getCurrentModel(): string {\n    return this.grokClient.getCurrentModel();\n  }\n\n  setModel(model: string): void {\n    this.grokClient.setModel(model);\n    // Update token counter for new model\n    this.tokenCounter.dispose();\n    this.tokenCounter = createTokenCounter(model);\n    // Persist state (best-effort)\n    saveState({ version: 1, model, cwd: process.cwd() }).catch(() => {});\n  }\n  \n  // ‚úÖ NEW: Get API key\n  getApiKey(): string {\n    return this.grokClient.getApiKey();\n  }\n  \n  // ‚úÖ NEW: Switch to different model with new API key and baseURL\n  // Used when changing providers (e.g., Grok ‚Üí Claude)\n  async switchToModel(model: string, apiKey: string, baseURL: string): Promise<string> {\n    debugLog.log(`üîß GrokAgent.switchToModel: model=${model}, baseURL=${baseURL}, apiKey=${apiKey.slice(0,10)}...`);\n    \n    // Recreate client with new config\n    this.grokClient = new GrokClient(apiKey, model, baseURL);\n    \n    debugLog.log(`‚úÖ GrokClient recreated with baseURL=${baseURL}`);\n    \n    // Update token counter\n    this.tokenCounter.dispose();\n    this.tokenCounter = createTokenCounter(model);\n    \n    // Update system message with new model name\n    this.updateSystemMessage();\n    debugLog.log(`‚úÖ System message updated for model=${model}`);\n    \n    // Inject hard reset message to prevent identity confusion\n    const provider = providerManager.detectProvider(model) || 'grok';\n    const providerConfig = providerManager.getProviderForModel(model);\n    this.messages.push({\n      role: \"user\" as const,\n      content: `[SYSTEM NOTIFICATION - MODEL SWITCHED]\n\nYou are now: ${model}\nProvider: ${providerConfig?.name || provider}\nEndpoint: ${providerConfig?.baseURL || 'unknown'}\n\n‚ö†Ô∏è CRITICAL: Ignore ALL previous model identity references in the conversation history.\nAny messages where you identified as a different model are now OBSOLETE and INCORRECT.\n\nYour CURRENT and ONLY identity is: ${model}\n\nIf you need confirmation, use the 'get_my_identity' tool.`\n    });\n    debugLog.log(`‚úÖ Hard reset message injected for identity clarity`);\n    \n    // Update session manager\n    sessionManager.switchProvider(provider, model, apiKey);\n    \n    debugLog.log(`‚úÖ Session manager updated for provider=${provider}`);\n    \n    // ‚úÖ NEW: Identity check (isolated message, no history) with timeout\n    try {\n      debugLog.log(`üîç Sending identity check to model...`);\n      \n      // Add timeout to prevent hanging on unresponsive APIs\n      const identityPromise = this.grokClient.chat(\n        [{ role: \"user\", content: \"In one short sentence, what is your exact model name and provider?\" }],\n        [], // No tools\n        undefined, // Use current model\n        undefined  // No search\n      );\n      \n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Identity check timeout after 10s')), 10000)\n      );\n      \n      const identityResponse = await Promise.race([identityPromise, timeoutPromise]) as any;\n      \n      const aiSays = identityResponse.choices[0]?.message?.content || \"No response\";\n      const apiReturned = identityResponse.model || model;\n      \n      debugLog.log(`‚úÖ AI says: \"${aiSays}\"`);\n      debugLog.log(`üìù API returned: ${apiReturned}`);\n      \n      // Return formatted identity info\n      return `ü§ñ AI Response: \"${aiSays}\"\\nüìã API Metadata: ${apiReturned}`;\n      \n    } catch (error: any) {\n      debugLog.log(`‚ö†Ô∏è  Identity check failed: ${error.message}`);\n      return `‚ö†Ô∏è  Identity check skipped (${error.message || 'timeout'}), connection established`;\n    }\n  }\n\n  abortCurrentOperation(): void {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  /**\n   * Detect provider from baseURL\n   */\n  private detectProvider(baseURL?: string): string {\n    if (!baseURL) return 'grok';\n    \n    if (baseURL.includes('anthropic')) return 'claude';\n    if (baseURL.includes('openai')) return 'openai';\n    if (baseURL.includes('mistral')) return 'mistral';\n    if (baseURL.includes('deepseek')) return 'deepseek';\n    if (baseURL.includes('x.ai')) return 'grok';\n    \n    return 'grok'; // default\n  }\n\n  /**\n   * Switch to a different provider/API key\n   */\n  switchProvider(provider: string, apiKey: string, model?: string) {\n    // Detect baseURL from provider\n    const baseUrls: Record<string, string> = {\n      grok: 'https://api.x.ai/v1',\n      claude: 'https://api.anthropic.com/v1',\n      openai: 'https://api.openai.com/v1',\n      mistral: 'https://api.mistral.ai/v1',\n      deepseek: 'https://api.deepseek.com/v1',\n    };\n\n    const baseURL = baseUrls[provider] || baseUrls.grok;\n    \n    // ‚úÖ CORRECTED: Use priority chain instead of hardcoded fallback\n    const manager = getSettingsManager();\n    const projectModel = manager.getProjectSetting(\"model\");\n    const userDefault = manager.getCurrentModel();\n    const systemDefault = \"grok-code-fast-1\";\n    \n    const modelToUse = model || projectModel || userDefault || systemDefault;\n\n    // Update client\n    this.grokClient = new GrokClient(apiKey, modelToUse, baseURL);\n    \n    // Update session manager\n    sessionManager.switchProvider(provider, modelToUse, apiKey);\n    \n    debugLog.log(`‚úÖ Switched to ${provider} (${modelToUse})`);\n  }\n}\n"
  },
  "src/grok/client.ts": {
    "path": "src/grok/client.ts",
    "hash": "8044d583185c438eba48dda047a7e433176d3984389426668546971528040cc3",
    "size": 19329,
    "timestamp": 1764704879297,
    "content": "import OpenAI from \"openai\";\nimport type { ChatCompletionMessageParam } from \"openai/resources/chat\";\nimport { debugLog } from \"../utils/debug-logger.js\";\n\nexport type GrokMessage = ChatCompletionMessageParam;\n\nexport interface GrokTool {\n  type: \"function\";\n  function: {\n    name: string;\n    description: string;\n    parameters: {\n      type: \"object\";\n      properties: Record<string, any>;\n      required: string[];\n    };\n  };\n}\n\nexport interface GrokToolCall {\n  id: string;\n  type: \"function\";\n  function: {\n    name: string;\n    arguments: string;\n  };\n}\n\nexport interface SearchParameters {\n  mode?: \"auto\" | \"on\" | \"off\";\n  // sources removed - let API use default sources to avoid format issues\n}\n\nexport interface SearchOptions {\n  search_parameters?: SearchParameters;\n}\n\nexport interface GrokResponse {\n  model?: string; // ‚úÖ Model name returned by API\n  choices: Array<{\n    message: {\n      role: string;\n      content: string | null;\n      tool_calls?: GrokToolCall[];\n    };\n    finish_reason: string;\n  }>;\n}\n\nexport class GrokClient {\n  private client: OpenAI;\n  private currentModel: string; // ‚úÖ NO HARDCODED DEFAULT\n  private defaultMaxTokens: number;\n  private apiKey: string; // ‚úÖ Store for later access\n  private baseURL: string; // ‚úÖ Store baseURL to detect provider\n\n  constructor(apiKey: string, model: string, baseURL?: string) { // ‚úÖ model REQUIRED\n    this.apiKey = apiKey; // ‚úÖ Store\n    this.baseURL = baseURL || process.env.GROK_BASE_URL || \"https://api.x.ai/v1\";\n    \n    console.log(`üèóÔ∏è  GrokClient constructor: model=${model}, baseURL=${this.baseURL}, apiKey=${apiKey.slice(0,10)}...`);\n    \n    this.client = new OpenAI({\n      apiKey,\n      baseURL: this.baseURL,\n      timeout: 360000,\n    });\n    const envMax = Number(process.env.GROK_MAX_TOKENS);\n    this.defaultMaxTokens = Number.isFinite(envMax) && envMax > 0 ? envMax : 1536;\n    this.currentModel = model; // ‚úÖ Use provided model (required)\n    \n    console.log(`‚úÖ GrokClient initialized with baseURL=${this.baseURL}`);\n  }\n  \n  /**\n   * Detect current provider from baseURL\n   */\n  private getProvider(): 'grok' | 'openai' | 'claude' | 'mistral' | 'deepseek' {\n    if (this.baseURL.includes('x.ai')) return 'grok';\n    if (this.baseURL.includes('openai.com')) return 'openai';\n    if (this.baseURL.includes('anthropic.com')) return 'claude';\n    if (this.baseURL.includes('mistral.ai')) return 'mistral';\n    if (this.baseURL.includes('deepseek.com')) return 'deepseek';\n    return 'grok'; // Default\n  }\n  \n  /**\n   * Check if current provider is Grok\n   */\n  private isGrokProvider(): boolean {\n    return this.baseURL.includes('x.ai');\n  }\n  \n  /**\n   * Check if current model is a reasoning model (o1, o3, gpt-5)\n   * These models require max_completion_tokens and no temperature\n   */\n  private isReasoningModel(model?: string): boolean {\n    const modelName = (model || this.currentModel).toLowerCase();\n    return modelName.startsWith('o1') || \n           modelName.startsWith('o3') || \n           modelName.startsWith('gpt-5');\n  }\n  \n  /**\n   * Format tools for specific provider\n   */\n  private formatToolsForProvider(tools: GrokTool[]): any[] {\n    const provider = this.getProvider();\n    \n    if (provider === 'mistral') {\n      // ‚úÖ Mistral format: Standard OpenAI-compatible with full type support\n      // According to https://docs.mistral.ai/agents/tools/function_calling\n      // Mistral supports: string, number, boolean, object, array\n      return tools.map(tool => ({\n        type: \"function\",\n        function: {\n          name: tool.function.name,\n          description: tool.function.description,\n          parameters: {\n            type: \"object\",\n            properties: tool.function.parameters.properties,  // ‚úÖ Keep original types\n            required: tool.function.parameters.required || [],\n          }\n        }\n      }));\n    }\n    \n    if (provider === 'claude') {\n      // Claude uses a different format (tools with input_schema)\n      return tools.map(tool => ({\n        name: tool.function.name,\n        description: tool.function.description,\n        input_schema: {\n          type: \"object\",\n          properties: tool.function.parameters.properties,\n          required: tool.function.parameters.required || [],\n        }\n      }));\n    }\n    \n    // Grok, OpenAI, DeepSeek use standard OpenAI format\n    return tools;\n  }\n  \n  /**\n   * Clean messages for provider compatibility\n   */\n  private cleanMessagesForProvider(messages: GrokMessage[]): GrokMessage[] {\n    const provider = this.getProvider();\n    \n    // ‚úÖ FIRST: Remove invalid assistant messages (empty content + no tool_calls)\n    // This causes 400 errors with all providers (OpenAI, Mistral, etc.)\n    messages = messages.filter(msg => {\n      if (msg.role === 'assistant') {\n        // Check if has content (handle both string and array types)\n        const hasContent = msg.content && \n          (typeof msg.content === 'string' \n            ? msg.content.trim().length > 0 \n            : msg.content.length > 0);\n        const hasToolCalls = (msg as any).tool_calls && (msg as any).tool_calls.length > 0;\n        \n        // Keep only if has content OR tool_calls\n        if (!hasContent && !hasToolCalls) {\n          debugLog.log(`üóëÔ∏è  Removing invalid assistant message (no content, no tool_calls)`);\n          return false;\n        }\n      }\n      return true;\n    });\n    \n    if (provider === 'mistral') {\n      // ‚úÖ Mistral-specific cleaning (strict message structure rules)\n      // According to https://docs.mistral.ai/agents/tools/function_calling\n      // Mistral requires:\n      // 1. No consecutive assistant messages (must have user between)\n      // 2. Tool calls must have 'type': 'function'\n      // 3. Proper alternation of user/assistant\n      const cleaned: GrokMessage[] = [];\n      let lastRole: string | null = null;\n      \n      for (let i = 0; i < messages.length; i++) {\n        const msg = messages[i];\n        \n        // Keep system messages as-is (only at start)\n        if (msg.role === 'system') {\n          cleaned.push(msg);\n          lastRole = 'system';\n          continue;\n        }\n        \n        // ‚úÖ Handle assistant messages\n        if (msg.role === 'assistant') {\n          // Strip tool_calls if present (Mistral doesn't need them in history)\n          if ((msg as any).tool_calls) {\n            debugLog.log(`üîÑ Mistral: Stripping tool_calls from assistant message`);\n            \n            // If last was also assistant, inject separator user message\n            if (lastRole === 'assistant') {\n              debugLog.log(`‚ö†Ô∏è  Mistral: Consecutive assistant messages detected, adding separator`);\n              cleaned.push({\n                role: 'user',\n                content: '[Continue]',\n              });\n            }\n            \n            // Push assistant WITHOUT tool_calls (was the working solution from bc275d3)\n            cleaned.push({\n              role: 'assistant',\n              content: msg.content || '[Using tools...]',\n            });\n            lastRole = 'assistant';\n            continue;\n          }\n          \n          // Assistant without tool_calls: keep if has content\n          if (msg.content && (typeof msg.content === 'string' ? msg.content.trim() : true)) {\n            // If last was also assistant, inject separator\n            if (lastRole === 'assistant') {\n              debugLog.log(`‚ö†Ô∏è  Mistral: Consecutive assistant messages detected, adding separator`);\n              cleaned.push({\n                role: 'user',\n                content: '[Continue]',\n              });\n            }\n            \n            cleaned.push(msg);\n            lastRole = 'assistant';\n            continue;\n          }\n          \n          // Skip empty assistant messages (already filtered but double-check)\n          debugLog.log(`üóëÔ∏è  Mistral: Skipping empty assistant message`);\n          continue;\n        }\n        \n        // ‚úÖ Handle tool messages - Convert ALL to user messages for Mistral\n        if (msg.role === 'tool') {\n          // ‚úÖ Mistral doesn't support role:\"tool\" even with 'name' field\n          // Convert ALL tool messages to user messages (not just orphans!)\n          // This was the working solution from commit bc275d3 (22 Nov)\n          debugLog.log(`üîÑ Mistral: Converting tool message to user (content length: ${msg.content.length})`);\n          cleaned.push({\n            role: 'user',\n            content: `[Tool Result]\\n${msg.content}`,\n          });\n          lastRole = 'user';\n          continue;\n        }\n        \n        // ‚úÖ Handle user messages (always keep)\n        if (msg.role === 'user') {\n          cleaned.push(msg);\n          lastRole = 'user';\n          continue;\n        }\n        \n        // Other messages: keep as-is\n        cleaned.push(msg);\n        lastRole = msg.role;\n      }\n      \n      debugLog.log(`‚úÖ Mistral cleaning: ${messages.length} ‚Üí ${cleaned.length} messages`);\n      return cleaned;\n    }\n    \n    // For OpenAI, Grok, DeepSeek: Ensure tool_calls have 'type' field + convert orphaned tool messages\n    if (provider === 'openai' || provider === 'grok' || provider === 'deepseek') {\n      const cleaned: GrokMessage[] = [];\n      \n      for (let i = 0; i < messages.length; i++) {\n        const msg = messages[i];\n        \n        // If it's a tool message, check if previous message has tool_calls\n        if (msg.role === 'tool') {\n          // Find previous non-tool message\n          let prevAssistant: GrokMessage | null = null;\n          for (let j = i - 1; j >= 0; j--) {\n            if (messages[j].role === 'assistant') {\n              prevAssistant = messages[j];\n              break;\n            }\n          }\n          \n          // If tool has valid parent: keep as-is\n          if (prevAssistant && (prevAssistant as any).tool_calls) {\n            cleaned.push(msg);\n          } else {\n            // Orphaned tool: convert to user to preserve content\n            // Better than losing valuable context!\n            cleaned.push({\n              role: 'user',\n              content: `[Tool Result - Previous Context]\\n${msg.content}`,\n            });\n          }\n          continue;\n        }\n        \n        // Fix assistant messages with tool_calls (add missing 'type' field)\n        if (msg.role === 'assistant' && (msg as any).tool_calls) {\n          const toolCalls = (msg as any).tool_calls.map((tc: any) => ({\n            id: tc.id,\n            type: tc.type || 'function', // ‚úÖ Add missing 'type' field\n            function: tc.function,\n          }));\n          \n          cleaned.push({\n            ...msg,\n            tool_calls: toolCalls,\n          });\n          continue;\n        }\n        \n        // Other messages: keep as-is\n        cleaned.push(msg);\n      }\n      \n      return cleaned;\n    }\n    \n    // Other providers (Claude): return as-is\n    return messages;\n  }\n  \n  /**\n   * Truncate messages to fit context window\n   */\n  private truncateMessages(messages: GrokMessage[], maxMessages: number = 50): GrokMessage[] {\n    if (messages.length <= maxMessages) {\n      return messages;\n    }\n    \n    // Keep system message + last N messages\n    const systemMessages = messages.filter(m => m.role === 'system');\n    const otherMessages = messages.filter(m => m.role !== 'system');\n    const recentMessages = otherMessages.slice(-maxMessages);\n    \n    debugLog.log(`‚ö†Ô∏è  Truncated messages: ${messages.length} ‚Üí ${systemMessages.length + recentMessages.length}`);\n    \n    return [...systemMessages, ...recentMessages];\n  }\n  \n  /**\n   * Additional pruning by rough character budget (provider-sensitive)\n   */\n  private pruneByCharBudget(messages: GrokMessage[], provider: string): GrokMessage[] {\n    if (provider !== 'mistral') return messages;\n    const BUDGET = 18000; // rough char budget (~6-8k tokens depending on content)\n    // Always keep first system message if present\n    const systemMsg = messages.find(m => m.role === 'system');\n    const rest = messages.filter(m => m !== systemMsg);\n    let acc: GrokMessage[] = [];\n    let used = systemMsg ? JSON.stringify(systemMsg).length : 0;\n    for (let i = rest.length - 1; i >= 0; i--) {\n      const m = rest[i];\n      const sz = JSON.stringify(m).length;\n      if (used + sz > BUDGET) break;\n      acc.push(m);\n      used += sz;\n    }\n    acc.reverse();\n    return systemMsg ? [systemMsg, ...acc] : acc;\n  }\n  \n  /**\n   * Build request payload specific to provider\n   */\n  private buildRequestPayload(\n    modelToUse: string,\n    messages: GrokMessage[],\n    tools?: GrokTool[],\n    searchOptions?: SearchOptions\n  ): any {\n    const provider = this.getProvider();\n    const isReasoning = this.isReasoningModel(modelToUse);\n    \n    // ‚úÖ Truncate messages for context window (especially for Mistral)\n    const truncatedMessages = this.truncateMessages(messages, 50);\n    const prunedByBudget = this.pruneByCharBudget(truncatedMessages, provider);\n    \n    // ‚úÖ Clean messages for provider compatibility (currently no-op)\n    const cleanedMessages = this.cleanMessagesForProvider(prunedByBudget);\n    \n    const requestPayload: any = {\n      model: modelToUse,\n      messages: cleanedMessages,\n    };\n    \n    // Add tools if provided (formatted for provider)\n    if (tools && tools.length > 0) {\n      const formattedTools = this.formatToolsForProvider(tools);\n      \n      if (provider === 'claude') {\n        requestPayload.tools = formattedTools;\n        // Claude doesn't use tool_choice in the same way\n      } else if (provider === 'mistral') {\n        // Mistral: tools without tool_choice\n        requestPayload.tools = formattedTools;\n      } else {\n        requestPayload.tools = formattedTools;\n        requestPayload.tool_choice = \"auto\";\n      }\n    }\n    \n    // Add provider-specific parameters\n    if (provider === 'claude') {\n      // Claude uses max_tokens (not max_completion_tokens)\n      requestPayload.max_tokens = this.defaultMaxTokens;\n      // Claude doesn't use temperature in tool calls\n      if (!tools || tools.length === 0) {\n        requestPayload.temperature = 0.7;\n      }\n    } else if (isReasoning) {\n      // Reasoning models (o1, o3, gpt-5): max_completion_tokens, no temperature\n      requestPayload.max_completion_tokens = this.defaultMaxTokens;\n    } else {\n      // Standard models: temperature + max_tokens\n      requestPayload.temperature = 0.7;\n      requestPayload.max_tokens = this.defaultMaxTokens;\n    }\n    \n    // Grok-specific: search_parameters\n    if (provider === 'grok' && searchOptions?.search_parameters) {\n      requestPayload.search_parameters = searchOptions.search_parameters;\n    }\n    \n    return requestPayload;\n  }\n\n  setModel(model: string): void {\n    this.currentModel = model;\n  }\n\n  getCurrentModel(): string {\n    return this.currentModel;\n  }\n  \n  // ‚úÖ NEW: Get API key for session switching\n  getApiKey(): string {\n    return this.apiKey;\n  }\n\n  async chat(\n    messages: GrokMessage[],\n    tools?: GrokTool[],\n    model?: string,\n    searchOptions?: SearchOptions\n  ): Promise<GrokResponse> {\n    const modelToUse = model || this.currentModel;\n    const provider = this.getProvider();\n    \n    debugLog.log(`\\nüì° GrokClient.chat() - provider: ${provider}, baseURL: ${this.baseURL}, model: ${modelToUse}`);\n    \n    // ‚úÖ Build provider-specific request payload\n    const requestPayload = this.buildRequestPayload(modelToUse, messages, tools, searchOptions);\n\n    debugLog.log(`üì§ Request payload:`, {\n      provider,\n      baseURL: this.baseURL,\n      model: requestPayload.model,\n      toolsCount: requestPayload.tools?.length || 0,\n      messagesCount: requestPayload.messages?.length || 0,\n      hasTemperature: 'temperature' in requestPayload,\n      hasMaxTokens: 'max_tokens' in requestPayload,\n      hasMaxCompletionTokens: 'max_completion_tokens' in requestPayload,\n      temperature: requestPayload.temperature,\n      max_tokens: requestPayload.max_tokens,\n      tool_choice: requestPayload.tool_choice,\n    });\n\n    try {\n      const response =\n        await this.client.chat.completions.create(requestPayload);\n\n      debugLog.log(`‚úÖ API Response OK - model: ${response.model}`);\n      return response as GrokResponse;\n    } catch (error: any) {\n      debugLog.error(`‚ùå API Error:`, {\n        provider,\n        message: error.message,\n        status: error.status,\n        code: error.code,\n        type: error.type,\n        requestHadTools: requestPayload.tools?.length || 0,\n        requestHadMessages: requestPayload.messages?.length || 0,\n        baseURL: this.baseURL,\n        model: modelToUse,\n      });\n      throw new Error(`Grok API error: ${error.message}`);\n    }\n  }\n\n  async *chatStream(\n    messages: GrokMessage[],\n    tools?: GrokTool[],\n    model?: string,\n    searchOptions?: SearchOptions\n  ): AsyncGenerator<any, void, unknown> {\n    const modelToUse = model || this.currentModel;\n    const provider = this.getProvider();\n    \n    debugLog.log(`\\nüåä GrokClient.chatStream() - provider: ${provider}, baseURL: ${this.baseURL}, model: ${modelToUse}`);\n    \n    // ‚úÖ Build provider-specific request payload\n    const requestPayload = this.buildRequestPayload(modelToUse, messages, tools, searchOptions);\n    requestPayload.stream = true; // Enable streaming\n\n    debugLog.log(`üì§ Stream Request payload:`, {\n      provider,\n      baseURL: this.baseURL,\n      model: requestPayload.model,\n      toolsCount: requestPayload.tools?.length || 0,\n      messagesCount: requestPayload.messages?.length || 0,\n      hasTemperature: 'temperature' in requestPayload,\n      hasMaxTokens: 'max_tokens' in requestPayload,\n      temperature: requestPayload.temperature,\n      max_tokens: requestPayload.max_tokens,\n      tool_choice: requestPayload.tool_choice,\n      stream: true,\n    });\n    \n    // ‚úÖ Log ACTUAL payload being sent (for debugging Mistral issue)\n    debugLog.log(`üìã ACTUAL REQUEST PAYLOAD (complete):`, JSON.stringify({\n      model: requestPayload.model,\n      messages: requestPayload.messages,\n      tools: requestPayload.tools,\n      tool_choice: requestPayload.tool_choice,\n      temperature: requestPayload.temperature,\n      max_tokens: requestPayload.max_tokens,\n      stream: requestPayload.stream,\n    }, null, 2));\n\n    try {\n      const stream = (await this.client.chat.completions.create(\n        requestPayload\n      )) as any;\n\n      debugLog.log(`‚úÖ Stream started successfully`);\n      \n      for await (const chunk of stream) {\n        yield chunk;\n      }\n      \n      debugLog.log(`‚úÖ Stream completed`);\n    } catch (error: any) {\n      debugLog.error(`‚ùå Stream Error:`, {\n        provider,\n        message: error.message,\n        status: error.status,\n        code: error.code,\n        type: error.type,\n        requestHadTools: requestPayload.tools?.length || 0,\n        requestHadMessages: requestPayload.messages?.length || 0,\n        baseURL: this.baseURL,\n        model: modelToUse,\n      });\n      throw new Error(`Grok API error: ${error.message}`);\n    }\n  }\n\n  async search(\n    query: string,\n    searchParameters?: SearchParameters\n  ): Promise<GrokResponse> {\n    const searchMessage: GrokMessage = {\n      role: \"user\",\n      content: query,\n    };\n\n    const searchOptions: SearchOptions = {\n      search_parameters: searchParameters || { mode: \"on\" },\n    };\n\n    return this.chat([searchMessage], [], undefined, searchOptions);\n  }\n}\n"
  },
  "src/grok/tools.ts": {
    "path": "src/grok/tools.ts",
    "hash": "a1d36d0c64ee7c1108c6490c9024b0fdebb9e2a841e747fd1d4a9512549d081b",
    "size": 34464,
    "timestamp": 1764704879298,
    "content": "import { GrokTool } from \"./client.js\";\nimport { MCPManager, MCPTool } from \"../mcp/client.js\";\nimport { loadMCPConfig } from \"../mcp/config.js\";\n\nconst BASE_GROK_TOOLS: GrokTool[] = [\n  {\n    type: \"function\",\n    function: {\n      name: \"view_file\",\n      description: \"View contents of a file or list directory contents\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          path: {\n            type: \"string\",\n            description: \"Path to file or directory to view\",\n          },\n          start_line: {\n            type: \"number\",\n            description:\n              \"Starting line number for partial file view (optional)\",\n          },\n          end_line: {\n            type: \"number\",\n            description: \"Ending line number for partial file view (optional)\",\n          },\n        },\n        required: [\"path\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"apply_patch\",\n      description:\n        \"Apply a unified diff (git-style) patch to the workspace. Use this for multi-file edits.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          patch: {\n            type: \"string\",\n            description: \"Unified diff content. Include ---/+++ and @@ hunks.\",\n          },\n          dry_run: {\n            type: \"boolean\",\n            description: \"If true, validate without writing changes.\",\n          },\n        },\n        required: [\"patch\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"create_file\",\n      description: \"Create a new file with specified content\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          path: {\n            type: \"string\",\n            description: \"Path where the file should be created\",\n          },\n          content: {\n            type: \"string\",\n            description: \"Content to write to the file\",\n          },\n        },\n        required: [\"path\", \"content\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"str_replace_editor\",\n      description: \"Replace specific text in a file. Use this for single line edits only\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          path: {\n            type: \"string\",\n            description: \"Path to the file to edit\",\n          },\n          old_str: {\n            type: \"string\",\n            description:\n              \"Text to replace (must match exactly, or will use fuzzy matching for multi-line strings)\",\n          },\n          new_str: {\n            type: \"string\",\n            description: \"Text to replace with\",\n          },\n          replace_all: {\n            type: \"boolean\",\n            description:\n              \"Replace all occurrences (default: false, only replaces first occurrence)\",\n          },\n        },\n        required: [\"path\", \"old_str\", \"new_str\"],\n      },\n    },\n  },\n\n  {\n    type: \"function\",\n    function: {\n      name: \"bash\",\n      description: \"Execute a bash command\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          command: {\n            type: \"string\",\n            description: \"The bash command to execute\",\n          },\n        },\n        required: [\"command\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"search\",\n      description:\n        \"Unified search tool for finding text content or files (similar to Cursor's search)\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          query: {\n            type: \"string\",\n            description: \"Text to search for or file name/path pattern\",\n          },\n          search_type: {\n            type: \"string\",\n            enum: [\"text\", \"files\", \"both\"],\n            description:\n              \"Type of search: 'text' for content search, 'files' for file names, 'both' for both (default: 'both')\",\n          },\n          include_pattern: {\n            type: \"string\",\n            description:\n              \"Glob pattern for files to include (e.g. '*.ts', '*.js')\",\n          },\n          exclude_pattern: {\n            type: \"string\",\n            description:\n              \"Glob pattern for files to exclude (e.g. '*.log', 'node_modules')\",\n          },\n          case_sensitive: {\n            type: \"boolean\",\n            description:\n              \"Whether search should be case sensitive (default: false)\",\n          },\n          whole_word: {\n            type: \"boolean\",\n            description: \"Whether to match whole words only (default: false)\",\n          },\n          regex: {\n            type: \"boolean\",\n            description: \"Whether query is a regex pattern (default: false)\",\n          },\n          max_results: {\n            type: \"number\",\n            description: \"Maximum number of results to return (default: 50)\",\n          },\n          file_types: {\n            type: \"array\",\n            items: { type: \"string\" },\n            description: \"File types to search (e.g. ['js', 'ts', 'py'])\",\n          },\n          include_hidden: {\n            type: \"boolean\",\n            description: \"Whether to include hidden files (default: false)\",\n          },\n        },\n        required: [\"query\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"create_todo_list\",\n      description: \"Create a new todo list for planning and tracking tasks\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          todos: {\n            type: \"array\",\n            description: \"Array of todo items\",\n            items: {\n              type: \"object\",\n              properties: {\n                id: {\n                  type: \"string\",\n                  description: \"Unique identifier for the todo item\",\n                },\n                content: {\n                  type: \"string\",\n                  description: \"Description of the todo item\",\n                },\n                status: {\n                  type: \"string\",\n                  enum: [\"pending\", \"in_progress\", \"completed\"],\n                  description: \"Current status of the todo item\",\n                },\n                priority: {\n                  type: \"string\",\n                  enum: [\"high\", \"medium\", \"low\"],\n                  description: \"Priority level of the todo item\",\n                },\n              },\n              required: [\"id\", \"content\", \"status\", \"priority\"],\n            },\n          },\n        },\n        required: [\"todos\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"update_todo_list\",\n      description: \"Update existing todos in the todo list\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          updates: {\n            type: \"array\",\n            description: \"Array of todo updates\",\n            items: {\n              type: \"object\",\n              properties: {\n                id: {\n                  type: \"string\",\n                  description: \"ID of the todo item to update\",\n                },\n                status: {\n                  type: \"string\",\n                  enum: [\"pending\", \"in_progress\", \"completed\"],\n                  description: \"New status for the todo item\",\n                },\n                content: {\n                  type: \"string\",\n                  description: \"New content for the todo item\",\n                },\n                priority: {\n                  type: \"string\",\n                  enum: [\"high\", \"medium\", \"low\"],\n                  description: \"New priority for the todo item\",\n                },\n              },\n              required: [\"id\"],\n            },\n          },\n        },\n        required: [\"updates\"],\n      },\n    },\n  },\n  {\n    type: \"function\",\n    function: {\n      name: \"get_my_identity\",\n      description: \"Get factual information about your own model identity, provider, and configuration. Use this if you need to verify who you are, especially after noticing inconsistencies in conversation history.\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n        required: [],\n      },\n    },\n  },\n  \n  // ============================================\n  // SESSION MANAGEMENT TOOLS (Git-like)\n  // ============================================\n  \n  {\n    type: \"function\",\n    function: {\n      name: \"session_list\",\n      description: \"List all conversation sessions with details (ID, directory, model, message count, dates). Use this to see available sessions before switching or for conversation management.\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n        required: [],\n      },\n    },\n  },\n  \n  {\n    type: \"function\",\n    function: {\n      name: \"session_switch\",\n      description: \"Switch to a different conversation session. Changes working directory and loads conversation history. **CRITICAL: ALWAYS ask user permission before calling.** Explain what will happen and get explicit approval.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          session_id: {\n            type: \"number\",\n            description: \"ID of the session to switch to (use session_list to see available sessions)\",\n          },\n        },\n        required: [\"session_id\"],\n      },\n    },\n  },\n  \n  {\n    type: \"function\",\n    function: {\n      name: \"session_new\",\n      description: `‚ö†Ô∏è CRITICAL: Before using this tool, ASK USER to clarify their intent!\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nTWO TOOLS AVAILABLE FOR SESSION/STATE CREATION - Ask user to choose:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üìÅ session_new (THIS TOOL) - Simple Session Creation             ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Starting fresh conversation in new directory                   ‚îÇ\n‚îÇ ‚Ä¢ Git repository cloning (CURRENT HEAD state)                    ‚îÇ\n‚îÇ ‚Ä¢ File copying (CURRENT files, excluding .git/node_modules)      ‚îÇ\n‚îÇ ‚Ä¢ Importing conversation history by date range                   ‚îÇ\n‚îÇ ‚Ä¢ Simple event sourcing initialization (via from-rewind mode)    ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ INITIALIZATION MODES (init_mode parameter):                      ‚îÇ\n‚îÇ ‚Ä¢ 'empty': Empty directory (default)                             ‚îÇ\n‚îÇ ‚Ä¢ 'clone-git': Clone current Git repo at HEAD                    ‚îÇ\n‚îÇ ‚Ä¢ 'copy-files': Copy current files (excludes .git, node_modules) ‚îÇ\n‚îÇ ‚Ä¢ 'from-rewind': Initialize from event sourcing timestamp        ‚îÇ\n‚îÇ   ‚îî‚îÄ> Requires: rewind_timestamp (ISO 8601)                      ‚îÇ\n‚îÇ   ‚îî‚îÄ> Optional: rewind_git_mode ('none'/'metadata'/'full')      ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ CONVERSATION IMPORT OPTIONS:                                     ‚îÇ\n‚îÇ ‚Ä¢ import_history: Import conversation history (boolean)          ‚îÇ\n‚îÇ ‚Ä¢ from_session_id: Source session ID (default: current)          ‚îÇ\n‚îÇ ‚Ä¢ date_range_start: Filter start date (ISO 8601 / YYYY-MM-DD)   ‚îÇ\n‚îÇ ‚Ä¢ date_range_end: Filter end date (ISO 8601 / YYYY-MM-DD)       ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ MODEL/PROVIDER OPTIONS:                                          ‚îÇ\n‚îÇ ‚Ä¢ model: Model to use (e.g., 'grok-2-1212', 'claude-sonnet-4')  ‚îÇ\n‚îÇ ‚Ä¢ provider: Provider (e.g., 'xai', 'anthropic')                  ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ LIMITATIONS:                                                      ‚îÇ\n‚îÇ ‚Ä¢ 'from-rewind' has limited options vs rewind_to tool            ‚îÇ\n‚îÇ ‚Ä¢ No autoCheckout, compareWith options                           ‚îÇ\n‚îÇ ‚Ä¢ For advanced rewind: use rewind_to tool instead                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚è∞ rewind_to - TIME MACHINE (Event Sourcing Alternative)          ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Recovering EXACT state at specific past timestamp              ‚îÇ\n‚îÇ ‚Ä¢ Event sourcing replay from timeline.db                         ‚îÇ\n‚îÇ ‚Ä¢ Full Git repository reconstruction (ANY commit, not just HEAD) ‚îÇ\n‚îÇ ‚Ä¢ Advanced options: compare dirs, auto-checkout, git modes       ‚îÇ\n‚îÇ ‚Ä¢ Automatically create session in rewinded state                 ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ POWERFUL FEATURES:                                                ‚îÇ\n‚îÇ ‚Ä¢ gitMode: 'none', 'metadata', or 'full' Git reconstruction      ‚îÇ\n‚îÇ ‚Ä¢ autoCheckout: Automatically cd to rewinded directory           ‚îÇ\n‚îÇ ‚Ä¢ compareWith: Generate diff report with another directory       ‚îÇ\n‚îÇ ‚Ä¢ createSession: Auto-create session in past state               ‚îÇ\n‚îÇ ‚Ä¢ Merkle DAG: Reconstruct exact file contents from blobs         ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ REQUIREMENTS:                                                     ‚îÇ\n‚îÇ ‚Ä¢ Exact timestamp (use timeline_query to find available times)   ‚îÇ\n‚îÇ ‚Ä¢ Timeline.db with event history                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nüî¥ MANDATORY: ASK USER BEFORE PROCEEDING:\n\n\"I can help you create a new session. There are TWO approaches available:\n\n1Ô∏è‚É£ **Simple Session Creation** (session_new - CURRENT state):\n   ‚úì Clone current Git repository (HEAD) - init_mode='clone-git'\n   ‚úì Copy current files to new directory - init_mode='copy-files'\n   ‚úì Start with empty directory - init_mode='empty' (default)\n   ‚úì Import conversation history by date range\n   ‚úì Basic event sourcing init - init_mode='from-rewind'\n   \n   Available Options:\n   ‚Ä¢ init_mode: 'empty', 'clone-git', 'copy-files', 'from-rewind'\n   ‚Ä¢ rewind_timestamp: For 'from-rewind' mode (ISO 8601)\n   ‚Ä¢ rewind_git_mode: Git mode for rewind ('none'/'metadata'/'full')\n   ‚Ä¢ import_history, from_session_id, date_range_start/end\n   ‚Ä¢ model, provider\n   \n   Limitations:\n   ‚úó from-rewind has fewer options than rewind_to\n   ‚úó No autoCheckout, compareWith features\n\n2Ô∏è‚É£ **Time Machine Recovery** (rewind_to - PAST state):\n   ‚úì Recover EXACT state from any past timestamp\n   ‚úì Event sourcing replay from timeline.db\n   ‚úì Full Git reconstruction at specific commit\n   ‚úì Advanced options (compare, auto-checkout, git modes)\n   ‚úì Can create session automatically in past state\n   ‚úó Requires exact timestamp\n   ‚úó More complex operation\n\nYour request: [describe what you understood]\n\nWhich approach do you need?\n‚Ä¢ Work with CURRENT state ‚Üí I'll use session_new\n‚Ä¢ Recover a PAST state at specific time ‚Üí I'll use rewind_to\n\nPlease confirm your choice so I can proceed correctly.\"\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nPROCEED WITH session_new ONLY AFTER USER CONFIRMS \"current state\" approach.`,\n      parameters: {\n        type: \"object\",\n        properties: {\n          directory: {\n            type: \"string\",\n            description: \"Target directory for new session (absolute or relative path). Will be created if doesn't exist.\",\n          },\n          init_mode: {\n            type: \"string\",\n            enum: [\"empty\", \"clone-git\", \"copy-files\", \"from-rewind\"],\n            description: `Directory initialization mode (default: 'empty'):\n‚Ä¢ 'empty': Create empty directory\n‚Ä¢ 'clone-git': Clone current Git repository (HEAD state) to target directory\n‚Ä¢ 'copy-files': Copy current files (excluding .git, node_modules, hidden files) to target directory\n‚Ä¢ 'from-rewind': Initialize from event sourcing rewind at specific timestamp (requires rewind_timestamp)\n\n‚ö†Ô∏è For 'from-rewind': Consider using rewind_to tool instead for full control over gitMode, autoCheckout, compareWith options.`,\n          },\n          rewind_timestamp: {\n            type: \"string\",\n            description: \"Timestamp for 'from-rewind' init mode (ISO 8601: 2025-11-28T15:00:00Z). Only used when init_mode='from-rewind'. Reconstructs directory state via event sourcing.\",\n          },\n          rewind_git_mode: {\n            type: \"string\",\n            enum: [\"none\", \"metadata\", \"full\"],\n            description: \"Git mode for 'from-rewind' (default: 'full'). Only used when init_mode='from-rewind'. See rewind_to tool for detailed gitMode documentation.\",\n          },\n          import_history: {\n            type: \"boolean\",\n            description: \"Whether to import conversation history from source session (default: false)\",\n          },\n          from_session_id: {\n            type: \"number\",\n            description: \"Session ID to import conversation history from (default: current session). Used when import_history=true.\",\n          },\n          date_range_start: {\n            type: \"string\",\n            description: \"Start date for conversation history filtering (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY). Used when import_history=true.\",\n          },\n          date_range_end: {\n            type: \"string\",\n            description: \"End date for conversation history filtering (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY). Used when import_history=true.\",\n          },\n          model: {\n            type: \"string\",\n            description: \"Model to use in new session (optional, e.g., 'grok-2-1212', 'claude-sonnet-4')\",\n          },\n          provider: {\n            type: \"string\",\n            description: \"Provider to use in new session (optional, e.g., 'xai', 'anthropic')\",\n          },\n        },\n        required: [\"directory\"],\n      },\n    },\n  },\n  \n  {\n    type: \"function\",\n    function: {\n      name: \"session_rewind\",\n      description: \"Perform Git rewind: synchronize conversation history AND code state to a specific date range. Creates new session in target directory with filtered conversation messages and Git repository at corresponding commit. **CRITICAL: This is the most powerful operation - ALWAYS explain the plan in detail and get explicit user permission before calling.** This modifies filesystem and Git state.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          target_directory: {\n            type: \"string\",\n            description: \"Directory for rewound session (will be created, must not exist)\",\n          },\n          date_range_start: {\n            type: \"string\",\n            description: \"Start date for rewind (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY)\",\n          },\n          date_range_end: {\n            type: \"string\",\n            description: \"End date for rewind (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY)\",\n          },\n          from_session_id: {\n            type: \"number\",\n            description: \"Session to rewind from (default: current session)\",\n          },\n          preserve_git_history: {\n            type: \"boolean\",\n            description: \"If true, clone full Git history. If false, use git archive (lightweight). Default: false\",\n          },\n        },\n        required: [\"target_directory\", \"date_range_start\", \"date_range_end\"],\n      },\n    },\n  },\n];\n\n// Morph Fast Apply tool (conditional)\nconst MORPH_EDIT_TOOL: GrokTool = {\n  type: \"function\",\n  function: {\n    name: \"edit_file\",\n    description: \"Use this tool to make an edit to an existing file.\\n\\nThis will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.\\nWhen writing the edit, you should specify each edit in sequence, with the special comment // ... existing code ... to represent unchanged code in between edited lines.\\n\\nFor example:\\n\\n// ... existing code ...\\nFIRST_EDIT\\n// ... existing code ...\\nSECOND_EDIT\\n// ... existing code ...\\nTHIRD_EDIT\\n// ... existing code ...\\n\\nYou should still bias towards repeating as few lines of the original file as possible to convey the change.\\nBut, each edit should contain sufficient context of unchanged lines around the code you're editing to resolve ambiguity.\\nDO NOT omit spans of pre-existing code (or comments) without using the // ... existing code ... comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.\\nIf you plan on deleting a section, you must provide context before and after to delete it. If the initial code is ```code \\\\n Block 1 \\\\n Block 2 \\\\n Block 3 \\\\n code```, and you want to remove Block 2, you would output ```// ... existing code ... \\\\n Block 1 \\\\n  Block 3 \\\\n // ... existing code ...```.\\nMake sure it is clear what the edit should be, and where it should be applied.\\nMake edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        target_file: {\n          type: \"string\",\n          description: \"The target file to modify.\"\n        },\n        instructions: {\n          type: \"string\",\n          description: \"A single sentence instruction describing what you are going to do for the sketched edit. This is used to assist the less intelligent model in applying the edit. Use the first person to describe what you are going to do. Use it to disambiguate uncertainty in the edit.\"\n        },\n        code_edit: {\n          type: \"string\",\n          description: \"Specify ONLY the precise lines of code that you wish to edit. NEVER specify or write out unchanged code. Instead, represent all unchanged code using the comment of the language you're editing in - example: // ... existing code ...\"\n        }\n      },\n      required: [\"target_file\", \"instructions\", \"code_edit\"]\n    }\n  }\n};\n\n// Function to build tools array conditionally\nfunction buildGrokTools(): GrokTool[] {\n  const tools = [...BASE_GROK_TOOLS];\n  \n  // Add Morph Fast Apply tool if API key is available\n  if (process.env.MORPH_API_KEY) {\n    tools.splice(3, 0, MORPH_EDIT_TOOL); // Insert after str_replace_editor\n  }\n  \n  // Add timeline tools\n  tools.push(\n    {\n      type: \"function\",\n      function: {\n        name: \"timeline_query\",\n        description: \"Query timeline event log to understand what happened (file modifications, git operations, conversations, tool calls, rewinds).\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            startTime: { type: \"string\", description: \"Start timestamp (ISO string or relative, e.g. '2025-11-28T00:00:00Z' or '2 hours ago')\" },\n            endTime: { type: \"string\", description: \"End timestamp (ISO string)\" },\n            categories: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n                enum: [\"SESSION\", \"LLM\", \"TOOL\", \"FILE\", \"GIT\", \"REWIND\"],\n              },\n              description: \"High-level event categories to filter.\",\n            },\n            eventTypes: {\n              type: \"array\",\n              items: { type: \"string\" },\n              description: \"Specific event types (e.g. FILE_MODIFIED, GIT_COMMIT, REWIND_COMPLETED).\",\n            },\n            actor: {\n              type: \"string\",\n              description: \"Filter by actor (e.g. 'user', 'system', 'git:username').\",\n            },\n            sessionId: {\n              type: \"number\",\n              description: \"Filter by session ID.\",\n            },\n            aggregateId: {\n              type: \"string\",\n              description: \"Filter by aggregate ID (e.g. file path).\",\n            },\n            limit: {\n              type: \"number\",\n              description: \"Max results (default: 100, max: 1000).\",\n            },\n            searchText: {\n              type: \"string\",\n              description: \"Search text in event payloads (useful to find specific errors or operations).\",\n            },\n            order: {\n              type: \"string\",\n              enum: [\"asc\", \"desc\"],\n              description: \"Sort order: 'asc' (oldest first) or 'desc' (newest first, default).\",\n            },\n            statsOnly: {\n              type: \"boolean\",\n              description: \"Return only aggregated statistics instead of full event list.\",\n            },\n          },\n          required: [],\n        },\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"rewind_to\",\n        description: `‚ö†Ô∏è CRITICAL: Before using this tool, ASK USER to clarify their intent AND get explicit permission!\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nTWO TOOLS AVAILABLE FOR SESSION/STATE CREATION - Ask user to choose:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚è∞ rewind_to (THIS TOOL) - TIME MACHINE via Event Sourcing        ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Recovering EXACT state at specific past timestamp              ‚îÇ\n‚îÇ ‚Ä¢ Event sourcing replay from timeline.db Merkle DAG              ‚îÇ\n‚îÇ ‚Ä¢ Full Git repository reconstruction at ANY commit               ‚îÇ\n‚îÇ ‚Ä¢ Advanced operations with multiple options                      ‚îÇ\n‚îÇ ‚Ä¢ Creating session automatically in rewinded past state          ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ POWERFUL FEATURES:                                                ‚îÇ\n‚îÇ ‚Ä¢ gitMode: 'none' | 'metadata' | 'full'                          ‚îÇ\n‚îÇ   - none: No Git information                                     ‚îÇ\n‚îÇ   - metadata: git_state.json with commit/branch info             ‚îÇ\n‚îÇ   - full: Complete .git repository at target commit              ‚îÇ\n‚îÇ ‚Ä¢ autoCheckout: Auto cd to rewinded directory after rewind       ‚îÇ\n‚îÇ ‚Ä¢ compareWith: Generate detailed diff report vs another dir      ‚îÇ\n‚îÇ ‚Ä¢ createSession: Auto-create grokinou session in rewinded state  ‚îÇ\n‚îÇ ‚Ä¢ includeFiles: Reconstruct file contents from Merkle DAG blobs  ‚îÇ\n‚îÇ ‚Ä¢ includeConversations: Import conversation history              ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ HOW IT WORKS (Event Sourcing):                                    ‚îÇ\n‚îÇ 1. Query timeline.db for all events before targetTimestamp       ‚îÇ\n‚îÇ 2. Find nearest snapshot (if exists) for optimization            ‚îÇ\n‚îÇ 3. Replay events from snapshot ‚Üí target time                     ‚îÇ\n‚îÇ 4. Reconstruct files from Merkle DAG blob storage                ‚îÇ\n‚îÇ 5. Materialize Git repository at exact commit (if gitMode‚â†none)  ‚îÇ\n‚îÇ 6. Create session in rewinded directory (if createSession=true)  ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ REQUIREMENTS:                                                     ‚îÇ\n‚îÇ ‚Ä¢ Exact timestamp (ISO 8601: 2025-11-28T14:30:00Z)               ‚îÇ\n‚îÇ ‚Ä¢ Use timeline_query first to find available timestamps          ‚îÇ\n‚îÇ ‚Ä¢ Timeline.db must have event history for target period          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üìÅ session_new - Simple Session Creation (Alternative)           ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Working with CURRENT state (not past)                          ‚îÇ\n‚îÇ ‚Ä¢ Simple Git clone (HEAD state only)                             ‚îÇ\n‚îÇ ‚Ä¢ File copying (current files)                                   ‚îÇ\n‚îÇ ‚Ä¢ Basic session creation                                         ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ LIMITATIONS:                                                      ‚îÇ\n‚îÇ ‚Ä¢ No event sourcing / time travel                                ‚îÇ\n‚îÇ ‚Ä¢ Works only with current state                                  ‚îÇ\n‚îÇ ‚Ä¢ No advanced rewind options                                     ‚îÇ\n‚îÇ ‚Ä¢ Cannot recover past timestamps                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nüî¥ MANDATORY: ASK USER BEFORE PROCEEDING:\n\n\"I can help you with time-based operations. There are TWO approaches:\n\n1Ô∏è‚É£ **Time Machine** (rewind_to - PAST state):\n   ‚úì Recover EXACT state from specific timestamp\n   ‚úì Event sourcing replay from timeline.db\n   ‚úì Full Git reconstruction at any commit\n   ‚úì Advanced options:\n     - gitMode: none/metadata/full\n     - autoCheckout: Auto cd after rewind\n     - compareWith: Diff with another directory\n     - createSession: Auto-create session\n   ‚úì Merkle DAG for file reconstruction\n   ‚úó Requires exact timestamp\n   ‚úó More complex operation\n\n2Ô∏è‚É£ **Simple Session** (session_new - CURRENT state):\n   ‚úì Clone current Git repository (HEAD)\n   ‚úì Copy current files\n   ‚úì Simpler operation\n   ‚úó No time travel / event sourcing\n   ‚úó Current state only\n\nYour request: [describe what you understood]\n\nQuestions to clarify:\n‚Ä¢ Do you need a PAST state at specific timestamp? ‚Üí rewind_to\n‚Ä¢ Do you need CURRENT state in new directory? ‚Üí session_new\n\nIf using rewind_to, you MUST provide:\n1. Exact timestamp (use timeline_query to find available times)\n   Example: timeline_query with startTime/endTime to see events\n2. Confirmation of options:\n   - gitMode? (none/metadata/full)\n   - autoCheckout? (true/false)\n   - createSession? (true/false)\n   - compareWith? (optional directory path)\n\n**This is a powerful operation that reconstructs exact past state.**\n**I need your explicit permission to proceed.**\n\nPlease confirm:\n‚Ä¢ Exact timestamp you want to rewind to\n‚Ä¢ Which options you want (gitMode, autoCheckout, etc.)\n‚Ä¢ Permission to execute the rewind\"\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nPROCEED WITH rewind_to ONLY AFTER:\n1. User confirms they need PAST state (not current)\n2. User provides exact timestamp\n3. User gives explicit permission\n4. User confirms desired options (gitMode, autoCheckout, compareWith, createSession)`,\n        parameters: {\n          type: \"object\",\n          properties: {\n            targetTimestamp: { type: \"string\", description: \"Target timestamp (ISO format: 2025-11-28T12:00:00Z)\" },\n            outputDir: { type: \"string\", description: \"Output directory (default: auto-generated ~/grokinou_rewind_TIMESTAMP)\" },\n            includeFiles: { type: \"boolean\", description: \"Include file contents reconstruction from Merkle DAG (default: true)\" },\n            includeConversations: { type: \"boolean\", description: \"Include conversation history import (default: true)\" },\n            gitMode: { \n              type: \"string\", \n              enum: [\"none\", \"metadata\", \"full\"],\n              description: \"Git mode: 'none'=no git, 'metadata'=git_state.json only, 'full'=complete .git repo (default: metadata)\" \n            },\n            createSession: { type: \"boolean\", description: \"Create a new grokinou session in rewinded directory (default: false)\" },\n            autoCheckout: { type: \"boolean\", description: \"Automatically change working directory (process.cwd) to rewinded directory (default: false)\" },\n            compareWith: { type: \"string\", description: \"Compare rewinded state with another directory - generates detailed diff report (optional)\" },\n            reason: { type: \"string\", description: \"Human-readable reason for rewind (for logging and audit trail)\" },\n          },\n          required: [\"targetTimestamp\"],\n        },\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"list_time_points\",\n        description: \"List available snapshots and recent events for rewinding\",\n        parameters: { \n          type: \"object\" as const, \n          properties: {}, \n          required: [] \n        },\n      },\n    }\n  );\n  \n  return tools;\n}\n\n// Export dynamic tools array\nexport const GROK_TOOLS: GrokTool[] = buildGrokTools();\n\n// Global MCP manager instance\nlet mcpManager: MCPManager | null = null;\n\nexport function getMCPManager(): MCPManager {\n  if (!mcpManager) {\n    mcpManager = new MCPManager();\n  }\n  return mcpManager;\n}\n\nexport async function initializeMCPServers(): Promise<void> {\n  const manager = getMCPManager();\n  const config = loadMCPConfig();\n  \n  // Store original stderr.write\n  const originalStderrWrite = process.stderr.write;\n  \n  // Temporarily suppress stderr to hide verbose MCP connection logs\n  process.stderr.write = function(chunk: any, encoding?: any, callback?: any): boolean {\n    // Filter out mcp-remote verbose logs\n    const chunkStr = chunk.toString();\n    if (chunkStr.includes('[') && (\n        chunkStr.includes('Using existing client port') ||\n        chunkStr.includes('Connecting to remote server') ||\n        chunkStr.includes('Using transport strategy') ||\n        chunkStr.includes('Connected to remote server') ||\n        chunkStr.includes('Local STDIO server running') ||\n        chunkStr.includes('Proxy established successfully') ||\n        chunkStr.includes('Local‚ÜíRemote') ||\n        chunkStr.includes('Remote‚ÜíLocal')\n      )) {\n      // Suppress these verbose logs\n      if (callback) callback();\n      return true;\n    }\n    \n    // Allow other stderr output\n    return originalStderrWrite.call(this, chunk, encoding, callback);\n  };\n  \n  try {\n    for (const serverConfig of config.servers) {\n      try {\n        await manager.addServer(serverConfig);\n      } catch (error) {\n        console.warn(`Failed to initialize MCP server ${serverConfig.name}:`, error);\n      }\n    }\n  } finally {\n    // Restore original stderr.write\n    process.stderr.write = originalStderrWrite;\n  }\n}\n\nexport function convertMCPToolToGrokTool(mcpTool: MCPTool): GrokTool {\n  return {\n    type: \"function\",\n    function: {\n      name: mcpTool.name,\n      description: mcpTool.description,\n      parameters: mcpTool.inputSchema || {\n        type: \"object\",\n        properties: {},\n        required: []\n      }\n    }\n  };\n}\n\nexport function addMCPToolsToGrokTools(baseTools: GrokTool[]): GrokTool[] {\n  if (!mcpManager) {\n    return baseTools;\n  }\n  \n  const mcpTools = mcpManager.getTools();\n  const grokMCPTools = mcpTools.map(convertMCPToolToGrokTool);\n  \n  return [...baseTools, ...grokMCPTools];\n}\n\nexport async function getAllGrokTools(): Promise<GrokTool[]> {\n  const manager = getMCPManager();\n  // Try to initialize servers if not already done, but don't block\n  manager.ensureServersInitialized().catch(() => {\n    // Ignore initialization errors to avoid blocking\n  });\n  return addMCPToolsToGrokTools(GROK_TOOLS);\n}\n"
  },
  "src/utils/settings-manager.ts": {
    "path": "src/utils/settings-manager.ts",
    "hash": "b8f682f21191dd56586176b9b1347ccff620f72cac6f93854acb22901c4f5517",
    "size": 15399,
    "timestamp": 1764704879298,
    "content": "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\n\n/**\n * User-level settings stored in ~/.grok/user-settings.json\n * These are global settings that apply across all projects\n */\nexport interface UserSettings {\n  apiKey?: string; // Legacy: Grok API key (for backward compatibility)\n  baseURL?: string; // Legacy: API base URL\n  defaultModel?: string; // User's preferred default model\n  models?: string[]; // Available models list\n  persistInputHistory?: boolean; // Persist input history to ~/.grok/input-history.jsonl\n  \n  // NEW: Multi-provider support\n  apiKeys?: Record<string, string>; // API keys per provider: { grok: \"xai-xxx\", claude: \"sk-ant-xxx\" }\n  providers?: Record<string, {\n    baseURL: string;\n    models?: string[];\n  }>; // Provider configurations\n}\n\n/**\n * Execution Viewer settings\n */\nexport interface ExecutionViewerSettings {\n  enabled?: boolean; // Enable/disable execution viewer\n  defaultMode?: 'hidden' | 'split' | 'fullscreen'; // Default mode\n  autoShow?: boolean; // Auto-show when execution starts\n  autoHide?: boolean; // Auto-hide when execution ends\n  autoHideDelay?: number; // Delay before auto-hide (ms)\n  splitRatio?: number; // Split ratio (0-1, default 0.6)\n  layout?: 'horizontal' | 'vertical'; // Split layout orientation\n  showCOT?: boolean; // Show Chain of Thought\n  showCommands?: boolean; // Show command executions\n  detailsMode?: boolean; // Show details by default\n  maxExecutionsShown?: number; // Max executions in history\n  colorScheme?: 'default' | 'minimal' | 'verbose'; // Color scheme\n}\n\n/**\n * Project-level settings stored in .grok/settings.json\n * These are project-specific settings\n */\nexport interface ProjectSettings {\n  model?: string; // Current model for this project\n  mcpServers?: Record<string, any>; // MCP server configurations\n  persistSession?: boolean; // Persist chat session to .grok/session.jsonl\n  autoRestoreSession?: boolean; // Auto-restore session on launch\n  executionViewer?: ExecutionViewerSettings; // Execution viewer configuration\n}\n\n/**\n * Default values for user settings\n */\nconst DEFAULT_USER_SETTINGS: Partial<UserSettings> = {\n  baseURL: \"https://api.x.ai/v1\",\n  defaultModel: \"grok-4-latest\",\n  models: [\n    // === GROK (X.AI) ===\n    \"grok-4-latest\",\n    \"grok-code-fast-1\",\n    \"grok-3-latest\",\n    \"grok-3-fast\",\n    \"grok-3-mini-fast\",\n    \"grok2-vision-beta\",\n    \n    // === CLAUDE (Anthropic) - Verified names ===\n    \"claude-sonnet-4-5-20250514\", // Latest Sonnet 4.5 (May 2025)\n    \"claude-3-5-sonnet-20241022\",\n    \"claude-3-5-haiku-20241022\",\n    \"claude-3-opus-20240229\",\n    \n    // === OPENAI - Verified ‚úÖ (Tested 2025-11-22) ===\n    \"gpt-5\", // ‚úÖ Latest GPT-5 (Aug 2025)\n    \"gpt-5-2025-08-07\", // ‚úÖ Explicit date version\n    \"o3\", // ‚úÖ Latest O3 reasoning (Apr 2025)\n    \"o3-mini\", // ‚úÖ O3 Mini (Jan 2025)\n    \"o1\", // ‚úÖ O1 reasoning (Dec 2024)\n    \"gpt-4o\", // ‚úÖ Latest GPT-4o\n    \"gpt-4o-2024-11-20\", // ‚úÖ Nov 2024 version\n    \"gpt-4o-2024-08-06\", // ‚úÖ Aug 2024 version\n    \"gpt-4o-mini\", // ‚úÖ Mini version\n    \"chatgpt-4o-latest\", // ‚úÖ ChatGPT version\n    \"gpt-4-turbo\", // ‚úÖ GPT-4 Turbo\n    \"gpt-3.5-turbo\", // ‚úÖ GPT-3.5\n    \n    // === DEEPSEEK - Verified ‚úÖ (Tested 2025-11-22) ===\n    \"deepseek-chat\", // ‚úÖ General chat\n    \"deepseek-coder\", // ‚úÖ Coding (‚Üí deepseek-chat)\n    \"deepseek-reasoner\", // ‚úÖ R1 reasoning model\n    \n    // === MISTRAL - Verified ‚úÖ (Tested 2025-11-22) ===\n    \"mistral-large-latest\", // ‚úÖ\n    \"mistral-large-2407\", // ‚úÖ\n    \"mistral-medium-latest\", // ‚úÖ\n    \"mistral-small-latest\", // ‚úÖ\n    \"mistral-tiny\", // ‚úÖ\n    \"codestral-latest\", // ‚úÖ\n    \"codestral-2405\", // ‚úÖ\n    \"open-mistral-7b\", // ‚úÖ\n    \"open-mixtral-8x7b\", // ‚úÖ\n    \"open-mixtral-8x22b\", // ‚úÖ\n  ],\n  persistInputHistory: true,\n};\n\n/**\n * Default values for execution viewer\n */\nconst DEFAULT_EXECUTION_VIEWER_SETTINGS: ExecutionViewerSettings = {\n  enabled: true,\n  defaultMode: 'hidden',\n  autoShow: true,\n  autoHide: false,\n  autoHideDelay: 5000,\n  splitRatio: 0.6,\n  layout: 'horizontal',\n  showCOT: true,\n  showCommands: true,\n  detailsMode: false,\n  maxExecutionsShown: 10,\n  colorScheme: 'default',\n};\n\n/**\n * Default values for project settings\n */\nconst DEFAULT_PROJECT_SETTINGS: Partial<ProjectSettings> = {\n  model: \"grok-code-fast-1\",\n  persistSession: true,\n  autoRestoreSession: true,\n  executionViewer: DEFAULT_EXECUTION_VIEWER_SETTINGS,\n};\n\n/**\n * Unified settings manager that handles both user-level and project-level settings\n */\nexport class SettingsManager {\n  private static instance: SettingsManager;\n\n  private userSettingsPath: string;\n  private projectSettingsPath: string;\n\n  private constructor() {\n    // User settings path: ~/.grok/user-settings.json\n    this.userSettingsPath = path.join(\n      os.homedir(),\n      \".grok\",\n      \"user-settings.json\"\n    );\n\n    // Project settings path: .grok/settings.json (in current working directory)\n    this.projectSettingsPath = path.join(\n      process.cwd(),\n      \".grok\",\n      \"settings.json\"\n    );\n  }\n\n  /**\n   * Get singleton instance\n   */\n  public static getInstance(): SettingsManager {\n    if (!SettingsManager.instance) {\n      SettingsManager.instance = new SettingsManager();\n      SettingsManager.instance.migrateModelsIfNeeded();\n    }\n    return SettingsManager.instance;\n  }\n  \n  /**\n   * Auto-migrate old model list to include all providers\n   */\n  private migrateModelsIfNeeded(): void {\n    try {\n      const currentModels = this.getUserSetting(\"models\") || [];\n      const defaultCount = DEFAULT_USER_SETTINGS.models?.length || 35;\n      \n      // Check if migration is needed\n      // Migrate if:\n      // 1. List is significantly smaller than default (< 50% of default models)\n      // 2. OR list is empty\n      const needsMigration = \n        currentModels.length === 0 || \n        currentModels.length < (defaultCount / 2);\n      \n      if (needsMigration) {\n        console.log(`üîÑ Migrating model list from ${currentModels.length} to ${defaultCount} models...`);\n        this.updateUserSetting(\"models\", DEFAULT_USER_SETTINGS.models);\n        console.log(`‚úÖ Model list updated: ${currentModels.length} ‚Üí ${defaultCount} models`);\n      } else if (currentModels.length < defaultCount - 5) {\n        // List exists but is slightly outdated\n        // Don't auto-migrate (user might have customized), but log a warning\n        console.log(`‚ÑπÔ∏è  Your model list has ${currentModels.length} models (default: ${defaultCount})`);\n        console.log(`   Run /models to see all available models, or manually update ~/.grok/user-settings.json`);\n      }\n    } catch (error) {\n      // Silent fail - not critical\n    }\n  }\n\n  /**\n   * Ensure directory exists for a given file path\n   */\n  private ensureDirectoryExists(filePath: string): void {\n    const dir = path.dirname(filePath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true, mode: 0o700 });\n    }\n  }\n\n  /**\n   * Load user settings from ~/.grok/user-settings.json\n   */\n  public loadUserSettings(): UserSettings {\n    try {\n      if (!fs.existsSync(this.userSettingsPath)) {\n        // Create default user settings if file doesn't exist\n        this.saveUserSettings(DEFAULT_USER_SETTINGS);\n        return { ...DEFAULT_USER_SETTINGS };\n      }\n\n      const content = fs.readFileSync(this.userSettingsPath, \"utf-8\");\n      const settings = JSON.parse(content);\n\n      // Merge with defaults to ensure all required fields exist\n      return { ...DEFAULT_USER_SETTINGS, ...settings };\n    } catch (error) {\n      console.warn(\n        \"Failed to load user settings:\",\n        error instanceof Error ? error.message : \"Unknown error\"\n      );\n      return { ...DEFAULT_USER_SETTINGS };\n    }\n  }\n\n  /**\n   * Save user settings to ~/.grok/user-settings.json\n   */\n  public saveUserSettings(settings: Partial<UserSettings>): void {\n    try {\n      this.ensureDirectoryExists(this.userSettingsPath);\n\n      // Read existing settings directly to avoid recursion\n      let existingSettings: UserSettings = { ...DEFAULT_USER_SETTINGS };\n      if (fs.existsSync(this.userSettingsPath)) {\n        try {\n          const content = fs.readFileSync(this.userSettingsPath, \"utf-8\");\n          const parsed = JSON.parse(content);\n          existingSettings = { ...DEFAULT_USER_SETTINGS, ...parsed };\n        } catch (error) {\n          // If file is corrupted, use defaults\n          console.warn(\"Corrupted user settings file, using defaults\");\n        }\n      }\n\n      const mergedSettings = { ...existingSettings, ...settings };\n\n      fs.writeFileSync(\n        this.userSettingsPath,\n        JSON.stringify(mergedSettings, null, 2),\n        { mode: 0o600 } // Secure permissions for API key\n      );\n    } catch (error) {\n      console.error(\n        \"Failed to save user settings:\",\n        error instanceof Error ? error.message : \"Unknown error\"\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Update a specific user setting\n   */\n  public updateUserSetting<K extends keyof UserSettings>(\n    key: K,\n    value: UserSettings[K]\n  ): void {\n    const settings = { [key]: value } as Partial<UserSettings>;\n    this.saveUserSettings(settings);\n  }\n\n  /**\n   * Get a specific user setting\n   */\n  public getUserSetting<K extends keyof UserSettings>(key: K): UserSettings[K] {\n    const settings = this.loadUserSettings();\n    return settings[key];\n  }\n\n  /**\n   * Load project settings from .grok/settings.json\n   */\n  public loadProjectSettings(): ProjectSettings {\n    try {\n      if (!fs.existsSync(this.projectSettingsPath)) {\n        // Create default project settings if file doesn't exist\n        this.saveProjectSettings(DEFAULT_PROJECT_SETTINGS);\n        return { ...DEFAULT_PROJECT_SETTINGS };\n      }\n\n      const content = fs.readFileSync(this.projectSettingsPath, \"utf-8\");\n      const settings = JSON.parse(content);\n\n      // Merge with defaults\n      return { ...DEFAULT_PROJECT_SETTINGS, ...settings };\n    } catch (error) {\n      console.warn(\n        \"Failed to load project settings:\",\n        error instanceof Error ? error.message : \"Unknown error\"\n      );\n      return { ...DEFAULT_PROJECT_SETTINGS };\n    }\n  }\n\n  /**\n   * Save project settings to .grok/settings.json\n   */\n  public saveProjectSettings(settings: Partial<ProjectSettings>): void {\n    try {\n      this.ensureDirectoryExists(this.projectSettingsPath);\n\n      // Read existing settings directly to avoid recursion\n      let existingSettings: ProjectSettings = { ...DEFAULT_PROJECT_SETTINGS };\n      if (fs.existsSync(this.projectSettingsPath)) {\n        try {\n          const content = fs.readFileSync(this.projectSettingsPath, \"utf-8\");\n          const parsed = JSON.parse(content);\n          existingSettings = { ...DEFAULT_PROJECT_SETTINGS, ...parsed };\n        } catch (error) {\n          // If file is corrupted, use defaults\n          console.warn(\"Corrupted project settings file, using defaults\");\n        }\n      }\n\n      const mergedSettings = { ...existingSettings, ...settings };\n\n      fs.writeFileSync(\n        this.projectSettingsPath,\n        JSON.stringify(mergedSettings, null, 2)\n      );\n    } catch (error) {\n      console.error(\n        \"Failed to save project settings:\",\n        error instanceof Error ? error.message : \"Unknown error\"\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Update a specific project setting\n   */\n  public updateProjectSetting<K extends keyof ProjectSettings>(\n    key: K,\n    value: ProjectSettings[K]\n  ): void {\n    const settings = { [key]: value } as Partial<ProjectSettings>;\n    this.saveProjectSettings(settings);\n  }\n\n  /**\n   * Get a specific project setting\n   */\n  public getProjectSetting<K extends keyof ProjectSettings>(\n    key: K\n  ): ProjectSettings[K] {\n    const settings = this.loadProjectSettings();\n    return settings[key];\n  }\n\n  /**\n   * Get the current model with proper fallback logic:\n   * 1. Project-specific model setting\n   * 2. User's default model\n   * 3. System default\n   */\n  public getCurrentModel(): string {\n    const projectModel = this.getProjectSetting(\"model\");\n    if (projectModel) {\n      return projectModel;\n    }\n\n    const userDefaultModel = this.getUserSetting(\"defaultModel\");\n    if (userDefaultModel) {\n      return userDefaultModel;\n    }\n\n    return DEFAULT_PROJECT_SETTINGS.model || \"grok-code-fast-1\";\n  }\n\n  /**\n   * Set the current model for the project\n   */\n  public setCurrentModel(model: string): void {\n    this.updateProjectSetting(\"model\", model);\n  }\n\n  /**\n   * Get available models list from user settings\n   */\n  public getAvailableModels(): string[] {\n    const models = this.getUserSetting(\"models\");\n    return models || DEFAULT_USER_SETTINGS.models || [];\n  }\n\n  /**\n   * Get API key from user settings or environment (legacy - for backward compatibility)\n   */\n  public getApiKey(): string | undefined {\n    // First check environment variable\n    const envApiKey = process.env.GROK_API_KEY;\n    if (envApiKey) {\n      return envApiKey;\n    }\n\n    // Then check user settings\n    return this.getUserSetting(\"apiKey\");\n  }\n  \n  /**\n   * Get all API keys (multi-provider)\n   */\n  public getApiKeys(): Record<string, string> | undefined {\n    const apiKeys = this.getUserSetting(\"apiKeys\");\n    \n    // Backward compatibility: if apiKeys not set but apiKey is, use it for grok\n    if (!apiKeys || Object.keys(apiKeys).length === 0) {\n      const legacyKey = this.getApiKey();\n      if (legacyKey) {\n        return { grok: legacyKey };\n      }\n    }\n    \n    return apiKeys;\n  }\n  \n  /**\n   * Get API key for a specific provider\n   */\n  public getApiKeyForProvider(provider: string): string | undefined {\n    const apiKeys = this.getApiKeys();\n    return apiKeys?.[provider];\n  }\n  \n  /**\n   * Set API key for a specific provider\n   */\n  public setApiKey(provider: string, apiKey: string): void {\n    const apiKeys = this.getApiKeys() || {};\n    apiKeys[provider] = apiKey;\n    this.updateUserSetting(\"apiKeys\", apiKeys);\n  }\n  \n  /**\n   * Get provider configurations\n   */\n  public getProviders(): Record<string, { baseURL: string; models?: string[] }> | undefined {\n    return this.getUserSetting(\"providers\");\n  }\n\n  /**\n   * Get base URL from user settings or environment\n   */\n  public getBaseURL(): string {\n    // First check environment variable\n    const envBaseURL = process.env.GROK_BASE_URL;\n    if (envBaseURL) {\n      return envBaseURL;\n    }\n\n    // Then check user settings\n    const userBaseURL = this.getUserSetting(\"baseURL\");\n    return (\n      userBaseURL || DEFAULT_USER_SETTINGS.baseURL || \"https://api.x.ai/v1\"\n    );\n  }\n\n  /**\n   * Get execution viewer settings (merged with defaults)\n   */\n  public getExecutionViewerSettings(): ExecutionViewerSettings {\n    const projectSettings = this.getProjectSetting(\"executionViewer\") || {};\n    return {\n      ...DEFAULT_EXECUTION_VIEWER_SETTINGS,\n      ...projectSettings,\n    };\n  }\n\n  /**\n   * Update execution viewer setting\n   */\n  public updateExecutionViewerSetting<K extends keyof ExecutionViewerSettings>(\n    key: K,\n    value: ExecutionViewerSettings[K]\n  ): void {\n    const current = this.getProjectSetting(\"executionViewer\") || {};\n    this.updateProjectSetting(\"executionViewer\", {\n      ...current,\n      [key]: value,\n    });\n  }\n}\n\n/**\n * Convenience function to get the singleton instance\n */\nexport function getSettingsManager(): SettingsManager {\n  return SettingsManager.getInstance();\n}\n"
  },
  "dist/timeline/rewind-engine.js": {
    "path": "dist/timeline/rewind-engine.js",
    "hash": "11aab8b02cc74a8ce256c8079778b8e3da28d4bafe720f7f0bb0f77e9d034b3e",
    "size": 29311,
    "timestamp": 1764704879298,
    "content": "/**\n * Rewind Engine - Time Travel for System State\n *\n * Reconstructs the complete system state at any point in time by:\n * 1. Loading nearest snapshot before target timestamp\n * 2. Replaying events from snapshot to target timestamp\n * 3. Materializing state (files, conversations, git) to output directory\n *\n * This is the core \"Time Machine\" feature.\n *\n * Features:\n * - Full state reconstruction\n * - Incremental replay from snapshots\n * - File system materialization\n * - Git state restoration\n * - Conversation history rebuild\n * - Non-destructive (creates new directory)\n *\n * @module timeline/rewind-engine\n * @version 1.0.0\n */\nimport fs from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { TimelineDatabase } from './database.js';\nimport { EventBus } from './event-bus.js';\nimport { QueryEngine } from './query-engine.js';\nimport { SnapshotManager } from './snapshot-manager.js';\nimport { MerkleDAG } from './storage/merkle-dag.js';\nimport { EventType } from './event-types.js';\nconst mkdir = promisify(fs.mkdir);\nconst writeFile = promisify(fs.writeFile);\nconst copyFile = promisify(fs.copyFile);\n/**\n * Rewind Engine\n */\nexport class RewindEngine {\n    static instance;\n    db;\n    bus;\n    queryEngine;\n    snapshotManager;\n    merkleDAG;\n    constructor() {\n        this.db = TimelineDatabase.getInstance();\n        this.bus = EventBus.getInstance();\n        this.queryEngine = QueryEngine.getInstance();\n        this.snapshotManager = SnapshotManager.getInstance();\n        this.merkleDAG = MerkleDAG.getInstance();\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!RewindEngine.instance) {\n            RewindEngine.instance = new RewindEngine();\n        }\n        return RewindEngine.instance;\n    }\n    /**\n     * Rewind to a specific timestamp\n     */\n    async rewindTo(options) {\n        const startTime = Date.now();\n        const { targetTimestamp, outputDir, includeFiles = true, includeConversations = true, includeGit = true, // Deprecated, for backward compatibility\n        gitMode = includeGit ? 'metadata' : 'none', // Default to metadata if includeGit=true\n        createSession = false, autoCheckout = false, compareWith, onProgress, } = options;\n        const reportProgress = (message, progress) => {\n            if (onProgress)\n                onProgress(message, progress);\n        };\n        try {\n            reportProgress('Starting rewind operation', 0);\n            // Emit rewind started event\n            await this.bus.emit({\n                event_type: EventType.REWIND_STARTED,\n                actor: 'system',\n                aggregate_id: targetTimestamp.toString(),\n                aggregate_type: 'rewind',\n                payload: {\n                    target_timestamp: targetTimestamp,\n                    target_timestamp_human: new Date(targetTimestamp).toISOString(),\n                    output_dir: outputDir || 'auto',\n                    requested_by: 'user',\n                },\n            });\n            // 1. Find nearest snapshot before target timestamp\n            reportProgress('Finding nearest snapshot', 10);\n            const snapshotMeta = await this.snapshotManager.getSnapshotBeforeTimestamp(targetTimestamp);\n            let baseState;\n            let baseFiles;\n            let baseGit;\n            let startSequence = 0;\n            if (snapshotMeta) {\n                reportProgress(`Loading snapshot: ${snapshotMeta.snapshot_id}`, 20);\n                const snapshot = await this.snapshotManager.loadSnapshot(snapshotMeta.snapshot_id);\n                if (snapshot) {\n                    baseState = this.extractSessionState(snapshot);\n                    baseFiles = this.extractFileState(snapshot);\n                    baseGit = this.extractGitState(snapshot);\n                    startSequence = snapshotMeta.sequence_number;\n                    await this.bus.emit({\n                        event_type: EventType.REWIND_SNAPSHOT_LOADED,\n                        actor: 'system',\n                        aggregate_id: snapshotMeta.snapshot_id,\n                        aggregate_type: 'snapshot',\n                        payload: {\n                            snapshot_id: snapshotMeta.snapshot_id,\n                            snapshot_timestamp: snapshotMeta.timestamp,\n                        },\n                    });\n                }\n                else {\n                    // No snapshot, start from empty state\n                    baseState = this.createEmptySessionState();\n                    baseFiles = new Map();\n                    baseGit = this.createEmptyGitState();\n                }\n            }\n            else {\n                // No snapshot found, replay from beginning\n                reportProgress('No snapshot found, replaying from beginning', 20);\n                baseState = this.createEmptySessionState();\n                baseFiles = new Map();\n                baseGit = this.createEmptyGitState();\n            }\n            // 2. Query events from snapshot to target timestamp\n            reportProgress('Querying events to replay', 30);\n            const { events } = this.queryEngine.query({\n                startTime: snapshotMeta?.timestamp || 0,\n                endTime: targetTimestamp,\n                limit: 999999,\n                order: 'asc',\n            });\n            reportProgress(`Replaying ${events.length} events`, 40);\n            // 3. Replay events to reconstruct state\n            let currentState = baseState;\n            let currentFiles = baseFiles;\n            let currentGit = baseGit;\n            for (let i = 0; i < events.length; i++) {\n                const event = events[i];\n                const progress = 40 + Math.floor((i / events.length) * 40);\n                if (i % 100 === 0) {\n                    reportProgress(`Replaying event ${i}/${events.length}`, progress);\n                }\n                // Apply event to state\n                currentState = this.applyEventToSessionState(currentState, event);\n                currentFiles = this.applyEventToFileState(currentFiles, event);\n                currentGit = this.applyEventToGitState(currentGit, event);\n            }\n            await this.bus.emit({\n                event_type: EventType.REWIND_EVENTS_REPLAYED,\n                actor: 'system',\n                aggregate_id: targetTimestamp.toString(),\n                aggregate_type: 'rewind',\n                payload: {\n                    events_replayed: events.length,\n                },\n            });\n            // 4. Materialize state to output directory\n            reportProgress('Materializing state to filesystem', 80);\n            const finalOutputDir = outputDir || this.generateOutputDir(targetTimestamp);\n            await mkdir(finalOutputDir, { recursive: true });\n            let filesRestored = 0;\n            // Write session state\n            if (includeConversations) {\n                const sessionFile = path.join(finalOutputDir, 'session_state.json');\n                await writeFile(sessionFile, JSON.stringify(currentState, null, 2));\n            }\n            // Write file states\n            if (includeFiles) {\n                const filesDir = path.join(finalOutputDir, 'files');\n                await mkdir(filesDir, { recursive: true });\n                for (const [filePath, fileState] of currentFiles.entries()) {\n                    if (fileState.exists) {\n                        try {\n                            // Only attempt restore if we have a content hash\n                            if (!fileState.contentHash) {\n                                continue;\n                            }\n                            // Try to restore from Merkle DAG\n                            const blob = await this.merkleDAG.retrieveBlob(fileState.contentHash);\n                            if (blob) {\n                                const targetPath = path.join(filesDir, filePath);\n                                await mkdir(path.dirname(targetPath), { recursive: true });\n                                await writeFile(targetPath, blob.content);\n                                filesRestored++;\n                            }\n                        }\n                        catch (error) {\n                            console.error(`Failed to restore file ${filePath}:`, error);\n                        }\n                    }\n                }\n            }\n            // Write git state based on gitMode\n            if (gitMode !== 'none') {\n                if (gitMode === 'metadata') {\n                    // Just write git_state.json with metadata\n                    const gitFile = path.join(finalOutputDir, 'git_state.json');\n                    await writeFile(gitFile, JSON.stringify(currentGit, null, 2));\n                }\n                else if (gitMode === 'full') {\n                    // Materialize full git repository\n                    reportProgress('Materializing Git repository', 85);\n                    await this.materializeGitRepository(finalOutputDir, currentGit, onProgress);\n                    // Also write metadata for reference\n                    const gitFile = path.join(finalOutputDir, 'git_state.json');\n                    await writeFile(gitFile, JSON.stringify(currentGit, null, 2));\n                }\n            }\n            // Write file manifest\n            const manifestFile = path.join(finalOutputDir, 'file_manifest.json');\n            await writeFile(manifestFile, JSON.stringify(Array.from(currentFiles.entries()), null, 2));\n            await this.bus.emit({\n                event_type: EventType.REWIND_STATE_MATERIALIZED,\n                actor: 'system',\n                aggregate_id: targetTimestamp.toString(),\n                aggregate_type: 'rewind',\n                payload: {\n                    output_directory: finalOutputDir,\n                    files_restored: filesRestored,\n                },\n            });\n            reportProgress('Rewind completed successfully', 90);\n            // Compare with another directory if requested\n            let comparisonReport;\n            if (compareWith) {\n                reportProgress('Comparing with target directory', 92);\n                try {\n                    comparisonReport = await this.compareDirectories(finalOutputDir, compareWith, currentFiles);\n                    console.log(`üìä Comparison: ${comparisonReport.added} added, ${comparisonReport.modified} modified, ${comparisonReport.deleted} deleted`);\n                }\n                catch (error) {\n                    console.error('Failed to compare directories:', error);\n                    // Don't fail the whole rewind\n                }\n            }\n            // Create session in rewinded directory if requested\n            let sessionCreated;\n            if (createSession) {\n                reportProgress('Creating session in rewinded directory', 95);\n                try {\n                    const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n                    const { providerManager } = await import('../utils/provider-manager.js');\n                    // Determine model/provider from reconstructed state\n                    const model = currentState.model || 'grok-beta';\n                    const provider = currentState.provider || providerManager.detectProvider(model) || 'grok';\n                    // Get API key (from current environment)\n                    const providerConfig = providerManager.getProviderForModel(model);\n                    const apiKey = providerConfig?.apiKey;\n                    if (!apiKey) {\n                        console.warn(`No API key found for ${provider}, session created without API key`);\n                    }\n                    // Create new session in rewinded directory\n                    const { session } = await sessionManager.createNewSession(finalOutputDir, provider, model, apiKey, {\n                        importHistory: includeConversations,\n                        // If we have conversations, they're already in session_state.json\n                    });\n                    sessionCreated = {\n                        sessionId: session.id,\n                        sessionName: session.session_name || `Rewind-${new Date(targetTimestamp).toISOString()}`,\n                    };\n                    console.log(`‚úÖ Created session #${session.id} in ${finalOutputDir}`);\n                }\n                catch (error) {\n                    console.error('Failed to create session:', error);\n                    // Don't fail the whole rewind, just log the error\n                }\n            }\n            // Auto-checkout to rewinded directory if requested\n            let autoCheckedOut = false;\n            let previousWorkingDir;\n            if (autoCheckout) {\n                reportProgress('Checking out to rewinded directory', 98);\n                try {\n                    previousWorkingDir = process.cwd();\n                    process.chdir(finalOutputDir);\n                    autoCheckedOut = true;\n                    console.log(`üìÇ Changed working directory from ${previousWorkingDir} to ${finalOutputDir}`);\n                }\n                catch (error) {\n                    console.error('Failed to change directory:', error);\n                    // Don't fail the whole rewind\n                }\n            }\n            await this.bus.emit({\n                event_type: EventType.REWIND_COMPLETED,\n                actor: 'system',\n                aggregate_id: targetTimestamp.toString(),\n                aggregate_type: 'rewind',\n                payload: {\n                    duration_ms: Date.now() - startTime,\n                    success: true,\n                    session_created: sessionCreated !== undefined,\n                    auto_checked_out: autoCheckedOut,\n                    comparison_performed: comparisonReport !== undefined,\n                },\n            });\n            reportProgress('All operations completed', 100);\n            return {\n                success: true,\n                targetTimestamp,\n                snapshotUsed: snapshotMeta?.snapshot_id || null,\n                eventsReplayed: events.length,\n                filesRestored,\n                outputDirectory: finalOutputDir,\n                duration: Date.now() - startTime,\n                sessionCreated,\n                comparisonReport,\n                autoCheckedOut,\n                previousWorkingDir,\n            };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            await this.bus.emit({\n                event_type: EventType.REWIND_FAILED,\n                actor: 'system',\n                aggregate_id: targetTimestamp.toString(),\n                aggregate_type: 'rewind',\n                payload: {\n                    error: errorMessage,\n                    duration_ms: Date.now() - startTime,\n                },\n            });\n            return {\n                success: false,\n                targetTimestamp,\n                snapshotUsed: null,\n                eventsReplayed: 0,\n                filesRestored: 0,\n                outputDirectory: outputDir || '',\n                duration: Date.now() - startTime,\n                error: errorMessage,\n            };\n        }\n    }\n    /**\n     * Extract session state from snapshot\n     */\n    extractSessionState(snapshot) {\n        return {\n            sessionId: snapshot.session_state.active_session_id,\n            sessionName: null,\n            workingDir: snapshot.session_state.working_directory,\n            model: snapshot.session_state.model,\n            provider: snapshot.session_state.provider,\n            conversations: [],\n        };\n    }\n    /**\n     * Extract file state from snapshot\n     */\n    extractFileState(snapshot) {\n        const files = new Map();\n        for (const [filePath, contentHash] of Object.entries(snapshot.file_checksums)) {\n            files.set(filePath, {\n                path: filePath,\n                contentHash,\n                exists: true,\n                lastModified: snapshot.metadata.timestamp,\n            });\n        }\n        return files;\n    }\n    /**\n     * Extract git state from snapshot\n     */\n    extractGitState(snapshot) {\n        return {\n            commitHash: snapshot.git_state.commit_hash,\n            branch: snapshot.git_state.branch,\n            isClean: snapshot.git_state.is_clean,\n        };\n    }\n    /**\n     * Create empty session state\n     */\n    createEmptySessionState() {\n        return {\n            sessionId: null,\n            sessionName: null,\n            workingDir: process.cwd(),\n            conversations: [],\n        };\n    }\n    /**\n     * Create empty git state\n     */\n    createEmptyGitState() {\n        return {\n            commitHash: null,\n            branch: null,\n            isClean: true,\n        };\n    }\n    /**\n     * Apply event to session state\n     */\n    applyEventToSessionState(state, event) {\n        const newState = { ...state };\n        switch (event.event_type) {\n            case EventType.SESSION_CREATED:\n                newState.sessionId = event.payload.session_id;\n                newState.sessionName = event.payload.session_name;\n                newState.workingDir = event.payload.working_dir;\n                break;\n            case EventType.SESSION_SWITCHED:\n                newState.sessionId = event.payload.session_id;\n                newState.workingDir = event.payload.working_dir;\n                break;\n            case EventType.LLM_MESSAGE_USER:\n            case EventType.LLM_MESSAGE_ASSISTANT:\n            case EventType.LLM_MESSAGE_SYSTEM:\n                newState.conversations.push({\n                    role: event.event_type === EventType.LLM_MESSAGE_USER ? 'user' :\n                        event.event_type === EventType.LLM_MESSAGE_ASSISTANT ? 'assistant' : 'system',\n                    content: event.payload.content || '',\n                    timestamp: event.timestamp,\n                });\n                break;\n            case EventType.MODEL_CHANGED:\n                newState.model = event.payload.new_model;\n                break;\n            case EventType.PROVIDER_CHANGED:\n                newState.provider = event.payload.new_provider;\n                break;\n        }\n        return newState;\n    }\n    /**\n     * Apply event to file state\n     */\n    applyEventToFileState(files, event) {\n        const newFiles = new Map(files);\n        const payload = event.payload;\n        switch (event.event_type) {\n            case EventType.FILE_CREATED:\n            case EventType.FILE_MODIFIED:\n                newFiles.set(payload.path, {\n                    path: payload.path,\n                    contentHash: payload.new_hash || payload.content_hash || null,\n                    exists: true,\n                    lastModified: event.timestamp,\n                });\n                break;\n            case EventType.FILE_DELETED:\n                newFiles.set(payload.path, {\n                    path: payload.path,\n                    contentHash: '',\n                    exists: false,\n                    lastModified: event.timestamp,\n                });\n                break;\n            case EventType.FILE_RENAMED:\n            case EventType.FILE_MOVED:\n                const oldFile = newFiles.get(payload.old_path);\n                if (oldFile) {\n                    newFiles.delete(payload.old_path);\n                    newFiles.set(payload.new_path, {\n                        ...oldFile,\n                        path: payload.new_path,\n                        lastModified: event.timestamp,\n                    });\n                }\n                break;\n        }\n        return newFiles;\n    }\n    /**\n     * Apply event to git state\n     */\n    applyEventToGitState(state, event) {\n        const newState = { ...state };\n        const payload = event.payload;\n        switch (event.event_type) {\n            case EventType.GIT_COMMIT:\n                newState.commitHash = payload.hash;\n                break;\n            case EventType.GIT_BRANCH_SWITCHED:\n                newState.branch = payload.branch;\n                break;\n        }\n        return newState;\n    }\n    /**\n     * Generate output directory name\n     */\n    generateOutputDir(timestamp) {\n        const dateStr = new Date(timestamp).toISOString().replace(/[:.]/g, '-');\n        return path.join(process.cwd(), `.rewind_${dateStr}`);\n    }\n    /**\n     * Compare rewinded directory with another directory\n     */\n    async compareDirectories(rewindDir, compareDir, rewindFiles) {\n        const crypto = await import('crypto');\n        const fsModule = await import('fs');\n        const { readdir, readFile, stat } = await import('fs/promises');\n        // Helper to calculate file hash\n        const calculateHash = async (filePath) => {\n            try {\n                const content = await readFile(filePath);\n                return crypto.createHash('sha256').update(content).digest('hex');\n            }\n            catch {\n                return '';\n            }\n        };\n        // Helper to recursively get all files in a directory\n        const getAllFiles = async (dir, baseDir = dir) => {\n            const files = new Set();\n            try {\n                const entries = await readdir(dir, { withFileTypes: true });\n                for (const entry of entries) {\n                    const fullPath = path.join(dir, entry.name);\n                    const relativePath = path.relative(baseDir, fullPath);\n                    // Skip .git and other hidden directories\n                    if (entry.name.startsWith('.')) {\n                        continue;\n                    }\n                    if (entry.isDirectory()) {\n                        const subFiles = await getAllFiles(fullPath, baseDir);\n                        subFiles.forEach(f => files.add(f));\n                    }\n                    else if (entry.isFile()) {\n                        files.add(relativePath);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(`Error reading directory ${dir}:`, error);\n            }\n            return files;\n        };\n        const report = {\n            compareDirectory: compareDir,\n            totalFiles: 0,\n            added: 0,\n            deleted: 0,\n            modified: 0,\n            unchanged: 0,\n            files: [],\n        };\n        try {\n            // Get all files from both directories\n            const rewindFilesDir = path.join(rewindDir, 'files');\n            const rewindFilePaths = await getAllFiles(rewindFilesDir);\n            const compareFilePaths = fsModule.existsSync(compareDir)\n                ? await getAllFiles(compareDir)\n                : new Set();\n            // Combine all file paths\n            const allPaths = new Set([...rewindFilePaths, ...compareFilePaths]);\n            report.totalFiles = allPaths.size;\n            // Compare each file\n            for (const relativePath of allPaths) {\n                const rewindPath = path.join(rewindFilesDir, relativePath);\n                const comparePath = path.join(compareDir, relativePath);\n                const rewindExists = fsModule.existsSync(rewindPath);\n                const compareExists = fsModule.existsSync(comparePath);\n                let comparison;\n                if (rewindExists && !compareExists) {\n                    // File added in rewind (was deleted in compare)\n                    comparison = {\n                        path: relativePath,\n                        status: 'deleted',\n                        rewindHash: await calculateHash(rewindPath),\n                    };\n                    report.deleted++;\n                }\n                else if (!rewindExists && compareExists) {\n                    // File deleted in rewind (was added in compare)\n                    comparison = {\n                        path: relativePath,\n                        status: 'added',\n                        compareHash: await calculateHash(comparePath),\n                    };\n                    report.added++;\n                }\n                else if (rewindExists && compareExists) {\n                    // File exists in both, check if modified\n                    const rewindHash = await calculateHash(rewindPath);\n                    const compareHash = await calculateHash(comparePath);\n                    if (rewindHash === compareHash) {\n                        comparison = {\n                            path: relativePath,\n                            status: 'unchanged',\n                            rewindHash,\n                            compareHash,\n                        };\n                        report.unchanged++;\n                    }\n                    else {\n                        const rewindStat = await stat(rewindPath);\n                        const compareStat = await stat(comparePath);\n                        comparison = {\n                            path: relativePath,\n                            status: 'modified',\n                            rewindHash,\n                            compareHash,\n                            sizeDiff: rewindStat.size - compareStat.size,\n                        };\n                        report.modified++;\n                    }\n                }\n                else {\n                    // Should not happen\n                    continue;\n                }\n                report.files.push(comparison);\n            }\n            // Sort files by status for better readability\n            report.files.sort((a, b) => {\n                const statusOrder = { added: 1, deleted: 2, modified: 3, unchanged: 4 };\n                return statusOrder[a.status] - statusOrder[b.status];\n            });\n        }\n        catch (error) {\n            console.error('Error during directory comparison:', error);\n            throw error;\n        }\n        return report;\n    }\n    /**\n     * Materialize full Git repository at target commit\n     */\n    async materializeGitRepository(outputDir, gitState, onProgress) {\n        try {\n            const { exec } = await import('child_process');\n            const { promisify } = await import('util');\n            const execAsync = promisify(exec);\n            const reportProgress = (msg) => {\n                if (onProgress)\n                    onProgress(msg, 85);\n            };\n            // Find the source git repository\n            const currentDir = process.cwd();\n            const gitDir = path.join(currentDir, '.git');\n            // Check if we're in a git repository\n            const fsModule = await import('fs');\n            if (!fsModule.existsSync(gitDir)) {\n                console.warn('Not in a git repository, skipping git materialization');\n                return;\n            }\n            reportProgress('Copying .git directory');\n            // Method 1: Clone the current repo to the output directory\n            // This is safer and cleaner than copying .git manually\n            try {\n                // Clone current repo to output dir\n                await execAsync(`git clone \"${currentDir}\" \"${outputDir}_temp\"`);\n                // Move the cloned content to the actual output dir\n                const tempGitDir = path.join(`${outputDir}_temp`, '.git');\n                const targetGitDir = path.join(outputDir, '.git');\n                // Copy .git directory\n                await execAsync(`cp -r \"${tempGitDir}\" \"${targetGitDir}\"`);\n                // Remove temp directory\n                await execAsync(`rm -rf \"${outputDir}_temp\"`);\n                reportProgress('Checking out target commit');\n                // Checkout the specific commit\n                if (gitState.commitHash) {\n                    await execAsync(`git -C \"${outputDir}\" checkout ${gitState.commitHash}`, {\n                        cwd: outputDir\n                    });\n                }\n                // If branch is specified and different from current, try to checkout branch\n                if (gitState.branch) {\n                    try {\n                        await execAsync(`git -C \"${outputDir}\" checkout ${gitState.branch}`, {\n                            cwd: outputDir\n                        });\n                    }\n                    catch (error) {\n                        // Branch might not exist or commit might be detached, that's ok\n                        console.warn(`Could not checkout branch ${gitState.branch}, staying on commit ${gitState.commitHash}`);\n                    }\n                }\n                reportProgress('Git repository materialized successfully');\n            }\n            catch (error) {\n                console.error('Failed to materialize git repository:', error);\n                throw new Error(`Git materialization failed: ${error instanceof Error ? error.message : String(error)}`);\n            }\n        }\n        catch (error) {\n            console.error('Error in materializeGitRepository:', error);\n            throw error;\n        }\n    }\n}\n/**\n * Get RewindEngine singleton instance\n */\nexport function getRewindEngine() {\n    return RewindEngine.getInstance();\n}\n//# sourceMappingURL=rewind-engine.js.map"
  },
  "dist/timeline/hooks/git-hook.js": {
    "path": "dist/timeline/hooks/git-hook.js",
    "hash": "28e3afab8b7ebc875c6bd24c3845ed823b2d5052dbb1527a98cb5620c349d791",
    "size": 11516,
    "timestamp": 1764704879298,
    "content": "/**\n * Git Hook - Automatic Git Command Tracking\n *\n * Captures git operations (commit, push, pull, merge, etc.) and logs them\n * to the timeline for complete version control history.\n *\n * Features:\n * - Wrapper for common git commands\n * - Automatic commit tracking\n * - Branch and merge detection\n * - Integration with Merkle DAG\n * - Singleton pattern\n *\n * @module timeline/hooks/git-hook\n * @version 1.0.0\n */\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { EventBus } from '../event-bus.js';\nimport { EventType } from '../event-types.js';\nconst execAsync = promisify(exec);\n/**\n * Git Hook for tracking git operations\n */\nexport class GitHook {\n    static instance;\n    bus;\n    config;\n    isEnabled = false;\n    constructor(config = {}) {\n        this.bus = EventBus.getInstance();\n        this.config = {\n            enabled: config.enabled ?? true,\n            repoPath: config.repoPath ?? process.cwd(),\n            trackCommands: config.trackCommands ?? ['commit', 'push', 'pull', 'merge', 'rebase', 'checkout'],\n        };\n        this.isEnabled = this.config.enabled;\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!GitHook.instance) {\n            GitHook.instance = new GitHook(config);\n        }\n        return GitHook.instance;\n    }\n    /**\n     * Execute git command and capture output\n     */\n    async executeGit(args) {\n        const command = `git ${args.join(' ')}`;\n        try {\n            const { stdout, stderr } = await execAsync(command, {\n                cwd: this.config.repoPath,\n                maxBuffer: 10 * 1024 * 1024, // 10MB\n            });\n            return {\n                success: true,\n                stdout: stdout.trim(),\n                stderr: stderr.trim(),\n                exitCode: 0,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                stdout: error.stdout?.trim() || '',\n                stderr: error.stderr?.trim() || error.message || '',\n                exitCode: error.code || 1,\n            };\n        }\n    }\n    /**\n     * Get current branch name\n     */\n    async getCurrentBranch() {\n        const result = await this.executeGit(['rev-parse', '--abbrev-ref', 'HEAD']);\n        return result.success ? result.stdout : 'unknown';\n    }\n    /**\n     * Get last commit info\n     */\n    async getLastCommitInfo() {\n        try {\n            // Get commit hash\n            const hashResult = await this.executeGit(['rev-parse', 'HEAD']);\n            if (!hashResult.success)\n                return null;\n            const hash = hashResult.stdout;\n            // Get commit details\n            const detailsResult = await this.executeGit([\n                'log', '-1', '--format=%s%n%an%n%ae%n%at', hash\n            ]);\n            if (!detailsResult.success)\n                return null;\n            const [message, author, email, timestamp] = detailsResult.stdout.split('\\n');\n            // Get stats\n            const statsResult = await this.executeGit([\n                'show', '--stat', '--format=', hash\n            ]);\n            let filesChanged = 0;\n            let insertions = 0;\n            let deletions = 0;\n            if (statsResult.success) {\n                const lines = statsResult.stdout.split('\\n');\n                const summaryLine = lines[lines.length - 1];\n                const match = summaryLine.match(/(\\d+) files? changed(?:, (\\d+) insertions?\\(\\+\\))?(?:, (\\d+) deletions?\\(-\\))?/);\n                if (match) {\n                    filesChanged = parseInt(match[1] || '0');\n                    insertions = parseInt(match[2] || '0');\n                    deletions = parseInt(match[3] || '0');\n                }\n            }\n            // Get branch\n            const branch = await this.getCurrentBranch();\n            return {\n                hash,\n                message,\n                author,\n                email,\n                timestamp: new Date(parseInt(timestamp) * 1000),\n                filesChanged,\n                insertions,\n                deletions,\n                branch,\n            };\n        }\n        catch (error) {\n            console.error('Failed to get commit info:', error);\n            return null;\n        }\n    }\n    /**\n     * Capture git commit\n     */\n    async captureCommit(sessionId = 0) {\n        if (!this.isEnabled)\n            return;\n        try {\n            const commitInfo = await this.getLastCommitInfo();\n            if (!commitInfo)\n                return;\n            await this.bus.emit({\n                event_type: EventType.GIT_COMMIT,\n                actor: `git:${commitInfo.author}`,\n                aggregate_id: commitInfo.hash,\n                aggregate_type: 'git_commit',\n                payload: {\n                    hash: commitInfo.hash,\n                    message: commitInfo.message,\n                    author: commitInfo.author,\n                    email: commitInfo.email,\n                    files_changed: commitInfo.filesChanged,\n                    insertions: commitInfo.insertions,\n                    deletions: commitInfo.deletions,\n                    session_id: sessionId,\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to capture git commit:', error);\n        }\n    }\n    /**\n     * Capture git push\n     */\n    async capturePush(remote, branch, sessionId = 0) {\n        if (!this.isEnabled)\n            return;\n        try {\n            await this.bus.emit({\n                event_type: EventType.GIT_PUSH,\n                actor: 'git',\n                aggregate_id: `${remote}/${branch}`,\n                aggregate_type: 'git_push',\n                payload: {\n                    remote,\n                    branch,\n                    timestamp: Date.now(),\n                    session_id: sessionId,\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to capture git push:', error);\n        }\n    }\n    /**\n     * Capture git pull\n     */\n    async capturePull(remote, branch, sessionId = 0) {\n        if (!this.isEnabled)\n            return;\n        try {\n            await this.bus.emit({\n                event_type: EventType.GIT_PULL,\n                actor: 'git',\n                aggregate_id: `${remote}/${branch}`,\n                aggregate_type: 'git_pull',\n                payload: {\n                    remote,\n                    branch,\n                    timestamp: Date.now(),\n                    session_id: sessionId,\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to capture git pull:', error);\n        }\n    }\n    /**\n     * Capture git merge\n     */\n    async captureMerge(sourceBranch, targetBranch, sessionId = 0) {\n        if (!this.isEnabled)\n            return;\n        try {\n            await this.bus.emit({\n                event_type: EventType.GIT_MERGE,\n                actor: 'git',\n                aggregate_id: `${sourceBranch}->${targetBranch}`,\n                aggregate_type: 'git_merge',\n                payload: {\n                    source_branch: sourceBranch,\n                    target_branch: targetBranch,\n                    timestamp: Date.now(),\n                    session_id: sessionId,\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to capture git merge:', error);\n        }\n    }\n    /**\n     * Capture git checkout (branch switch)\n     */\n    async captureCheckout(branch, sessionId = 0) {\n        if (!this.isEnabled)\n            return;\n        try {\n            await this.bus.emit({\n                event_type: EventType.GIT_BRANCH_SWITCHED,\n                actor: 'git',\n                aggregate_id: branch,\n                aggregate_type: 'git_checkout',\n                payload: {\n                    branch,\n                    timestamp: Date.now(),\n                    session_id: sessionId,\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to capture git checkout:', error);\n        }\n    }\n    /**\n     * Wrapper for git commit command\n     *\n     * Use this instead of calling git commit directly to automatically\n     * capture the commit in the timeline.\n     */\n    async commit(message, options = []) {\n        const args = ['commit', '-m', message, ...options];\n        const result = await this.executeGit(args);\n        if (result.success) {\n            await this.captureCommit();\n        }\n        return result;\n    }\n    /**\n     * Wrapper for git push command\n     */\n    async push(remote = 'origin', branch, options = []) {\n        const currentBranch = branch || await this.getCurrentBranch();\n        const args = ['push', remote, currentBranch, ...options];\n        const result = await this.executeGit(args);\n        if (result.success) {\n            await this.capturePush(remote, currentBranch);\n        }\n        return result;\n    }\n    /**\n     * Wrapper for git pull command\n     */\n    async pull(remote = 'origin', branch, options = []) {\n        const currentBranch = branch || await this.getCurrentBranch();\n        const args = ['pull', remote, currentBranch, ...options];\n        const result = await this.executeGit(args);\n        if (result.success) {\n            await this.capturePull(remote, currentBranch);\n        }\n        return result;\n    }\n    /**\n     * Check if repository is clean (no uncommitted changes)\n     */\n    async isClean() {\n        const result = await this.executeGit(['status', '--porcelain']);\n        return result.success && result.stdout === '';\n    }\n    /**\n     * Get current repository status\n     */\n    async getStatus() {\n        const branch = await this.getCurrentBranch();\n        // Get ahead/behind counts\n        let ahead = 0;\n        let behind = 0;\n        const revResult = await this.executeGit(['rev-list', '--left-right', '--count', `${branch}...origin/${branch}`]);\n        if (revResult.success) {\n            const [a, b] = revResult.stdout.split('\\t').map(Number);\n            ahead = a || 0;\n            behind = b || 0;\n        }\n        // Get file counts\n        let modified = 0;\n        let added = 0;\n        let deleted = 0;\n        let untracked = 0;\n        const statusResult = await this.executeGit(['status', '--porcelain']);\n        if (statusResult.success) {\n            const lines = statusResult.stdout.split('\\n');\n            for (const line of lines) {\n                if (!line)\n                    continue;\n                const status = line.substring(0, 2);\n                if (status.includes('M'))\n                    modified++;\n                if (status.includes('A'))\n                    added++;\n                if (status.includes('D'))\n                    deleted++;\n                if (status.includes('?'))\n                    untracked++;\n            }\n        }\n        return { branch, ahead, behind, modified, added, deleted, untracked };\n    }\n    /**\n     * Enable git tracking\n     */\n    enable() {\n        this.isEnabled = true;\n    }\n    /**\n     * Disable git tracking\n     */\n    disable() {\n        this.isEnabled = false;\n    }\n    /**\n     * Check if git tracking is enabled\n     */\n    isActive() {\n        return this.isEnabled;\n    }\n}\n/**\n * Get GitHook singleton instance\n */\nexport function getGitHook(config) {\n    return GitHook.getInstance(config);\n}\n//# sourceMappingURL=git-hook.js.map"
  },
  "dist/timeline/hooks/file-hook.js": {
    "path": "dist/timeline/hooks/file-hook.js",
    "hash": "b9fbe9a2d5ff2b0d5498863ca28db1ec853a5af9e6f7263e53da367494eedc4b",
    "size": 7601,
    "timestamp": 1764704879298,
    "content": "/**\n * File Hook - Automatic File Change Tracking\n *\n * Monitors file system changes (create, modify, delete) and logs them\n * to the timeline with debouncing to avoid event spam.\n *\n * Features:\n * - Debounced event emission (configurable delay)\n * - SHA256 content hashing\n * - Automatic ignore patterns (.git, node_modules, etc.)\n * - Singleton pattern\n *\n * @module timeline/hooks/file-hook\n * @version 1.0.0\n */\nimport chokidar from 'chokidar';\nimport fs from 'fs';\nimport path from 'path';\nimport { EventBus } from '../event-bus.js';\nimport { EventType } from '../event-types.js';\nimport { getMerkleDAG } from '../storage/merkle-dag.js';\n/**\n * File Hook for monitoring file system changes\n */\nexport class FileHook {\n    static instance;\n    bus;\n    config;\n    watcher = null;\n    pendingEvents = new Map();\n    isWatching = false;\n    constructor(config = {}) {\n        this.bus = EventBus.getInstance();\n        this.config = {\n            enabled: config.enabled ?? true,\n            debounceMs: config.debounceMs ?? 500,\n            watchPaths: config.watchPaths ?? [process.cwd()],\n            ignorePatterns: config.ignorePatterns ?? [\n                '**/node_modules/**',\n                '**/.git/**',\n                '**/.grok/**',\n                '**/dist/**',\n                '**/build/**',\n                '**/*.log',\n                '**/coverage/**',\n                '**/.DS_Store',\n                '**/Thumbs.db',\n                '**/*.swp',\n                '**/*.swo',\n                '**/*~',\n            ],\n            maxFileSizeForHash: config.maxFileSizeForHash ?? 10 * 1024 * 1024, // 10 MB\n        };\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!FileHook.instance) {\n            FileHook.instance = new FileHook(config);\n        }\n        return FileHook.instance;\n    }\n    /**\n     * Start watching files\n     */\n    async startWatching() {\n        if (!this.config.enabled) {\n            return;\n        }\n        if (this.isWatching) {\n            return;\n        }\n        try {\n            this.watcher = chokidar.watch(this.config.watchPaths, {\n                ignored: this.config.ignorePatterns,\n                persistent: true,\n                ignoreInitial: true, // Don't emit events for existing files\n                awaitWriteFinish: {\n                    stabilityThreshold: 100,\n                    pollInterval: 50,\n                },\n            });\n            this.watcher.on('add', (filePath) => this.handleFileEvent(filePath, 'add'));\n            this.watcher.on('change', (filePath) => this.handleFileEvent(filePath, 'change'));\n            this.watcher.on('unlink', (filePath) => this.handleFileEvent(filePath, 'unlink'));\n            this.watcher.on('error', (error) => {\n                console.error('File watcher error:', error);\n            });\n            await new Promise((resolve) => {\n                this.watcher.on('ready', () => {\n                    this.isWatching = true;\n                    resolve();\n                });\n            });\n        }\n        catch (error) {\n            console.error('Failed to start file watcher:', error);\n            throw error;\n        }\n    }\n    /**\n     * Stop watching files\n     */\n    async stopWatching() {\n        if (!this.isWatching) {\n            return;\n        }\n        // Clear all pending debounced events\n        for (const [, event] of this.pendingEvents) {\n            clearTimeout(event.timeout);\n        }\n        this.pendingEvents.clear();\n        if (this.watcher) {\n            await this.watcher.close();\n            this.watcher = null;\n        }\n        this.isWatching = false;\n    }\n    /**\n     * Handle file system event with debouncing\n     */\n    handleFileEvent(filePath, eventType) {\n        // Cancel existing timeout for this file\n        const existing = this.pendingEvents.get(filePath);\n        if (existing) {\n            clearTimeout(existing.timeout);\n        }\n        // Create new debounced event\n        const timeout = setTimeout(() => {\n            this.emitFileEvent(filePath, eventType);\n            this.pendingEvents.delete(filePath);\n        }, this.config.debounceMs);\n        this.pendingEvents.set(filePath, {\n            filePath,\n            eventType,\n            timeout,\n        });\n    }\n    /**\n     * Emit file event to timeline\n     */\n    async emitFileEvent(filePath, eventType) {\n        try {\n            const absolutePath = path.resolve(filePath);\n            const relativePath = path.relative(process.cwd(), absolutePath);\n            // Get file stats (if file exists)\n            let size;\n            let contentHash;\n            if (eventType !== 'unlink') {\n                try {\n                    const stats = fs.statSync(absolutePath);\n                    size = stats.size;\n                    // Hash + store content in Merkle DAG only for files within size limit\n                    if (size <= this.config.maxFileSizeForHash) {\n                        contentHash = await this.hashFileContent(absolutePath);\n                    }\n                }\n                catch (error) {\n                    // File might have been deleted between event and processing\n                    console.warn(`Failed to read file ${relativePath}:`, error);\n                    return;\n                }\n            }\n            // Map event type to timeline event type\n            const timelineEventType = eventType === 'add'\n                ? EventType.FILE_CREATED\n                : eventType === 'change'\n                    ? EventType.FILE_MODIFIED\n                    : EventType.FILE_DELETED;\n            // Emit event\n            await this.bus.emit({\n                event_type: timelineEventType,\n                actor: 'system',\n                aggregate_id: relativePath,\n                aggregate_type: 'file',\n                payload: {\n                    path: relativePath,\n                    old_hash: eventType === 'change' ? 'unknown' : undefined,\n                    new_hash: contentHash,\n                    size_bytes: size,\n                    session_id: 0, // Will be populated by session context if available\n                },\n            });\n        }\n        catch (error) {\n            console.error('Failed to emit file event:', error);\n        }\n    }\n    /**\n     * Calculate SHA256 hash of file content\n     */\n    async hashFileContent(filePath) {\n        // Read full content (bounded by maxFileSizeForHash via caller)\n        const content = await fs.promises.readFile(filePath);\n        // Store blob in Merkle DAG (content-addressable storage)\n        const merkle = getMerkleDAG();\n        const result = await merkle.storeBlob(content);\n        // Return the content hash used as key in Merkle DAG\n        return result.hash;\n    }\n    /**\n     * Check if watching is active\n     */\n    isActive() {\n        return this.isWatching;\n    }\n    /**\n     * Get current configuration\n     */\n    getConfig() {\n        return { ...this.config };\n    }\n    /**\n     * Update configuration (requires restart)\n     */\n    async updateConfig(config) {\n        const wasWatching = this.isWatching;\n        if (wasWatching) {\n            await this.stopWatching();\n        }\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        if (wasWatching && this.config.enabled) {\n            await this.startWatching();\n        }\n    }\n}\n/**\n * Get FileHook singleton instance\n */\nexport function getFileHook(config) {\n    return FileHook.getInstance(config);\n}\n//# sourceMappingURL=file-hook.js.map"
  },
  "dist/timeline/hooks/tool-hook.js": {
    "path": "dist/timeline/hooks/tool-hook.js",
    "hash": "9158ef0501997c3641fc618c37534a24b71bc94aba9f08de5474a22fe203bf1f",
    "size": 6468,
    "timestamp": 1764704879298,
    "content": "/**\n * Tool Hook - Automatic Event Capture for Tool Calls\n *\n * Captures all tool executions (calls, results, errors, permissions)\n * and logs them to timeline.db.\n *\n * Integration point:\n * - ConfirmationService.executeWithConfirmation()\n * - Tool execution logic\n *\n * @module timeline/hooks/tool-hook\n * @version 1.0.0\n */\nimport { EventBus } from '../event-bus.js';\nimport { EventType } from '../event-types.js';\n/**\n * Tool Hook - Captures tool executions\n */\nexport class ToolHook {\n    static instance = null;\n    eventBus;\n    config;\n    /**\n     * Private constructor (Singleton)\n     */\n    constructor(config = {}) {\n        this.eventBus = EventBus.getInstance();\n        this.config = {\n            enabled: config.enabled !== false,\n            capturePermissions: config.capturePermissions !== false,\n            maxResultLength: config.maxResultLength || 10000,\n        };\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!ToolHook.instance) {\n            ToolHook.instance = new ToolHook(config);\n        }\n        return ToolHook.instance;\n    }\n    /**\n     * Enable/disable hook\n     */\n    setEnabled(enabled) {\n        this.config.enabled = enabled;\n    }\n    /**\n     * Check if hook is enabled\n     */\n    isEnabled() {\n        return this.config.enabled;\n    }\n    /**\n     * Capture tool call started\n     *\n     * @param toolName - Tool name\n     * @param args - Tool arguments\n     * @param sessionId - Current session ID\n     * @returns Event ID for causation tracking\n     */\n    async captureToolCallStarted(toolName, args, sessionId) {\n        if (!this.config.enabled)\n            return '';\n        const payload = {\n            tool_name: toolName,\n            arguments: args,\n            session_id: sessionId,\n        };\n        const result = await this.eventBus.emit({\n            event_type: EventType.TOOL_CALL_STARTED,\n            actor: `tool:${toolName}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n        return result.event_id;\n    }\n    /**\n     * Capture tool call success\n     *\n     * @param toolName - Tool name\n     * @param args - Tool arguments\n     * @param result - Tool result\n     * @param sessionId - Current session ID\n     * @param durationMs - Execution duration\n     * @param causationId - Parent event ID (from captureToolCallStarted)\n     */\n    async captureToolCallSuccess(toolName, args, result, sessionId, durationMs, causationId) {\n        if (!this.config.enabled)\n            return;\n        // Truncate result if too long\n        let resultToLog = result;\n        if (typeof result === 'string' && result.length > this.config.maxResultLength) {\n            resultToLog = result.substring(0, this.config.maxResultLength) + '... (truncated)';\n        }\n        const payload = {\n            tool_name: toolName,\n            arguments: args,\n            result: resultToLog,\n            duration_ms: durationMs,\n            session_id: sessionId,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.TOOL_CALL_SUCCESS,\n            actor: `tool:${toolName}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n            causation_id: causationId,\n        });\n    }\n    /**\n     * Capture tool call failed\n     *\n     * @param toolName - Tool name\n     * @param args - Tool arguments\n     * @param error - Error message\n     * @param sessionId - Current session ID\n     * @param durationMs - Execution duration\n     * @param causationId - Parent event ID\n     */\n    async captureToolCallFailed(toolName, args, error, sessionId, durationMs, causationId) {\n        if (!this.config.enabled)\n            return;\n        const payload = {\n            tool_name: toolName,\n            arguments: args,\n            error,\n            duration_ms: durationMs,\n            session_id: sessionId,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.TOOL_CALL_FAILED,\n            actor: `tool:${toolName}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n            causation_id: causationId,\n        });\n    }\n    /**\n     * Capture permission requested\n     *\n     * @param toolName - Tool name\n     * @param args - Tool arguments\n     * @param sessionId - Current session ID\n     */\n    async capturePermissionRequested(toolName, args, sessionId) {\n        if (!this.config.enabled || !this.config.capturePermissions)\n            return;\n        const payload = {\n            tool_name: toolName,\n            arguments: args,\n            session_id: sessionId,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.TOOL_PERMISSION_REQUESTED,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n    }\n    /**\n     * Capture permission granted\n     *\n     * @param toolName - Tool name\n     * @param sessionId - Current session ID\n     */\n    async capturePermissionGranted(toolName, sessionId) {\n        if (!this.config.enabled || !this.config.capturePermissions)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.TOOL_PERMISSION_GRANTED,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                tool_name: toolName,\n                session_id: sessionId,\n            },\n        });\n    }\n    /**\n     * Capture permission denied\n     *\n     * @param toolName - Tool name\n     * @param sessionId - Current session ID\n     */\n    async capturePermissionDenied(toolName, sessionId) {\n        if (!this.config.enabled || !this.config.capturePermissions)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.TOOL_PERMISSION_DENIED,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                tool_name: toolName,\n                session_id: sessionId,\n            },\n        });\n    }\n}\n/**\n * Get tool hook instance (convenience)\n */\nexport function getToolHook(config) {\n    return ToolHook.getInstance(config);\n}\n/**\n * Export for use in other modules\n */\nexport default ToolHook;\n//# sourceMappingURL=tool-hook.js.map"
  },
  "dist/timeline/hooks/index.js": {
    "path": "dist/timeline/hooks/index.js",
    "hash": "04fd4576fd094b09bc8f27b0c5ea6f7607e14dd40d4b3f0e943dbaefcf768b51",
    "size": 455,
    "timestamp": 1764704879298,
    "content": "/**\n * Timeline Hooks - Automatic Event Capture\n *\n * Export all hooks for easy import.\n *\n * @module timeline/hooks\n * @version 1.0.0\n */\nexport { LLMHook, getLLMHook } from './llm-hook.js';\nexport { ToolHook, getToolHook } from './tool-hook.js';\nexport { SessionHook, getSessionHook } from './session-hook.js';\nexport { FileHook, getFileHook } from './file-hook.js';\nexport { GitHook, getGitHook } from './git-hook.js';\n//# sourceMappingURL=index.js.map"
  },
  "dist/timeline/hooks/llm-hook.js": {
    "path": "dist/timeline/hooks/llm-hook.js",
    "hash": "e87a06dec3e60c305e492bb5ef69a9566ee5a1b19a155a38da274b12aca73f63",
    "size": 6355,
    "timestamp": 1764704879298,
    "content": "/**\n * LLM Hook - Automatic Event Capture for LLM Messages\n *\n * Captures all LLM interactions (user messages, assistant responses, system messages)\n * and logs them to timeline.db.\n *\n * Integration points:\n * - GrokAgent.sendMessage() - User messages\n * - GrokAgent streaming - Assistant responses\n * - System message updates\n *\n * @module timeline/hooks/llm-hook\n * @version 1.0.0\n */\nimport { EventBus } from '../event-bus.js';\nimport { EventType } from '../event-types.js';\n/**\n * LLM Hook - Captures LLM messages\n */\nexport class LLMHook {\n    static instance = null;\n    eventBus;\n    config;\n    /**\n     * Private constructor (Singleton)\n     */\n    constructor(config = {}) {\n        this.eventBus = EventBus.getInstance();\n        this.config = {\n            enabled: config.enabled !== false,\n            captureStreaming: config.captureStreaming || false,\n            minContentLength: config.minContentLength || 0,\n        };\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!LLMHook.instance) {\n            LLMHook.instance = new LLMHook(config);\n        }\n        return LLMHook.instance;\n    }\n    /**\n     * Enable/disable hook\n     */\n    setEnabled(enabled) {\n        this.config.enabled = enabled;\n    }\n    /**\n     * Check if hook is enabled\n     */\n    isEnabled() {\n        return this.config.enabled;\n    }\n    /**\n     * Capture user message\n     *\n     * Call this when user sends a message to LLM.\n     *\n     * @param content - User message content\n     * @param sessionId - Current session ID\n     * @param model - Model name\n     * @param provider - Provider name\n     * @param tokenCount - Optional token count\n     */\n    async captureUserMessage(content, sessionId, model, provider, tokenCount) {\n        if (!this.config.enabled)\n            return;\n        if (content.length < this.config.minContentLength)\n            return;\n        const payload = {\n            role: 'user',\n            content,\n            session_id: sessionId,\n            model,\n            provider,\n            token_count: tokenCount,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.LLM_MESSAGE_USER,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n    }\n    /**\n     * Capture assistant message\n     *\n     * Call this when LLM sends a response (after streaming completes).\n     *\n     * @param content - Assistant response content\n     * @param sessionId - Current session ID\n     * @param model - Model name\n     * @param provider - Provider name\n     * @param tokenCount - Optional token count\n     */\n    async captureAssistantMessage(content, sessionId, model, provider, tokenCount) {\n        if (!this.config.enabled)\n            return;\n        if (content.length < this.config.minContentLength)\n            return;\n        const payload = {\n            role: 'assistant',\n            content,\n            session_id: sessionId,\n            model,\n            provider,\n            token_count: tokenCount,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.LLM_MESSAGE_ASSISTANT,\n            actor: `llm:${model}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n    }\n    /**\n     * Capture system message\n     *\n     * Call this when system message is set/updated.\n     *\n     * @param content - System message content\n     * @param sessionId - Current session ID\n     * @param model - Model name\n     * @param provider - Provider name\n     */\n    async captureSystemMessage(content, sessionId, model, provider) {\n        if (!this.config.enabled)\n            return;\n        const payload = {\n            role: 'system',\n            content,\n            session_id: sessionId,\n            model,\n            provider,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.LLM_MESSAGE_SYSTEM,\n            actor: 'system',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n    }\n    /**\n     * Capture streaming start\n     *\n     * Optional: Call when streaming starts (if captureStreaming enabled).\n     */\n    async captureStreamingStart(sessionId, model, provider) {\n        if (!this.config.enabled || !this.config.captureStreaming)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.LLM_STREAMING_START,\n            actor: `llm:${model}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                model,\n                provider,\n            },\n        });\n    }\n    /**\n     * Capture streaming end\n     *\n     * Optional: Call when streaming completes (if captureStreaming enabled).\n     */\n    async captureStreamingEnd(sessionId, model, provider, totalTokens) {\n        if (!this.config.enabled || !this.config.captureStreaming)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.LLM_STREAMING_END,\n            actor: `llm:${model}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                model,\n                provider,\n                token_count: totalTokens,\n            },\n        });\n    }\n    /**\n     * Capture LLM error\n     *\n     * Call this when LLM request fails.\n     */\n    async captureError(error, sessionId, model, provider) {\n        if (!this.config.enabled)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.LLM_ERROR,\n            actor: `llm:${model}`,\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                model,\n                provider,\n                error: error.message,\n                stack: error.stack,\n            },\n        });\n    }\n}\n/**\n * Get LLM hook instance (convenience)\n */\nexport function getLLMHook(config) {\n    return LLMHook.getInstance(config);\n}\n/**\n * Export for use in other modules\n */\nexport default LLMHook;\n//# sourceMappingURL=llm-hook.js.map"
  },
  "dist/timeline/hooks/session-hook.js": {
    "path": "dist/timeline/hooks/session-hook.js",
    "hash": "e2bb638c0ba11806443715f414e1b828c1942168592aacfee756bf04bfe717b7",
    "size": 5122,
    "timestamp": 1764704879298,
    "content": "/**\n * Session Hook - Automatic Event Capture for Session Lifecycle\n *\n * Captures all session lifecycle events (create, switch, rename, close)\n * and logs them to timeline.db.\n *\n * Integration points:\n * - SessionManager.initSession()\n * - SessionManager.switchSession()\n * - SessionManager.renameSession()\n * - Application shutdown\n *\n * @module timeline/hooks/session-hook\n * @version 1.0.0\n */\nimport { EventBus } from '../event-bus.js';\nimport { EventType } from '../event-types.js';\n/**\n * Session Hook - Captures session lifecycle\n */\nexport class SessionHook {\n    static instance = null;\n    eventBus;\n    config;\n    /**\n     * Private constructor (Singleton)\n     */\n    constructor(config = {}) {\n        this.eventBus = EventBus.getInstance();\n        this.config = {\n            enabled: config.enabled !== false,\n        };\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!SessionHook.instance) {\n            SessionHook.instance = new SessionHook(config);\n        }\n        return SessionHook.instance;\n    }\n    /**\n     * Enable/disable hook\n     */\n    setEnabled(enabled) {\n        this.config.enabled = enabled;\n    }\n    /**\n     * Check if hook is enabled\n     */\n    isEnabled() {\n        return this.config.enabled;\n    }\n    /**\n     * Capture session created\n     *\n     * @param sessionId - New session ID\n     * @param sessionName - Session name\n     * @param workingDir - Working directory\n     * @param model - Initial model\n     * @param provider - Initial provider\n     */\n    async captureSessionCreated(sessionId, sessionName, workingDir, model, provider) {\n        if (!this.config.enabled)\n            return;\n        const payload = {\n            session_id: sessionId,\n            session_name: sessionName,\n            working_dir: workingDir,\n            model,\n            provider,\n        };\n        await this.eventBus.emit({\n            event_type: EventType.SESSION_CREATED,\n            actor: 'system',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload,\n        });\n    }\n    /**\n     * Capture session switched\n     *\n     * @param fromSessionId - Previous session ID\n     * @param toSessionId - New session ID\n     * @param toWorkingDir - New working directory\n     */\n    async captureSessionSwitched(fromSessionId, toSessionId, toWorkingDir) {\n        if (!this.config.enabled)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.SESSION_SWITCHED,\n            actor: 'user',\n            aggregate_id: toSessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                from_session_id: fromSessionId,\n                to_session_id: toSessionId,\n                to_working_dir: toWorkingDir,\n            },\n        });\n    }\n    /**\n     * Capture session renamed\n     *\n     * @param sessionId - Session ID\n     * @param oldName - Old session name\n     * @param newName - New session name\n     */\n    async captureSessionRenamed(sessionId, oldName, newName) {\n        if (!this.config.enabled)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.SESSION_RENAMED,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                old_name: oldName,\n                new_name: newName,\n            },\n        });\n    }\n    /**\n     * Capture session closed\n     *\n     * @param sessionId - Session ID\n     * @param reason - Close reason (optional)\n     */\n    async captureSessionClosed(sessionId, reason) {\n        if (!this.config.enabled)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.SESSION_CLOSED,\n            actor: 'user',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                reason,\n            },\n        });\n    }\n    /**\n     * Capture session restored (from rewind)\n     *\n     * @param sessionId - Session ID\n     * @param fromTimestamp - Rewind target timestamp\n     * @param outputDir - Restored output directory\n     */\n    async captureSessionRestored(sessionId, fromTimestamp, outputDir) {\n        if (!this.config.enabled)\n            return;\n        await this.eventBus.emit({\n            event_type: EventType.SESSION_RESTORED,\n            actor: 'system',\n            aggregate_id: sessionId.toString(),\n            aggregate_type: 'session',\n            payload: {\n                session_id: sessionId,\n                from_timestamp: fromTimestamp,\n                output_dir: outputDir,\n                timestamp_human: new Date(fromTimestamp / 1000).toISOString(),\n            },\n        });\n    }\n}\n/**\n * Get session hook instance (convenience)\n */\nexport function getSessionHook(config) {\n    return SessionHook.getInstance(config);\n}\n/**\n * Export for use in other modules\n */\nexport default SessionHook;\n//# sourceMappingURL=session-hook.js.map"
  },
  "dist/timeline/query-engine.js": {
    "path": "dist/timeline/query-engine.js",
    "hash": "37aded30189546d95c9b00455a63c74356450c7d340f83dfb017102ca0fcf7ad",
    "size": 10748,
    "timestamp": 1764704879298,
    "content": "/**\n * Query Engine - Timeline Event Querying\n *\n * Provides powerful query capabilities over the timeline event log.\n * Supports filtering by time range, event type, actor, aggregate, etc.\n *\n * Features:\n * - Time range queries\n * - Event type filtering\n * - Actor/aggregate filtering\n * - Pagination support\n * - Aggregation queries\n * - Causation chain traversal\n *\n * @module timeline/query-engine\n * @version 1.0.0\n */\nimport { TimelineDatabase } from './database.js';\nimport { EventType, EventCategory, isEventInCategory } from './event-types.js';\n/**\n * Query Engine for timeline events\n */\nexport class QueryEngine {\n    static instance;\n    db;\n    constructor() {\n        this.db = TimelineDatabase.getInstance();\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!QueryEngine.instance) {\n            QueryEngine.instance = new QueryEngine();\n        }\n        return QueryEngine.instance;\n    }\n    /**\n     * Query events with filters\n     */\n    query(filter = {}) {\n        const { startTime, endTime, eventTypes, categories, actor, aggregateId, aggregateType, sessionId, limit = 100, offset = 0, order = 'asc', } = filter;\n        // Build WHERE clauses\n        const whereClauses = [];\n        const params = [];\n        if (startTime !== undefined) {\n            whereClauses.push('timestamp >= ?');\n            params.push(startTime);\n        }\n        if (endTime !== undefined) {\n            whereClauses.push('timestamp <= ?');\n            params.push(endTime);\n        }\n        if (eventTypes && eventTypes.length > 0) {\n            whereClauses.push(`event_type IN (${eventTypes.map(() => '?').join(', ')})`);\n            params.push(...eventTypes);\n        }\n        if (categories && categories.length > 0) {\n            // Get all event types in these categories\n            const categoryEventTypes = new Set();\n            for (const category of categories) {\n                const types = this.getEventTypesInCategory(category);\n                types.forEach(t => categoryEventTypes.add(t));\n            }\n            if (categoryEventTypes.size > 0) {\n                const types = Array.from(categoryEventTypes);\n                whereClauses.push(`event_type IN (${types.map(() => '?').join(', ')})`);\n                params.push(...types);\n            }\n        }\n        if (actor) {\n            whereClauses.push('actor = ?');\n            params.push(actor);\n        }\n        if (aggregateId) {\n            whereClauses.push('aggregate_id = ?');\n            params.push(aggregateId);\n        }\n        if (aggregateType) {\n            whereClauses.push('aggregate_type = ?');\n            params.push(aggregateType);\n        }\n        if (sessionId !== undefined) {\n            whereClauses.push(\"json_extract(payload, '$.session_id') = ?\");\n            params.push(sessionId);\n        }\n        const whereClause = whereClauses.length > 0\n            ? `WHERE ${whereClauses.join(' AND ')}`\n            : '';\n        // Count total matching events\n        const countSql = `SELECT COUNT(*) as count FROM timeline_events ${whereClause}`;\n        const countResult = this.db.getConnection().prepare(countSql).get(...params);\n        const total = countResult.count;\n        // Get paginated events\n        const querySql = `\n      SELECT * FROM timeline_events \n      ${whereClause}\n      ORDER BY timestamp ${order.toUpperCase()}, sequence_number ${order.toUpperCase()}\n      LIMIT ? OFFSET ?\n    `;\n        const rows = this.db.getConnection().prepare(querySql).all(...params, limit, offset);\n        const events = rows.map((row) => ({\n            id: row.id,\n            timestamp: row.timestamp,\n            sequence_number: row.sequence_number,\n            event_type: row.event_type,\n            actor: row.actor,\n            aggregate_id: row.aggregate_id,\n            aggregate_type: row.aggregate_type,\n            causation_id: row.causation_id,\n            correlation_id: row.correlation_id,\n            payload: JSON.parse(row.payload),\n        }));\n        return {\n            events,\n            total,\n            hasMore: offset + events.length < total,\n            offset,\n            limit,\n        };\n    }\n    /**\n     * Get event types in a category\n     */\n    getEventTypesInCategory(category) {\n        const types = [];\n        for (const type of Object.values(EventType)) {\n            if (isEventInCategory(type, category)) {\n                types.push(type);\n            }\n        }\n        return types;\n    }\n    /**\n     * Get event by ID\n     */\n    getEventById(id) {\n        const row = this.db.getConnection()\n            .prepare('SELECT * FROM timeline_events WHERE id = ?')\n            .get(id);\n        if (!row)\n            return null;\n        const r = row;\n        return {\n            id: r.id,\n            timestamp: r.timestamp,\n            sequence_number: r.sequence_number,\n            event_type: r.event_type,\n            actor: r.actor,\n            aggregate_id: r.aggregate_id,\n            aggregate_type: r.aggregate_type,\n            causation_id: r.causation_id,\n            correlation_id: r.correlation_id,\n            payload: JSON.parse(r.payload),\n        };\n    }\n    /**\n     * Get causation chain (all events caused by a root event)\n     */\n    getCausationChain(rootEventId) {\n        const rootEvent = this.getEventById(rootEventId);\n        if (!rootEvent)\n            return null;\n        return this.buildCausationChain(rootEvent, 0);\n    }\n    /**\n     * Build causation chain recursively\n     */\n    buildCausationChain(event, depth) {\n        // Find all events caused by this event\n        const childRows = this.db.getConnection()\n            .prepare('SELECT * FROM timeline_events WHERE causation_id = ? ORDER BY timestamp ASC')\n            .all(event.id);\n        const children = childRows.map((row) => {\n            const childEvent = {\n                id: row.id,\n                timestamp: row.timestamp,\n                sequence_number: row.sequence_number,\n                event_type: row.event_type,\n                actor: row.actor,\n                aggregate_id: row.aggregate_id,\n                aggregate_type: row.aggregate_type,\n                causation_id: row.causation_id,\n                correlation_id: row.correlation_id,\n                payload: JSON.parse(row.payload),\n            };\n            return this.buildCausationChain(childEvent, depth + 1);\n        });\n        return {\n            event,\n            depth,\n            children,\n        };\n    }\n    /**\n     * Get correlation chain (all events with the same correlation ID)\n     */\n    getCorrelationChain(correlationId) {\n        const rows = this.db.getConnection()\n            .prepare('SELECT * FROM timeline_events WHERE correlation_id = ? ORDER BY timestamp ASC')\n            .all(correlationId);\n        return rows.map((row) => ({\n            id: row.id,\n            timestamp: row.timestamp,\n            sequence_number: row.sequence_number,\n            event_type: row.event_type,\n            actor: row.actor,\n            aggregate_id: row.aggregate_id,\n            aggregate_type: row.aggregate_type,\n            causation_id: row.causation_id,\n            correlation_id: row.correlation_id,\n            payload: JSON.parse(row.payload),\n        }));\n    }\n    /**\n     * Get events for a specific session\n     */\n    getSessionEvents(sessionId, filter) {\n        return this.query({\n            ...filter,\n            sessionId,\n        });\n    }\n    /**\n     * Get events for a specific file\n     */\n    getFileEvents(filePath, filter) {\n        return this.query({\n            ...filter,\n            aggregateId: filePath,\n            aggregateType: 'file',\n        });\n    }\n    /**\n     * Get statistics about events\n     */\n    getStats(filter) {\n        const { events } = this.query({ ...filter, limit: 999999 });\n        const eventsByType = {};\n        const eventsByCategory = {};\n        const eventsByActor = {};\n        let earliest = Infinity;\n        let latest = -Infinity;\n        for (const event of events) {\n            // Count by type\n            eventsByType[event.event_type] = (eventsByType[event.event_type] || 0) + 1;\n            // Count by category\n            for (const category of Object.values(EventCategory)) {\n                if (isEventInCategory(event.event_type, category)) {\n                    const catKey = category;\n                    eventsByCategory[catKey] = (eventsByCategory[catKey] || 0) + 1;\n                }\n            }\n            // Count by actor\n            eventsByActor[event.actor] = (eventsByActor[event.actor] || 0) + 1;\n            // Track time range\n            earliest = Math.min(earliest, event.timestamp);\n            latest = Math.max(latest, event.timestamp);\n        }\n        return {\n            totalEvents: events.length,\n            eventsByType,\n            eventsByCategory,\n            eventsByActor,\n            timeRange: {\n                earliest: earliest === Infinity ? 0 : earliest,\n                latest: latest === -Infinity ? 0 : latest,\n            },\n        };\n    }\n    /**\n     * Get recent events\n     */\n    getRecentEvents(limit = 100) {\n        const { events } = this.query({ limit, order: 'desc' });\n        return events;\n    }\n    /**\n     * Search events by text in payload\n     */\n    searchPayload(searchTerm, filter) {\n        const allResults = this.query({ ...filter, limit: 999999 });\n        const searchLower = searchTerm.toLowerCase();\n        const matchingEvents = allResults.events.filter(event => {\n            const payloadStr = JSON.stringify(event.payload).toLowerCase();\n            return payloadStr.includes(searchLower);\n        });\n        const { limit = 100, offset = 0 } = filter || {};\n        const paginatedEvents = matchingEvents.slice(offset, offset + limit);\n        return {\n            events: paginatedEvents,\n            total: matchingEvents.length,\n            hasMore: offset + paginatedEvents.length < matchingEvents.length,\n            offset,\n            limit,\n        };\n    }\n    /**\n     * Get events around a specific timestamp (before + after)\n     */\n    getEventsAroundTime(timestamp, before = 10, after = 10) {\n        const beforeEvents = this.query({\n            endTime: timestamp,\n            limit: before,\n            order: 'desc',\n        }).events.reverse();\n        const afterEvents = this.query({\n            startTime: timestamp + 1,\n            limit: after,\n            order: 'asc',\n        }).events;\n        return [...beforeEvents, ...afterEvents];\n    }\n}\n/**\n * Get QueryEngine singleton instance\n */\nexport function getQueryEngine() {\n    return QueryEngine.getInstance();\n}\n//# sourceMappingURL=query-engine.js.map"
  },
  "dist/timeline/event-bus.js": {
    "path": "dist/timeline/event-bus.js",
    "hash": "007123f869dc1a1c4f404c240d5772b748350b2fe73d61ff5d69546d230fddd7",
    "size": 8023,
    "timestamp": 1764704879299,
    "content": "/**\n * Event Bus\n *\n * Central event dispatcher for the entire application.\n * ALL state mutations MUST go through this bus.\n *\n * Architecture:\n * - Event-First: Events are logged BEFORE state changes\n * - CQRS: Separates writes (timeline) from reads (conversations.db)\n * - Causality: Tracks event chains via correlation_id and causation_id\n *\n * Benefits:\n * - Single source of truth (timeline.db)\n * - Complete audit trail\n * - Time travel capability\n * - No synchronization issues\n *\n * @module timeline/event-bus\n * @version 1.0.0\n */\nimport crypto from 'crypto';\nimport { TimelineLogger } from './timeline-logger.js';\n/**\n * Event Bus\n *\n * Singleton pattern for consistent event dispatching.\n */\nexport class EventBus {\n    static instance = null;\n    logger;\n    listeners = new Map();\n    globalListeners = [];\n    options;\n    /**\n     * Private constructor (Singleton)\n     */\n    constructor(options = {}) {\n        this.logger = TimelineLogger.getInstance();\n        this.options = {\n            enableLogging: options.enableLogging !== false,\n            enableProjections: options.enableProjections !== false,\n        };\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(options) {\n        if (!EventBus.instance) {\n            EventBus.instance = new EventBus(options);\n        }\n        return EventBus.instance;\n    }\n    /**\n     * Emit an event\n     *\n     * This is the MAIN entry point for all state changes.\n     *\n     * Flow:\n     * 1. Log to timeline.db (immutable)\n     * 2. Notify listeners (projections, UI updates, etc.)\n     * 3. Return event ID for causality tracking\n     *\n     * @param input - Event data\n     * @returns LogResult with event ID\n     */\n    async emit(input) {\n        try {\n            // 1. Log to timeline (immutable source of truth)\n            let logResult = {\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n            };\n            if (this.options.enableLogging) {\n                logResult = await this.logger.log(input);\n                if (!logResult.success) {\n                    console.error(`‚ùå Failed to log event ${input.event_type}:`, logResult.error);\n                    return logResult;\n                }\n            }\n            // 2. Construct full event object\n            const fullEvent = {\n                id: logResult.event_id,\n                timestamp: Date.now() * 1000,\n                sequence_number: logResult.sequence_number,\n                actor: input.actor,\n                event_type: input.event_type,\n                aggregate_id: input.aggregate_id,\n                aggregate_type: input.aggregate_type,\n                payload: input.payload,\n                correlation_id: input.correlation_id,\n                causation_id: input.causation_id,\n                metadata: input.metadata,\n                checksum: crypto.createHash('sha256').update(JSON.stringify(input.payload)).digest('hex'),\n            };\n            // 3. Notify listeners (async, non-blocking)\n            this.notifyListeners(fullEvent);\n            return logResult;\n        }\n        catch (error) {\n            console.error('‚ùå EventBus.emit failed:', error);\n            return {\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: error.message,\n            };\n        }\n    }\n    /**\n     * Emit multiple events atomically (transaction)\n     *\n     * All events succeed or all fail together.\n     */\n    async emitBatch(inputs) {\n        if (this.options.enableLogging) {\n            const results = await this.logger.logBatch(inputs);\n            // Notify listeners for each successful event\n            for (let i = 0; i < results.length; i++) {\n                if (results[i].success) {\n                    const fullEvent = {\n                        id: results[i].event_id,\n                        timestamp: Date.now() * 1000,\n                        sequence_number: results[i].sequence_number,\n                        actor: inputs[i].actor,\n                        event_type: inputs[i].event_type,\n                        aggregate_id: inputs[i].aggregate_id,\n                        aggregate_type: inputs[i].aggregate_type,\n                        payload: inputs[i].payload,\n                        correlation_id: inputs[i].correlation_id,\n                        causation_id: inputs[i].causation_id,\n                        metadata: inputs[i].metadata,\n                        checksum: crypto.createHash('sha256').update(JSON.stringify(inputs[i].payload)).digest('hex'),\n                    };\n                    this.notifyListeners(fullEvent);\n                }\n            }\n            return results;\n        }\n        return inputs.map(() => ({\n            success: false,\n            event_id: '',\n            sequence_number: 0,\n            error: 'Timeline logging is disabled'\n        }));\n    }\n    /**\n     * Subscribe to specific event type\n     *\n     * @param eventType - Event type to listen for\n     * @param listener - Callback function\n     */\n    on(eventType, listener) {\n        if (!this.listeners.has(eventType)) {\n            this.listeners.set(eventType, []);\n        }\n        this.listeners.get(eventType).push(listener);\n    }\n    /**\n     * Subscribe to all events\n     *\n     * @param listener - Callback function\n     */\n    onAny(listener) {\n        this.globalListeners.push(listener);\n    }\n    /**\n     * Unsubscribe from event type\n     *\n     * @param eventType - Event type\n     * @param listener - Callback to remove\n     */\n    off(eventType, listener) {\n        const listeners = this.listeners.get(eventType);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Unsubscribe from all events\n     *\n     * @param listener - Callback to remove\n     */\n    offAny(listener) {\n        const index = this.globalListeners.indexOf(listener);\n        if (index !== -1) {\n            this.globalListeners.splice(index, 1);\n        }\n    }\n    /**\n     * Notify all listeners (async, non-blocking)\n     *\n     * @private\n     */\n    notifyListeners(event) {\n        // Notify type-specific listeners\n        const typeListeners = this.listeners.get(event.event_type) || [];\n        for (const listener of typeListeners) {\n            setImmediate(() => {\n                try {\n                    listener(event);\n                }\n                catch (error) {\n                    console.error(`‚ùå Event listener error (${event.event_type}):`, error);\n                }\n            });\n        }\n        // Notify global listeners\n        for (const listener of this.globalListeners) {\n            setImmediate(() => {\n                try {\n                    listener(event);\n                }\n                catch (error) {\n                    console.error('‚ùå Global event listener error:', error);\n                }\n            });\n        }\n    }\n    /**\n     * Generate correlation ID for transaction tracking\n     *\n     * Use this when multiple related events form a logical transaction.\n     * Example: Tool call ‚Üí File modifications ‚Üí Git commit\n     */\n    generateCorrelationId() {\n        return crypto.randomUUID();\n    }\n    /**\n     * Get event bus statistics\n     */\n    getStats() {\n        let totalListeners = 0;\n        for (const listeners of this.listeners.values()) {\n            totalListeners += listeners.length;\n        }\n        return {\n            listeners_count: totalListeners,\n            global_listeners_count: this.globalListeners.length,\n            event_types_subscribed: this.listeners.size,\n        };\n    }\n}\n/**\n * Get event bus instance (convenience)\n */\nexport function getEventBus(options) {\n    return EventBus.getInstance(options);\n}\n/**\n * Export for use in other modules\n */\nexport default EventBus;\n//# sourceMappingURL=event-bus.js.map"
  },
  "dist/timeline/timeline-logger.js": {
    "path": "dist/timeline/timeline-logger.js",
    "hash": "f92dc4a04e9d280db9a29c987aec4cb7a517d9ae702832d2bc1e0c49e753e069",
    "size": 8907,
    "timestamp": 1764704879299,
    "content": "/**\n * Timeline Logger\n *\n * Core component for logging events to timeline.db.\n * Ensures immutability, cryptographic integrity, and strict ordering.\n *\n * Features:\n * - Atomic writes (SQLite transaction)\n * - Automatic sequence numbering\n * - SHA256 checksums for tamper detection\n * - Correlation and causation tracking\n * - Thread-safe via SQLite BEGIN IMMEDIATE\n *\n * @module timeline/timeline-logger\n * @version 1.0.0\n */\nimport crypto from 'crypto';\nimport { TimelineDatabase } from './database.js';\n/**\n * Timeline Logger\n *\n * Singleton pattern for consistent logging across the application.\n */\nexport class TimelineLogger {\n    static instance = null;\n    db;\n    enabled = true;\n    insertStmt; // Prepared statement for performance\n    /**\n     * Private constructor (Singleton)\n     */\n    constructor() {\n        this.db = TimelineDatabase.getInstance();\n        // Prepare INSERT statement for performance\n        const conn = this.db.getConnection();\n        this.insertStmt = conn.prepare(`\n      INSERT INTO events (\n        id, timestamp, sequence_number, actor, event_type,\n        aggregate_id, aggregate_type, payload,\n        correlation_id, causation_id, metadata, checksum\n      ) VALUES (\n        ?, ?, ?, ?, ?,\n        ?, ?, ?,\n        ?, ?, ?, ?\n      )\n    `);\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!TimelineLogger.instance) {\n            TimelineLogger.instance = new TimelineLogger();\n        }\n        return TimelineLogger.instance;\n    }\n    /**\n     * Enable/disable logging\n     *\n     * Useful for debugging or temporary disable.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        console.log(`üïê Timeline logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    /**\n     * Check if logging is enabled\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Log an event to timeline\n     *\n     * @param input - Event data (without generated fields)\n     * @returns LogResult with event ID and sequence number\n     */\n    async log(input) {\n        if (!this.enabled) {\n            return {\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: 'Timeline logging is disabled'\n            };\n        }\n        try {\n            // Generate event ID\n            const eventId = crypto.randomUUID();\n            // Get current timestamp (microseconds)\n            const timestamp = Date.now() * 1000;\n            // Get next sequence number (thread-safe)\n            const sequence = this.db.getNextSequence();\n            // Serialize payload\n            const payloadJson = JSON.stringify(input.payload);\n            // Calculate checksum\n            const checksum = crypto\n                .createHash('sha256')\n                .update(payloadJson)\n                .digest('hex');\n            // Serialize metadata\n            const metadataJson = input.metadata ? JSON.stringify(input.metadata) : null;\n            // Insert event (atomic)\n            this.insertStmt.run(eventId, timestamp, sequence, input.actor, input.event_type, input.aggregate_id || null, input.aggregate_type || null, payloadJson, input.correlation_id || null, input.causation_id || null, metadataJson, checksum);\n            return {\n                success: true,\n                event_id: eventId,\n                sequence_number: sequence,\n            };\n        }\n        catch (error) {\n            console.error('‚ùå Timeline logging failed:', error);\n            return {\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: error.message,\n            };\n        }\n    }\n    /**\n     * Log multiple events atomically (transaction)\n     *\n     * All events succeed or all fail together.\n     */\n    async logBatch(inputs) {\n        if (!this.enabled) {\n            return inputs.map(() => ({\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: 'Timeline logging is disabled'\n            }));\n        }\n        const conn = this.db.getConnection();\n        const results = [];\n        // Begin transaction\n        const transaction = conn.transaction((events) => {\n            for (const input of events) {\n                const result = this.logSync(input); // Synchronous version\n                results.push(result);\n            }\n        });\n        try {\n            transaction(inputs);\n            return results;\n        }\n        catch (error) {\n            console.error('‚ùå Timeline batch logging failed:', error);\n            return inputs.map(() => ({\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: error.message\n            }));\n        }\n    }\n    /**\n     * Synchronous version of log() for use in transactions\n     *\n     * @private\n     */\n    logSync(input) {\n        try {\n            const eventId = crypto.randomUUID();\n            const timestamp = Date.now() * 1000;\n            const sequence = this.db.getNextSequence();\n            const payloadJson = JSON.stringify(input.payload);\n            const checksum = crypto.createHash('sha256').update(payloadJson).digest('hex');\n            const metadataJson = input.metadata ? JSON.stringify(input.metadata) : null;\n            this.insertStmt.run(eventId, timestamp, sequence, input.actor, input.event_type, input.aggregate_id || null, input.aggregate_type || null, payloadJson, input.correlation_id || null, input.causation_id || null, metadataJson, checksum);\n            return {\n                success: true,\n                event_id: eventId,\n                sequence_number: sequence,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                event_id: '',\n                sequence_number: 0,\n                error: error.message,\n            };\n        }\n    }\n    /**\n     * Verify event integrity (checksum validation)\n     *\n     * @param eventId - Event ID to verify\n     * @returns True if checksum is valid\n     */\n    verifyEvent(eventId) {\n        try {\n            const conn = this.db.getConnection();\n            const event = conn.prepare('SELECT payload, checksum FROM events WHERE id = ?').get(eventId);\n            if (!event) {\n                return false;\n            }\n            const expectedChecksum = crypto\n                .createHash('sha256')\n                .update(event.payload)\n                .digest('hex');\n            return event.checksum === expectedChecksum;\n        }\n        catch (error) {\n            console.error('‚ùå Event verification failed:', error);\n            return false;\n        }\n    }\n    /**\n     * Verify integrity of all events in database\n     *\n     * @returns Object with stats\n     */\n    verifyAllEvents() {\n        const conn = this.db.getConnection();\n        const events = conn.prepare('SELECT id, payload, checksum FROM events').all();\n        let valid = 0;\n        let invalid = 0;\n        const invalidIds = [];\n        for (const event of events) {\n            const expectedChecksum = crypto\n                .createHash('sha256')\n                .update(event.payload)\n                .digest('hex');\n            if (event.checksum === expectedChecksum) {\n                valid++;\n            }\n            else {\n                invalid++;\n                invalidIds.push(event.id);\n            }\n        }\n        return {\n            total: events.length,\n            valid,\n            invalid,\n            invalid_ids: invalidIds,\n        };\n    }\n    /**\n     * Get last N events\n     */\n    getLastEvents(limit = 10) {\n        const conn = this.db.getConnection();\n        const stmt = conn.prepare(`\n      SELECT * FROM events\n      ORDER BY sequence_number DESC\n      LIMIT ?\n    `);\n        const rows = stmt.all(limit);\n        return rows.map(row => this.rowToEvent(row));\n    }\n    /**\n     * Convert database row to Event object\n     *\n     * @private\n     */\n    rowToEvent(row) {\n        return {\n            id: row.id,\n            timestamp: row.timestamp,\n            sequence_number: row.sequence_number,\n            actor: row.actor,\n            event_type: row.event_type,\n            aggregate_id: row.aggregate_id,\n            aggregate_type: row.aggregate_type,\n            payload: JSON.parse(row.payload),\n            correlation_id: row.correlation_id,\n            causation_id: row.causation_id,\n            metadata: row.metadata ? JSON.parse(row.metadata) : null,\n            checksum: row.checksum,\n        };\n    }\n}\n/**\n * Get timeline logger instance (convenience)\n */\nexport function getTimelineLogger() {\n    return TimelineLogger.getInstance();\n}\n/**\n * Export for use in other modules\n */\nexport default TimelineLogger;\n//# sourceMappingURL=timeline-logger.js.map"
  },
  "dist/timeline/schema.js": {
    "path": "dist/timeline/schema.js",
    "hash": "4a2bccd1fe4bb764af7822a32881536070b28b809c1a5215ba4a43fd7a62668b",
    "size": 5609,
    "timestamp": 1764704879299,
    "content": "/**\n * Timeline Database Schema (Embedded)\n *\n * @module timeline/schema\n * @version 1.0.0\n */\nexport const TIMELINE_SCHEMA = `\n-- ============================================================================\n-- TIMELINE.DB - Event Sourcing Schema\n-- ============================================================================\n\nCREATE TABLE IF NOT EXISTS events (\n    id TEXT PRIMARY KEY,\n    timestamp INTEGER NOT NULL,\n    sequence_number INTEGER NOT NULL UNIQUE,\n    actor TEXT NOT NULL,\n    event_type TEXT NOT NULL,\n    aggregate_id TEXT,\n    aggregate_type TEXT,\n    payload TEXT NOT NULL,\n    correlation_id TEXT,\n    causation_id TEXT,\n    metadata TEXT,\n    checksum TEXT NOT NULL,\n    CHECK (length(checksum) = 64),\n    CHECK (timestamp > 0),\n    CHECK (sequence_number > 0)\n);\n\nCREATE INDEX IF NOT EXISTS idx_events_sequence ON events (sequence_number);\nCREATE INDEX IF NOT EXISTS idx_events_timestamp ON events (timestamp);\nCREATE INDEX IF NOT EXISTS idx_events_type ON events (event_type);\nCREATE INDEX IF NOT EXISTS idx_events_aggregate ON events (aggregate_id, aggregate_type);\nCREATE INDEX IF NOT EXISTS idx_events_correlation ON events (correlation_id);\nCREATE INDEX IF NOT EXISTS idx_events_actor ON events (actor);\n\n-- Convenience view for querying events (used by QueryEngine)\nCREATE VIEW IF NOT EXISTS timeline_events AS\nSELECT\n    id,\n    timestamp,\n    sequence_number,\n    actor,\n    event_type,\n    aggregate_id,\n    aggregate_type,\n    payload,\n    correlation_id,\n    causation_id,\n    metadata,\n    checksum\nFROM events;\n\nCREATE TABLE IF NOT EXISTS snapshots (\n    id TEXT PRIMARY KEY,\n    timestamp INTEGER NOT NULL,\n    sequence_number INTEGER NOT NULL,\n    event_count INTEGER NOT NULL,\n    session_id INTEGER,\n    session_name TEXT,\n    working_dir TEXT NOT NULL,\n    git_commit_hash TEXT,\n    git_branch TEXT,\n    file_count INTEGER NOT NULL,\n    compressed_size_bytes INTEGER NOT NULL,\n    uncompressed_size_bytes INTEGER NOT NULL,\n    snapshot_data BLOB NOT NULL,\n    created_at INTEGER NOT NULL,\n    CHECK (timestamp > 0),\n    CHECK (sequence_number > 0),\n    CHECK (event_count >= 0),\n    CHECK (file_count >= 0),\n    CHECK (compressed_size_bytes >= 0),\n    CHECK (uncompressed_size_bytes >= 0)\n);\n\nCREATE INDEX IF NOT EXISTS idx_snapshots_sequence ON snapshots (sequence_number DESC);\nCREATE INDEX IF NOT EXISTS idx_snapshots_timestamp ON snapshots (timestamp DESC);\nCREATE INDEX IF NOT EXISTS idx_snapshots_created ON snapshots (created_at DESC);\n\nCREATE TABLE IF NOT EXISTS file_blobs (\n    hash TEXT PRIMARY KEY,\n    content BLOB NOT NULL,\n    is_delta INTEGER DEFAULT 0,\n    base_hash TEXT,\n    size INTEGER NOT NULL,\n    compressed_size INTEGER NOT NULL,\n    created_at INTEGER NOT NULL,\n    CHECK (length(hash) = 64),\n    CHECK (size >= 0),\n    CHECK (compressed_size >= 0),\n    CHECK (is_delta IN (0, 1)),\n    CHECK (is_delta = 0 OR base_hash IS NOT NULL),\n    FOREIGN KEY (base_hash) REFERENCES file_blobs(hash) ON DELETE SET NULL\n);\n\nCREATE INDEX IF NOT EXISTS idx_file_blobs_created ON file_blobs (created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_file_blobs_base ON file_blobs (base_hash);\n\nCREATE TABLE IF NOT EXISTS file_trees (\n    hash TEXT PRIMARY KEY,\n    tree_json TEXT NOT NULL,\n    parent_hash TEXT,\n    timestamp INTEGER NOT NULL,\n    total_files INTEGER DEFAULT 0,\n    CHECK (length(hash) = 64),\n    CHECK (timestamp > 0),\n    CHECK (total_files >= 0),\n    FOREIGN KEY (parent_hash) REFERENCES file_trees(hash) ON DELETE SET NULL\n);\n\nCREATE INDEX IF NOT EXISTS idx_file_trees_timestamp ON file_trees (timestamp DESC);\nCREATE INDEX IF NOT EXISTS idx_file_trees_parent ON file_trees (parent_hash);\n\nCREATE TABLE IF NOT EXISTS rewind_cache (\n    target_timestamp INTEGER PRIMARY KEY,\n    snapshot_sequence INTEGER NOT NULL,\n    tree_hash TEXT NOT NULL,\n    state_json TEXT NOT NULL,\n    created_at INTEGER NOT NULL,\n    hit_count INTEGER DEFAULT 0,\n    CHECK (target_timestamp > 0),\n    CHECK (created_at > 0),\n    CHECK (hit_count >= 0),\n    FOREIGN KEY (tree_hash) REFERENCES file_trees(hash) ON DELETE CASCADE\n);\n\nCREATE INDEX IF NOT EXISTS idx_rewind_cache_created ON rewind_cache (created_at DESC);\n\nCREATE TABLE IF NOT EXISTS metadata (\n    key TEXT PRIMARY KEY,\n    value TEXT NOT NULL,\n    updated_at INTEGER NOT NULL\n);\n\n-- Insert metadata only if keys don't exist (idempotent)\n-- Using INSERT OR IGNORE to preserve existing values (e.g., last_sequence)\nINSERT OR IGNORE INTO metadata (key, value, updated_at) VALUES\n    ('schema_version', '1.0.0', strftime('%s', 'now') * 1000000),\n    ('created_at', strftime('%s', 'now') * 1000000, strftime('%s', 'now') * 1000000),\n    ('last_sequence', '0', strftime('%s', 'now') * 1000000),\n    ('last_snapshot_sequence', '0', strftime('%s', 'now') * 1000000);\n\n-- Update schema_version separately (can be updated on schema changes)\nUPDATE metadata \nSET value = '1.0.0', updated_at = strftime('%s', 'now') * 1000000\nWHERE key = 'schema_version';\n\nCREATE VIEW IF NOT EXISTS v_recent_events AS\nSELECT \n    id,\n    datetime(timestamp / 1000000, 'unixepoch') as timestamp_human,\n    sequence_number,\n    actor,\n    event_type,\n    aggregate_id,\n    aggregate_type\nFROM events\nORDER BY sequence_number DESC\nLIMIT 100;\n\nCREATE VIEW IF NOT EXISTS v_event_stats AS\nSELECT \n    event_type,\n    COUNT(*) as count,\n    MIN(timestamp) as first_seen,\n    MAX(timestamp) as last_seen,\n    datetime(MIN(timestamp) / 1000000, 'unixepoch') as first_seen_human,\n    datetime(MAX(timestamp) / 1000000, 'unixepoch') as last_seen_human\nFROM events\nGROUP BY event_type\nORDER BY count DESC;\n`;\n//# sourceMappingURL=schema.js.map"
  },
  "dist/timeline/storage/merkle-dag.js": {
    "path": "dist/timeline/storage/merkle-dag.js",
    "hash": "b68d269f32372efc48e0c91da2c69071cbd9b03d336444f3fa5d590b614fe7b4",
    "size": 6337,
    "timestamp": 1764704879299,
    "content": "/**\n * Merkle DAG (Directed Acyclic Graph) Storage\n *\n * Content-addressable storage for file blobs using SHA256 hashing.\n * Inspired by Git's object storage model.\n *\n * Features:\n * - Content deduplication via SHA256 hashing\n * - Delta compression (like Git pack files)\n * - zlib compression for storage efficiency\n * - Immutable blob storage\n *\n * @module timeline/storage/merkle-dag\n * @version 1.0.0\n */\nimport crypto from 'crypto';\nimport zlib from 'zlib';\nimport { promisify } from 'util';\nimport { TimelineDatabase } from '../database.js';\nconst gzip = promisify(zlib.gzip);\nconst gunzip = promisify(zlib.gunzip);\n/**\n * Merkle DAG Storage Manager\n */\nexport class MerkleDAG {\n    static instance;\n    db;\n    constructor() {\n        this.db = TimelineDatabase.getInstance();\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!MerkleDAG.instance) {\n            MerkleDAG.instance = new MerkleDAG();\n        }\n        return MerkleDAG.instance;\n    }\n    /**\n     * Store a file blob (full content)\n     *\n     * @param content - File content\n     * @returns Storage result with hash\n     */\n    async storeBlob(content) {\n        const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content, 'utf-8');\n        // Calculate hash\n        const hash = crypto.createHash('sha256').update(buffer).digest('hex');\n        // Check if blob already exists (deduplication)\n        const existing = this.getBlobInfo(hash);\n        if (existing) {\n            return existing;\n        }\n        // Compress content\n        const compressed = await gzip(buffer);\n        // Store in database\n        const stmt = this.db.getConnection().prepare(`\n      INSERT INTO file_blobs (hash, content, is_delta, base_hash, size, compressed_size, created_at)\n      VALUES (?, ?, 0, NULL, ?, ?, ?)\n    `);\n        stmt.run(hash, compressed, buffer.length, compressed.length, Date.now() * 1000 // microseconds\n        );\n        return {\n            hash,\n            size: buffer.length,\n            compressedSize: compressed.length,\n            isDelta: false,\n        };\n    }\n    /**\n     * Store a delta blob (compressed diff)\n     *\n     * @param deltaContent - Delta patch content\n     * @param baseHash - Hash of the base version\n     * @returns Storage result with hash\n     */\n    async storeDelta(deltaContent, baseHash) {\n        const buffer = Buffer.isBuffer(deltaContent) ? deltaContent : Buffer.from(deltaContent, 'utf-8');\n        // Calculate hash of delta\n        const hash = crypto.createHash('sha256').update(buffer).digest('hex');\n        // Check if delta already exists\n        const existing = this.getBlobInfo(hash);\n        if (existing) {\n            return existing;\n        }\n        // Compress delta\n        const compressed = await gzip(buffer);\n        // Store in database\n        const stmt = this.db.getConnection().prepare(`\n      INSERT INTO file_blobs (hash, content, is_delta, base_hash, size, compressed_size, created_at)\n      VALUES (?, ?, 1, ?, ?, ?, ?)\n    `);\n        stmt.run(hash, compressed, baseHash, buffer.length, compressed.length, Date.now() * 1000);\n        return {\n            hash,\n            size: buffer.length,\n            compressedSize: compressed.length,\n            isDelta: true,\n            baseHash,\n        };\n    }\n    /**\n     * Retrieve a blob by hash\n     *\n     * @param hash - SHA256 hash of the blob\n     * @returns Blob content and metadata\n     */\n    async retrieveBlob(hash) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT hash, content, is_delta, base_hash, size\n      FROM file_blobs\n      WHERE hash = ?\n    `);\n        const row = stmt.get(hash);\n        if (!row) {\n            return null;\n        }\n        // Decompress content\n        const decompressed = await gunzip(row.content);\n        return {\n            hash: row.hash,\n            content: decompressed,\n            size: row.size,\n            isDelta: row.is_delta === 1,\n            baseHash: row.base_hash || undefined,\n        };\n    }\n    /**\n     * Get blob info without retrieving content\n     *\n     * @param hash - SHA256 hash of the blob\n     * @returns Blob metadata\n     */\n    getBlobInfo(hash) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT hash, is_delta, base_hash, size, compressed_size\n      FROM file_blobs\n      WHERE hash = ?\n    `);\n        const row = stmt.get(hash);\n        if (!row) {\n            return null;\n        }\n        return {\n            hash: row.hash,\n            size: row.size,\n            compressedSize: row.compressed_size,\n            isDelta: row.is_delta === 1,\n            baseHash: row.base_hash || undefined,\n        };\n    }\n    /**\n     * Check if a blob exists\n     *\n     * @param hash - SHA256 hash of the blob\n     * @returns True if blob exists\n     */\n    hasBlob(hash) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT 1 FROM file_blobs WHERE hash = ? LIMIT 1\n    `);\n        return stmt.get(hash) !== undefined;\n    }\n    /**\n     * Get storage statistics\n     *\n     * @returns Storage statistics\n     */\n    getStats() {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT\n        COUNT(*) as total_blobs,\n        SUM(size) as total_size,\n        SUM(compressed_size) as total_compressed_size,\n        SUM(CASE WHEN is_delta = 1 THEN 1 ELSE 0 END) as delta_blobs\n      FROM file_blobs\n    `);\n        const row = stmt.get();\n        const totalSize = row.total_size || 0;\n        const totalCompressedSize = row.total_compressed_size || 0;\n        return {\n            totalBlobs: row.total_blobs || 0,\n            totalSize,\n            totalCompressedSize,\n            compressionRatio: totalSize > 0 ? totalCompressedSize / totalSize : 0,\n            deltaBlobs: row.delta_blobs || 0,\n        };\n    }\n    /**\n     * Garbage collect unreferenced blobs\n     *\n     * Removes blobs that are not referenced by any file tree.\n     *\n     * @returns Number of blobs deleted\n     */\n    garbageCollect() {\n        // TODO: Implement garbage collection\n        // This requires scanning all file_trees and finding unreferenced blobs\n        return 0;\n    }\n}\n/**\n * Get MerkleDAG singleton instance\n */\nexport function getMerkleDAG() {\n    return MerkleDAG.getInstance();\n}\n//# sourceMappingURL=merkle-dag.js.map"
  },
  "dist/timeline/snapshot-manager.js": {
    "path": "dist/timeline/snapshot-manager.js",
    "hash": "3ab12736b8d5c793fa4495f5f00695f9a8b83865f5d1bfebe49424f82cac1621",
    "size": 11360,
    "timestamp": 1764704879299,
    "content": "/**\n * Snapshot Manager - Automatic System State Snapshots\n *\n * Creates periodic snapshots of the system state for efficient rewind operations.\n * Snapshots include:\n * - Session state (active session, working directory, model)\n * - Conversation history (compressed)\n * - File checksums (SHA256 hashes)\n * - Git state (commit hash, branch, status)\n *\n * Strategy:\n * - Auto-snapshot every N events\n * - Auto-snapshot every N minutes\n * - Manual snapshot on demand\n * - Keep last K snapshots\n *\n * @module timeline/snapshot-manager\n * @version 1.0.0\n */\nimport { TimelineDatabase } from './database.js';\nimport { EventBus } from './event-bus.js';\nimport { EventType } from './event-types.js';\nimport { QueryEngine } from './query-engine.js';\nimport zlib from 'zlib';\nimport { promisify } from 'util';\nconst gzip = promisify(zlib.gzip);\nconst gunzip = promisify(zlib.gunzip);\n/**\n * Snapshot Manager\n */\nexport class SnapshotManager {\n    static instance;\n    db;\n    bus;\n    queryEngine;\n    config;\n    lastSnapshotTime = 0;\n    lastSnapshotSequence = 0;\n    autoSnapshotTimer = null;\n    constructor(config = {}) {\n        this.db = TimelineDatabase.getInstance();\n        this.bus = EventBus.getInstance();\n        this.queryEngine = QueryEngine.getInstance();\n        this.config = {\n            eventsInterval: config.eventsInterval ?? 100,\n            timeInterval: config.timeInterval ?? 5 * 60 * 1000, // 5 minutes\n            maxSnapshots: config.maxSnapshots ?? 50,\n            autoEnabled: config.autoEnabled ?? true,\n        };\n        // Listen for events to trigger auto-snapshots\n        if (this.config.autoEnabled) {\n            this.startAutoSnapshots();\n        }\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!SnapshotManager.instance) {\n            SnapshotManager.instance = new SnapshotManager(config);\n        }\n        return SnapshotManager.instance;\n    }\n    /**\n     * Start automatic snapshot timers\n     */\n    startAutoSnapshots() {\n        // Time-based snapshots\n        if (this.config.timeInterval > 0) {\n            this.autoSnapshotTimer = setInterval(() => {\n                this.checkAndCreateTimeSnapshot();\n            }, this.config.timeInterval);\n        }\n        // Event-based snapshots would require a more complex event listener\n        // For now, we rely on time-based snapshots only\n        // TODO: Implement event counting mechanism\n    }\n    /**\n     * Stop automatic snapshots\n     */\n    stopAutoSnapshots() {\n        if (this.autoSnapshotTimer) {\n            clearInterval(this.autoSnapshotTimer);\n            this.autoSnapshotTimer = null;\n        }\n    }\n    /**\n     * Check and create time-based snapshot\n     */\n    async checkAndCreateTimeSnapshot() {\n        const now = Date.now();\n        if (now - this.lastSnapshotTime >= this.config.timeInterval) {\n            try {\n                await this.createSnapshot('auto_time');\n            }\n            catch (error) {\n                console.error('Failed to create time-based snapshot:', error);\n            }\n        }\n    }\n    /**\n     * Check and create event-based snapshot\n     */\n    async checkAndCreateEventSnapshot() {\n        const currentSequence = this.db.getCurrentSequence();\n        if (currentSequence - this.lastSnapshotSequence >= this.config.eventsInterval) {\n            try {\n                await this.createSnapshot('auto_event');\n            }\n            catch (error) {\n                console.error('Failed to create event-based snapshot:', error);\n            }\n        }\n    }\n    /**\n     * Create a snapshot of current system state\n     */\n    async createSnapshot(reason = 'manual') {\n        const timestamp = Date.now();\n        const snapshotId = `snapshot_${timestamp}_${Math.random().toString(36).substring(7)}`;\n        // Collect system state\n        const data = {\n            metadata: {\n                snapshot_id: snapshotId,\n                timestamp,\n                sequence_number: this.db.getCurrentSequence(),\n                event_count: this.queryEngine.query({ limit: 1 }).total,\n                session_id: null, // TODO: Get from session manager\n                session_name: null,\n                working_dir: process.cwd(),\n                git_commit_hash: null, // TODO: Get from git hook\n                git_branch: null,\n                file_count: 0,\n                compressed_size_bytes: 0,\n                uncompressed_size_bytes: 0,\n                created_at: timestamp,\n            },\n            session_state: {\n                active_session_id: null,\n                working_directory: process.cwd(),\n            },\n            conversations: [],\n            file_checksums: {},\n            git_state: {\n                commit_hash: null,\n                branch: null,\n                is_clean: true,\n                ahead: 0,\n                behind: 0,\n            },\n        };\n        // Compress snapshot data\n        const jsonData = JSON.stringify(data);\n        const uncompressedSize = Buffer.from(jsonData).length;\n        const compressed = await gzip(jsonData);\n        const compressedSize = compressed.length;\n        // Update metadata with sizes\n        data.metadata.compressed_size_bytes = compressedSize;\n        data.metadata.uncompressed_size_bytes = uncompressedSize;\n        // Store in database\n        const stmt = this.db.getConnection().prepare(`\n      INSERT INTO snapshots (\n        id, timestamp, sequence_number, event_count,\n        session_id, session_name, working_dir,\n        git_commit_hash, git_branch,\n        file_count, compressed_size_bytes, uncompressed_size_bytes,\n        snapshot_data, created_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n        stmt.run(snapshotId, timestamp, data.metadata.sequence_number, data.metadata.event_count, data.metadata.session_id, data.metadata.session_name, data.metadata.working_dir, data.metadata.git_commit_hash, data.metadata.git_branch, data.metadata.file_count, compressedSize, uncompressedSize, compressed, timestamp);\n        // Update tracking\n        this.lastSnapshotTime = timestamp;\n        this.lastSnapshotSequence = data.metadata.sequence_number;\n        // Log snapshot creation event\n        await this.bus.emit({\n            event_type: EventType.SNAPSHOT_CREATED,\n            actor: 'system',\n            aggregate_id: snapshotId,\n            aggregate_type: 'snapshot',\n            payload: {\n                reason,\n                compressed_size_bytes: compressedSize,\n                uncompressed_size_bytes: uncompressedSize,\n                event_count: data.metadata.event_count,\n            },\n        });\n        // Cleanup old snapshots if needed\n        if (this.config.maxSnapshots > 0) {\n            await this.cleanupOldSnapshots();\n        }\n        return snapshotId;\n    }\n    /**\n     * Load snapshot by ID\n     */\n    async loadSnapshot(snapshotId) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT * FROM snapshots WHERE id = ?\n    `);\n        const row = stmt.get(snapshotId);\n        if (!row)\n            return null;\n        // Decompress data\n        const compressed = row.snapshot_data;\n        const uncompressed = await gunzip(compressed);\n        const data = JSON.parse(uncompressed.toString());\n        // Log snapshot load event\n        await this.bus.emit({\n            event_type: EventType.SNAPSHOT_LOADED,\n            actor: 'system',\n            aggregate_id: snapshotId,\n            aggregate_type: 'snapshot',\n            payload: {\n                timestamp: row.timestamp,\n                event_count: row.event_count,\n            },\n        });\n        return data;\n    }\n    /**\n     * Get snapshot closest to a timestamp\n     */\n    async getSnapshotBeforeTimestamp(timestamp) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT \n        id as snapshot_id,\n        timestamp,\n        sequence_number,\n        event_count,\n        session_id,\n        session_name,\n        working_dir,\n        git_commit_hash,\n        git_branch,\n        file_count,\n        compressed_size_bytes,\n        uncompressed_size_bytes,\n        created_at\n      FROM snapshots \n      WHERE timestamp <= ?\n      ORDER BY timestamp DESC\n      LIMIT 1\n    `);\n        const row = stmt.get(timestamp);\n        return row || null;\n    }\n    /**\n     * List all snapshots\n     */\n    listSnapshots(limit = 100) {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT \n        id as snapshot_id,\n        timestamp,\n        sequence_number,\n        event_count,\n        session_id,\n        session_name,\n        working_dir,\n        git_commit_hash,\n        git_branch,\n        file_count,\n        compressed_size_bytes,\n        uncompressed_size_bytes,\n        created_at\n      FROM snapshots \n      ORDER BY timestamp DESC\n      LIMIT ?\n    `);\n        return stmt.all(limit);\n    }\n    /**\n     * Delete snapshot\n     */\n    async deleteSnapshot(snapshotId) {\n        const stmt = this.db.getConnection().prepare(`\n      DELETE FROM snapshots WHERE id = ?\n    `);\n        const result = stmt.run(snapshotId);\n        if (result.changes > 0) {\n            await this.bus.emit({\n                event_type: EventType.SNAPSHOT_DELETED,\n                actor: 'system',\n                aggregate_id: snapshotId,\n                aggregate_type: 'snapshot',\n                payload: {\n                    deleted_at: Date.now(),\n                },\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Cleanup old snapshots (keep only maxSnapshots)\n     */\n    async cleanupOldSnapshots() {\n        const snapshots = this.listSnapshots(999999);\n        if (snapshots.length <= this.config.maxSnapshots) {\n            return 0;\n        }\n        const toDelete = snapshots.slice(this.config.maxSnapshots);\n        let deleted = 0;\n        for (const snapshot of toDelete) {\n            const success = await this.deleteSnapshot(snapshot.snapshot_id);\n            if (success)\n                deleted++;\n        }\n        return deleted;\n    }\n    /**\n     * Get snapshot statistics\n     */\n    getStats() {\n        const stmt = this.db.getConnection().prepare(`\n      SELECT \n        COUNT(*) as total,\n        SUM(compressed_size_bytes) as total_size,\n        MIN(timestamp) as oldest,\n        MAX(timestamp) as newest,\n        AVG(compressed_size_bytes) as avg_size\n      FROM snapshots\n    `);\n        const row = stmt.get();\n        return {\n            total_snapshots: row.total || 0,\n            total_size_mb: (row.total_size || 0) / (1024 * 1024),\n            oldest_timestamp: row.oldest || null,\n            newest_timestamp: row.newest || null,\n            avg_compressed_size_kb: (row.avg_size || 0) / 1024,\n        };\n    }\n    /**\n     * Update configuration\n     */\n    updateConfig(config) {\n        Object.assign(this.config, config);\n        // Restart auto-snapshots if config changed\n        if (config.autoEnabled !== undefined) {\n            this.stopAutoSnapshots();\n            if (config.autoEnabled) {\n                this.startAutoSnapshots();\n            }\n        }\n    }\n}\n/**\n * Get SnapshotManager singleton instance\n */\nexport function getSnapshotManager(config) {\n    return SnapshotManager.getInstance(config);\n}\n//# sourceMappingURL=snapshot-manager.js.map"
  },
  "dist/timeline/index.js": {
    "path": "dist/timeline/index.js",
    "hash": "6c01b80f9dd55df9f62ac30d88a848fe27b77dea9fa60d38dd4d927c2343c79d",
    "size": 3622,
    "timestamp": 1764704879299,
    "content": "/**\n * Timeline Module - Event Sourcing & Time Machine\n *\n * Main entry point for timeline functionality.\n *\n * Usage:\n * ```typescript\n * import { getTimelineDb, getLLMHook, getEventBus } from './timeline';\n *\n * // Initialize timeline\n * const timeline = getTimelineDb();\n *\n * // Get hooks\n * const llmHook = getLLMHook();\n * const toolHook = getToolHook();\n *\n * // Capture events\n * await llmHook.captureUserMessage('Hello', 1, 'gpt-4', 'openai');\n * ```\n *\n * @module timeline\n * @version 1.0.0\n */\n// Core\nexport { TimelineDatabase, getTimelineDb } from './database.js';\nexport { EventBus, getEventBus } from './event-bus.js';\nexport { TimelineLogger, getTimelineLogger } from './timeline-logger.js';\n// Event Types\nexport { EventType, EventCategory, isEventInCategory, getEventDescription, EVENT_CATEGORIES } from './event-types.js';\n// Hooks\nexport { LLMHook, getLLMHook } from './hooks/llm-hook.js';\nexport { ToolHook, getToolHook } from './hooks/tool-hook.js';\nexport { SessionHook, getSessionHook } from './hooks/session-hook.js';\nexport { FileHook, getFileHook } from './hooks/file-hook.js';\nexport { GitHook, getGitHook } from './hooks/git-hook.js';\n// Storage\nexport { MerkleDAG, getMerkleDAG } from './storage/merkle-dag.js';\n// Query & Rewind\nexport { QueryEngine, getQueryEngine } from './query-engine.js';\nexport { SnapshotManager, getSnapshotManager } from './snapshot-manager.js';\nexport { RewindEngine, getRewindEngine } from './rewind-engine.js';\n// Internal imports for functions\nimport { getLLMHook as _getLLMHook } from './hooks/llm-hook.js';\nimport { getToolHook as _getToolHook } from './hooks/tool-hook.js';\nimport { getSessionHook as _getSessionHook } from './hooks/session-hook.js';\nimport { getFileHook as _getFileHook } from './hooks/file-hook.js';\nimport { getGitHook as _getGitHook } from './hooks/git-hook.js';\nimport { getTimelineDb as _getTimelineDb } from './database.js';\nimport { getEventBus as _getEventBus } from './event-bus.js';\n/**\n * Initialize timeline module\n *\n * Call this once at application startup.\n *\n * @param config - Optional configuration\n * @returns Promise that resolves to true if initialization succeeded\n */\nexport async function initTimeline(config) {\n    try {\n        // Initialize database\n        const db = _getTimelineDb({ dbPath: config?.dbPath });\n        if (!db.healthCheck()) {\n            console.error('‚ùå Timeline database health check failed');\n            return false;\n        }\n        // Initialize hooks\n        if (config?.enableLLMHook !== false) {\n            _getLLMHook({ enabled: true });\n        }\n        if (config?.enableToolHook !== false) {\n            _getToolHook({ enabled: true });\n        }\n        if (config?.enableSessionHook !== false) {\n            _getSessionHook({ enabled: true });\n        }\n        // Initialize and start file hook (if enabled)\n        if (config?.enableFileHook !== false) {\n            const fileHook = _getFileHook({ enabled: true });\n            await fileHook.startWatching();\n        }\n        // Initialize git hook (if enabled)\n        if (config?.enableGitHook !== false) {\n            _getGitHook({ enabled: true });\n        }\n        console.log('‚úÖ Timeline module initialized');\n        return true;\n    }\n    catch (error) {\n        console.error('‚ùå Timeline initialization failed:', error);\n        return false;\n    }\n}\n/**\n * Get timeline statistics\n */\nexport function getTimelineStats() {\n    const db = _getTimelineDb();\n    const bus = _getEventBus();\n    return {\n        database: db.getStats(),\n        eventBus: bus.getStats(),\n    };\n}\n//# sourceMappingURL=index.js.map"
  },
  "dist/timeline/event-types.js": {
    "path": "dist/timeline/event-types.js",
    "hash": "1c816148f098330fe9bd52723ebaed62e13f07c7ccb50a9ce90b03fb6bb75896",
    "size": 12271,
    "timestamp": 1764704879299,
    "content": "/**\n * Event Types - Complete Taxonomy for Timeline Event Sourcing\n *\n * This file defines ALL possible event types that can occur in the system.\n * Each event type represents an atomic, immutable fact about what happened.\n *\n * Design principles:\n * - Past tense (FILE_CREATED, not CREATE_FILE)\n * - Granular (separate STARTED/SUCCESS/FAILED for operations)\n * - Explicit (no ambiguous types)\n *\n * @module timeline/event-types\n * @version 1.0.0\n */\n/**\n * Event Type Enumeration\n *\n * Categories:\n * - SESSION_*: Session lifecycle\n * - LLM_*: LLM interactions\n * - TOOL_*: Tool executions\n * - FILE_*: File operations\n * - GIT_*: Git operations\n * - CLI_*: CLI system events\n * - REWIND_*: Rewind operations\n */\nexport var EventType;\n(function (EventType) {\n    // ========================================\n    // SESSION EVENTS\n    // ========================================\n    EventType[\"SESSION_CREATED\"] = \"SESSION_CREATED\";\n    EventType[\"SESSION_SWITCHED\"] = \"SESSION_SWITCHED\";\n    EventType[\"SESSION_RENAMED\"] = \"SESSION_RENAMED\";\n    EventType[\"SESSION_CLOSED\"] = \"SESSION_CLOSED\";\n    EventType[\"SESSION_RESTORED\"] = \"SESSION_RESTORED\";\n    // ========================================\n    // LLM INTERACTION EVENTS\n    // ========================================\n    EventType[\"LLM_MESSAGE_USER\"] = \"LLM_MESSAGE_USER\";\n    EventType[\"LLM_MESSAGE_ASSISTANT\"] = \"LLM_MESSAGE_ASSISTANT\";\n    EventType[\"LLM_MESSAGE_SYSTEM\"] = \"LLM_MESSAGE_SYSTEM\";\n    EventType[\"LLM_STREAMING_START\"] = \"LLM_STREAMING_START\";\n    EventType[\"LLM_STREAMING_CHUNK\"] = \"LLM_STREAMING_CHUNK\";\n    EventType[\"LLM_STREAMING_END\"] = \"LLM_STREAMING_END\";\n    EventType[\"LLM_ERROR\"] = \"LLM_ERROR\";\n    // ========================================\n    // TOOL EXECUTION EVENTS\n    // ========================================\n    EventType[\"TOOL_CALL_STARTED\"] = \"TOOL_CALL_STARTED\";\n    EventType[\"TOOL_CALL_SUCCESS\"] = \"TOOL_CALL_SUCCESS\";\n    EventType[\"TOOL_CALL_FAILED\"] = \"TOOL_CALL_FAILED\";\n    EventType[\"TOOL_PERMISSION_REQUESTED\"] = \"TOOL_PERMISSION_REQUESTED\";\n    EventType[\"TOOL_PERMISSION_GRANTED\"] = \"TOOL_PERMISSION_GRANTED\";\n    EventType[\"TOOL_PERMISSION_DENIED\"] = \"TOOL_PERMISSION_DENIED\";\n    // ========================================\n    // FILE OPERATION EVENTS\n    // ========================================\n    EventType[\"FILE_READ\"] = \"FILE_READ\";\n    EventType[\"FILE_CREATED\"] = \"FILE_CREATED\";\n    EventType[\"FILE_MODIFIED\"] = \"FILE_MODIFIED\";\n    EventType[\"FILE_DELETED\"] = \"FILE_DELETED\";\n    EventType[\"FILE_RENAMED\"] = \"FILE_RENAMED\";\n    EventType[\"FILE_PERMISSION_CHANGED\"] = \"FILE_PERMISSION_CHANGED\";\n    EventType[\"FILE_MOVED\"] = \"FILE_MOVED\";\n    // ========================================\n    // DIRECTORY OPERATION EVENTS\n    // ========================================\n    EventType[\"DIRECTORY_CREATED\"] = \"DIRECTORY_CREATED\";\n    EventType[\"DIRECTORY_DELETED\"] = \"DIRECTORY_DELETED\";\n    EventType[\"DIRECTORY_RENAMED\"] = \"DIRECTORY_RENAMED\";\n    EventType[\"DIRECTORY_MOVED\"] = \"DIRECTORY_MOVED\";\n    // ========================================\n    // GIT OPERATION EVENTS\n    // ========================================\n    EventType[\"GIT_INIT\"] = \"GIT_INIT\";\n    EventType[\"GIT_ADD\"] = \"GIT_ADD\";\n    EventType[\"GIT_COMMIT\"] = \"GIT_COMMIT\";\n    EventType[\"GIT_PUSH\"] = \"GIT_PUSH\";\n    EventType[\"GIT_PULL\"] = \"GIT_PULL\";\n    EventType[\"GIT_FETCH\"] = \"GIT_FETCH\";\n    EventType[\"GIT_MERGE\"] = \"GIT_MERGE\";\n    EventType[\"GIT_REBASE\"] = \"GIT_REBASE\";\n    EventType[\"GIT_BRANCH_CREATED\"] = \"GIT_BRANCH_CREATED\";\n    EventType[\"GIT_BRANCH_SWITCHED\"] = \"GIT_BRANCH_SWITCHED\";\n    EventType[\"GIT_BRANCH_DELETED\"] = \"GIT_BRANCH_DELETED\";\n    EventType[\"GIT_TAG_CREATED\"] = \"GIT_TAG_CREATED\";\n    EventType[\"GIT_TAG_DELETED\"] = \"GIT_TAG_DELETED\";\n    EventType[\"GIT_STASH_PUSH\"] = \"GIT_STASH_PUSH\";\n    EventType[\"GIT_STASH_POP\"] = \"GIT_STASH_POP\";\n    EventType[\"GIT_CONFLICT\"] = \"GIT_CONFLICT\";\n    // ========================================\n    // CLI SYSTEM EVENTS\n    // ========================================\n    EventType[\"CLI_STARTED\"] = \"CLI_STARTED\";\n    EventType[\"CLI_STOPPED\"] = \"CLI_STOPPED\";\n    EventType[\"CLI_COMMAND_EXECUTED\"] = \"CLI_COMMAND_EXECUTED\";\n    EventType[\"MODEL_CHANGED\"] = \"MODEL_CHANGED\";\n    EventType[\"PROVIDER_CHANGED\"] = \"PROVIDER_CHANGED\";\n    EventType[\"SETTINGS_UPDATED\"] = \"SETTINGS_UPDATED\";\n    EventType[\"API_KEY_ADDED\"] = \"API_KEY_ADDED\";\n    EventType[\"API_KEY_REMOVED\"] = \"API_KEY_REMOVED\";\n    // ========================================\n    // REWIND OPERATION EVENTS\n    // ========================================\n    EventType[\"REWIND_STARTED\"] = \"REWIND_STARTED\";\n    EventType[\"REWIND_SNAPSHOT_LOADED\"] = \"REWIND_SNAPSHOT_LOADED\";\n    EventType[\"REWIND_EVENTS_REPLAYED\"] = \"REWIND_EVENTS_REPLAYED\";\n    EventType[\"REWIND_STATE_MATERIALIZED\"] = \"REWIND_STATE_MATERIALIZED\";\n    EventType[\"REWIND_COMPLETED\"] = \"REWIND_COMPLETED\";\n    EventType[\"REWIND_FAILED\"] = \"REWIND_FAILED\";\n    // ========================================\n    // SNAPSHOT EVENTS\n    // ========================================\n    EventType[\"SNAPSHOT_CREATED\"] = \"SNAPSHOT_CREATED\";\n    EventType[\"SNAPSHOT_LOADED\"] = \"SNAPSHOT_LOADED\";\n    EventType[\"SNAPSHOT_DELETED\"] = \"SNAPSHOT_DELETED\";\n    // ========================================\n    // ERROR EVENTS\n    // ========================================\n    EventType[\"ERROR_OCCURRED\"] = \"ERROR_OCCURRED\";\n    EventType[\"EXCEPTION_THROWN\"] = \"EXCEPTION_THROWN\";\n})(EventType || (EventType = {}));\n/**\n * Event Category Enum\n */\nexport var EventCategory;\n(function (EventCategory) {\n    EventCategory[\"SESSION\"] = \"SESSION\";\n    EventCategory[\"LLM\"] = \"LLM\";\n    EventCategory[\"TOOL\"] = \"TOOL\";\n    EventCategory[\"FILE\"] = \"FILE\";\n    EventCategory[\"GIT\"] = \"GIT\";\n    EventCategory[\"REWIND\"] = \"REWIND\";\n})(EventCategory || (EventCategory = {}));\n/**\n * Event Category Groupings\n *\n * For filtering and querying events by category.\n */\nexport const EVENT_CATEGORIES = {\n    SESSION: [\n        EventType.SESSION_CREATED,\n        EventType.SESSION_SWITCHED,\n        EventType.SESSION_RENAMED,\n        EventType.SESSION_CLOSED,\n        EventType.SESSION_RESTORED,\n    ],\n    LLM: [\n        EventType.LLM_MESSAGE_USER,\n        EventType.LLM_MESSAGE_ASSISTANT,\n        EventType.LLM_MESSAGE_SYSTEM,\n        EventType.LLM_STREAMING_START,\n        EventType.LLM_STREAMING_CHUNK,\n        EventType.LLM_STREAMING_END,\n        EventType.LLM_ERROR,\n    ],\n    TOOL: [\n        EventType.TOOL_CALL_STARTED,\n        EventType.TOOL_CALL_SUCCESS,\n        EventType.TOOL_CALL_FAILED,\n        EventType.TOOL_PERMISSION_REQUESTED,\n        EventType.TOOL_PERMISSION_GRANTED,\n        EventType.TOOL_PERMISSION_DENIED,\n    ],\n    FILE: [\n        EventType.FILE_READ,\n        EventType.FILE_CREATED,\n        EventType.FILE_MODIFIED,\n        EventType.FILE_DELETED,\n        EventType.FILE_RENAMED,\n        EventType.FILE_PERMISSION_CHANGED,\n        EventType.FILE_MOVED,\n        EventType.DIRECTORY_CREATED,\n        EventType.DIRECTORY_DELETED,\n        EventType.DIRECTORY_RENAMED,\n        EventType.DIRECTORY_MOVED,\n    ],\n    GIT: [\n        EventType.GIT_INIT,\n        EventType.GIT_ADD,\n        EventType.GIT_COMMIT,\n        EventType.GIT_PUSH,\n        EventType.GIT_PULL,\n        EventType.GIT_FETCH,\n        EventType.GIT_MERGE,\n        EventType.GIT_REBASE,\n        EventType.GIT_BRANCH_CREATED,\n        EventType.GIT_BRANCH_SWITCHED,\n        EventType.GIT_BRANCH_DELETED,\n        EventType.GIT_TAG_CREATED,\n        EventType.GIT_TAG_DELETED,\n        EventType.GIT_STASH_PUSH,\n        EventType.GIT_STASH_POP,\n        EventType.GIT_CONFLICT,\n    ],\n    REWIND: [\n        EventType.REWIND_STARTED,\n        EventType.REWIND_SNAPSHOT_LOADED,\n        EventType.REWIND_EVENTS_REPLAYED,\n        EventType.REWIND_STATE_MATERIALIZED,\n        EventType.REWIND_COMPLETED,\n        EventType.REWIND_FAILED,\n    ],\n};\n/**\n * Helper: Check if event type belongs to a category\n */\nexport function isEventInCategory(eventType, category) {\n    const categoryKey = typeof category === 'string' && category in EVENT_CATEGORIES\n        ? category\n        : category;\n    return EVENT_CATEGORIES[categoryKey].includes(eventType);\n}\n/**\n * Helper: Get human-readable event description\n */\nexport function getEventDescription(eventType) {\n    const descriptions = {\n        [EventType.SESSION_CREATED]: 'Session created',\n        [EventType.SESSION_SWITCHED]: 'Switched to different session',\n        [EventType.SESSION_RENAMED]: 'Session renamed',\n        [EventType.SESSION_CLOSED]: 'Session closed',\n        [EventType.SESSION_RESTORED]: 'Session restored from rewind',\n        [EventType.LLM_MESSAGE_USER]: 'User message sent to LLM',\n        [EventType.LLM_MESSAGE_ASSISTANT]: 'LLM response received',\n        [EventType.LLM_MESSAGE_SYSTEM]: 'System message added',\n        [EventType.LLM_STREAMING_START]: 'LLM streaming started',\n        [EventType.LLM_STREAMING_CHUNK]: 'LLM streaming chunk received',\n        [EventType.LLM_STREAMING_END]: 'LLM streaming completed',\n        [EventType.LLM_ERROR]: 'LLM error occurred',\n        [EventType.TOOL_CALL_STARTED]: 'Tool execution started',\n        [EventType.TOOL_CALL_SUCCESS]: 'Tool executed successfully',\n        [EventType.TOOL_CALL_FAILED]: 'Tool execution failed',\n        [EventType.TOOL_PERMISSION_REQUESTED]: 'Tool permission requested',\n        [EventType.TOOL_PERMISSION_GRANTED]: 'Tool permission granted',\n        [EventType.TOOL_PERMISSION_DENIED]: 'Tool permission denied',\n        [EventType.FILE_READ]: 'File read',\n        [EventType.FILE_CREATED]: 'File created',\n        [EventType.FILE_MODIFIED]: 'File modified',\n        [EventType.FILE_DELETED]: 'File deleted',\n        [EventType.FILE_RENAMED]: 'File renamed',\n        [EventType.FILE_PERMISSION_CHANGED]: 'File permissions changed',\n        [EventType.FILE_MOVED]: 'File moved',\n        [EventType.DIRECTORY_CREATED]: 'Directory created',\n        [EventType.DIRECTORY_DELETED]: 'Directory deleted',\n        [EventType.DIRECTORY_RENAMED]: 'Directory renamed',\n        [EventType.DIRECTORY_MOVED]: 'Directory moved',\n        [EventType.GIT_INIT]: 'Git repository initialized',\n        [EventType.GIT_ADD]: 'Files staged for commit',\n        [EventType.GIT_COMMIT]: 'Git commit created',\n        [EventType.GIT_PUSH]: 'Changes pushed to remote',\n        [EventType.GIT_PULL]: 'Changes pulled from remote',\n        [EventType.GIT_FETCH]: 'Remote changes fetched',\n        [EventType.GIT_MERGE]: 'Branches merged',\n        [EventType.GIT_REBASE]: 'Branch rebased',\n        [EventType.GIT_BRANCH_CREATED]: 'Git branch created',\n        [EventType.GIT_BRANCH_SWITCHED]: 'Switched to different branch',\n        [EventType.GIT_BRANCH_DELETED]: 'Git branch deleted',\n        [EventType.GIT_TAG_CREATED]: 'Git tag created',\n        [EventType.GIT_TAG_DELETED]: 'Git tag deleted',\n        [EventType.GIT_STASH_PUSH]: 'Changes stashed',\n        [EventType.GIT_STASH_POP]: 'Stashed changes applied',\n        [EventType.GIT_CONFLICT]: 'Git conflict occurred',\n        [EventType.CLI_STARTED]: 'CLI started',\n        [EventType.CLI_STOPPED]: 'CLI stopped',\n        [EventType.CLI_COMMAND_EXECUTED]: 'Command executed',\n        [EventType.MODEL_CHANGED]: 'AI model changed',\n        [EventType.PROVIDER_CHANGED]: 'AI provider changed',\n        [EventType.SETTINGS_UPDATED]: 'Settings updated',\n        [EventType.API_KEY_ADDED]: 'API key added',\n        [EventType.API_KEY_REMOVED]: 'API key removed',\n        [EventType.REWIND_STARTED]: 'Rewind operation started',\n        [EventType.REWIND_SNAPSHOT_LOADED]: 'Snapshot loaded for rewind',\n        [EventType.REWIND_EVENTS_REPLAYED]: 'Events replayed',\n        [EventType.REWIND_STATE_MATERIALIZED]: 'State materialized to filesystem',\n        [EventType.REWIND_COMPLETED]: 'Rewind completed successfully',\n        [EventType.REWIND_FAILED]: 'Rewind failed',\n        [EventType.SNAPSHOT_CREATED]: 'Snapshot created',\n        [EventType.SNAPSHOT_LOADED]: 'Snapshot loaded',\n        [EventType.SNAPSHOT_DELETED]: 'Snapshot deleted',\n        [EventType.ERROR_OCCURRED]: 'Error occurred',\n        [EventType.EXCEPTION_THROWN]: 'Exception thrown',\n    };\n    return descriptions[eventType] || 'Unknown event';\n}\n//# sourceMappingURL=event-types.js.map"
  },
  "dist/timeline/database.js": {
    "path": "dist/timeline/database.js",
    "hash": "f287d13536dd4cf3a9b193d697f0f7cd213be80a600e5b83a4144118c6e37d88",
    "size": 9011,
    "timestamp": 1764704879299,
    "content": "/**\n * Timeline Database Manager\n *\n * Manages the connection to timeline.db (SQLite).\n * This database is APPEND-ONLY: NO UPDATE or DELETE operations allowed.\n *\n * Features:\n * - Auto-initialization of schema\n * - Connection pooling (via better-sqlite3)\n * - Read-only mode for queries\n * - Write-only mode for event logging\n *\n * @module timeline/database\n * @version 1.0.0\n */\nimport Database from 'better-sqlite3';\nimport fs from 'fs';\nimport path from 'path';\nimport { TIMELINE_SCHEMA } from './schema.js';\n/**\n * Timeline Database Manager\n *\n * Singleton pattern: Only one instance per process.\n */\nexport class TimelineDatabase {\n    static instance = null;\n    db;\n    dbPath;\n    schemaVersion = '1.0.0';\n    /**\n     * Private constructor (Singleton pattern)\n     */\n    constructor(config = {}) {\n        // Determine database path\n        const homeDir = process.env.HOME || process.env.USERPROFILE || '/tmp';\n        const grokDir = path.join(homeDir, '.grok');\n        // Ensure .grok directory exists\n        if (!fs.existsSync(grokDir)) {\n            fs.mkdirSync(grokDir, { recursive: true });\n        }\n        this.dbPath = config.dbPath || path.join(grokDir, 'timeline.db');\n        // Open database connection\n        this.db = new Database(this.dbPath, {\n            readonly: config.readOnly || false,\n            verbose: config.verbose ? console.log : undefined,\n        });\n        // Configure SQLite for performance\n        this.db.pragma('journal_mode = WAL'); // Write-Ahead Logging\n        this.db.pragma('synchronous = NORMAL'); // Balance safety/performance\n        this.db.pragma('cache_size = -64000'); // 64MB cache\n        this.db.pragma('foreign_keys = ON'); // Enforce foreign keys\n        this.db.pragma('temp_store = MEMORY'); // Temp tables in RAM\n        // Initialize schema if needed\n        if (!config.readOnly) {\n            this.initializeSchema();\n        }\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance(config) {\n        if (!TimelineDatabase.instance) {\n            TimelineDatabase.instance = new TimelineDatabase(config);\n        }\n        return TimelineDatabase.instance;\n    }\n    /**\n     * Initialize database schema\n     */\n    initializeSchema() {\n        try {\n            // Run lightweight migrations before applying full schema\n            this.migrateSchemaIfNeeded();\n            // Execute embedded schema\n            this.db.exec(TIMELINE_SCHEMA);\n            // Verify schema version\n            const currentVersion = this.getMetadata('schema_version');\n            if (currentVersion !== this.schemaVersion) {\n                console.warn(`‚ö†Ô∏è  Timeline schema version mismatch: expected ${this.schemaVersion}, got ${currentVersion}`);\n            }\n        }\n        catch (error) {\n            console.error('‚ùå Failed to initialize timeline schema:', error);\n            throw error;\n        }\n    }\n    /**\n     * Run backward-compatible migrations for older timeline.db versions.\n     *\n     * Important: this must NOT drop existing data. Only additive changes.\n     */\n    migrateSchemaIfNeeded() {\n        try {\n            // 1) snapshots.created_at migration\n            // Older versions created \"snapshots\" without created_at column,\n            // but newer schema expects it and creates an index on it.\n            const hasSnapshotsTable = this.db\n                .prepare(`SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'snapshots'`)\n                .get();\n            if (hasSnapshotsTable) {\n                const columns = this.db\n                    .prepare(`PRAGMA table_info('snapshots')`)\n                    .all();\n                const hasCreatedAt = columns.some((c) => c.name === 'created_at');\n                if (!hasCreatedAt) {\n                    console.warn('‚ö†Ô∏è  Timeline migration: adding missing snapshots.created_at column (backfilling from timestamp)');\n                    // Add the column as nullable, then backfill from existing timestamp\n                    this.db.exec(`\n            ALTER TABLE snapshots ADD COLUMN created_at INTEGER;\n            UPDATE snapshots SET created_at = timestamp WHERE created_at IS NULL;\n          `);\n                }\n            }\n        }\n        catch (migrationError) {\n            // Migrations should never block startup; log and continue.\n            console.error('‚ö†Ô∏è  Timeline schema migration failed (non-fatal):', migrationError);\n        }\n    }\n    /**\n     * Get database connection (for raw queries)\n     *\n     * ‚ö†Ô∏è WARNING: Use with caution. Prefer high-level methods.\n     */\n    getConnection() {\n        return this.db;\n    }\n    /**\n     * Get metadata value\n     */\n    getMetadata(key) {\n        const stmt = this.db.prepare('SELECT value FROM metadata WHERE key = ?');\n        const row = stmt.get(key);\n        return row?.value || null;\n    }\n    /**\n     * Set metadata value\n     */\n    setMetadata(key, value) {\n        const stmt = this.db.prepare(`\n      INSERT OR REPLACE INTO metadata (key, value, updated_at)\n      VALUES (?, ?, ?)\n    `);\n        stmt.run(key, value, Date.now() * 1000); // Microseconds\n    }\n    /**\n     * Get current sequence number\n     */\n    getCurrentSequence() {\n        const lastSeq = this.getMetadata('last_sequence');\n        return parseInt(lastSeq || '0', 10);\n    }\n    /**\n     * Increment and return next sequence number\n     *\n     * Thread-safe via SQLite's transaction.\n     * Auto-repairs if last_sequence is out of sync with actual events.\n     */\n    getNextSequence() {\n        // Use transaction for thread-safety\n        const getNext = this.db.transaction(() => {\n            // Get current last_sequence from metadata\n            const currentSeq = parseInt(this.getMetadata('last_sequence') || '0', 10);\n            // Safety check: verify against actual max sequence in events table\n            const maxSeqRow = this.db.prepare('SELECT COALESCE(MAX(sequence_number), 0) as max_seq FROM events').get();\n            const maxSeq = maxSeqRow.max_seq;\n            // If metadata is out of sync, repair it\n            let nextSeq = currentSeq + 1;\n            if (currentSeq < maxSeq) {\n                console.warn(`‚ö†Ô∏è  Timeline sequence counter out of sync (metadata: ${currentSeq}, actual: ${maxSeq}). Auto-repairing...`);\n                nextSeq = maxSeq + 1;\n            }\n            // Update metadata with new sequence\n            const updateStmt = this.db.prepare(`\n        UPDATE metadata \n        SET value = ?,\n            updated_at = ?\n        WHERE key = 'last_sequence'\n      `);\n            updateStmt.run(nextSeq.toString(), Date.now() * 1000);\n            return nextSeq;\n        });\n        return getNext();\n    }\n    /**\n     * Get database statistics\n     */\n    getStats() {\n        const countEvents = this.db.prepare('SELECT COUNT(*) as count FROM events').get();\n        const countSnapshots = this.db.prepare('SELECT COUNT(*) as count FROM snapshots').get();\n        const countBlobs = this.db.prepare('SELECT COUNT(*) as count FROM file_blobs').get();\n        const lastEvent = this.db.prepare('SELECT MAX(timestamp) as ts FROM events').get();\n        // Get database file size\n        let dbSizeMb = 0;\n        try {\n            const stats = fs.statSync(this.dbPath);\n            dbSizeMb = stats.size / 1024 / 1024;\n        }\n        catch (error) {\n            // Ignore error\n        }\n        return {\n            total_events: countEvents.count,\n            total_snapshots: countSnapshots.count,\n            total_blobs: countBlobs.count,\n            db_size_mb: Math.round(dbSizeMb * 100) / 100,\n            last_event_time: lastEvent.ts,\n        };\n    }\n    /**\n     * Vacuum database (reclaim space)\n     *\n     * ‚ö†Ô∏è This can be slow on large databases.\n     */\n    vacuum() {\n        console.log('üóëÔ∏è  Vacuuming timeline database...');\n        this.db.exec('VACUUM');\n        console.log('‚úÖ Vacuum completed');\n    }\n    /**\n     * Optimize database (analyze + reindex)\n     */\n    optimize() {\n        console.log('‚ö° Optimizing timeline database...');\n        this.db.exec('ANALYZE');\n        this.db.exec('REINDEX');\n        console.log('‚úÖ Optimization completed');\n    }\n    /**\n     * Close database connection\n     */\n    close() {\n        if (this.db) {\n            this.db.close();\n            TimelineDatabase.instance = null;\n        }\n    }\n    /**\n     * Check if database is healthy\n     */\n    healthCheck() {\n        try {\n            // Simple query to verify database is accessible\n            this.db.prepare('SELECT 1').get();\n            return true;\n        }\n        catch (error) {\n            console.error('‚ùå Timeline database health check failed:', error);\n            return false;\n        }\n    }\n}\n/**\n * Get timeline database instance (convenience function)\n */\nexport function getTimelineDb(config) {\n    return TimelineDatabase.getInstance(config);\n}\n/**\n * Export for use in other modules\n */\nexport default TimelineDatabase;\n//# sourceMappingURL=database.js.map"
  },
  "dist/utils/custom-instructions.js": {
    "path": "dist/utils/custom-instructions.js",
    "hash": "d57af98e7368c76cec1e3ac0cafd2309c992702868e08af7fcab44d879197f4b",
    "size": 597,
    "timestamp": 1764704879299,
    "content": "import * as fs from 'fs';\nimport * as path from 'path';\nexport function loadCustomInstructions(workingDirectory = process.cwd()) {\n    try {\n        const instructionsPath = path.join(workingDirectory, '.grok', 'GROK.md');\n        if (!fs.existsSync(instructionsPath)) {\n            return null;\n        }\n        const customInstructions = fs.readFileSync(instructionsPath, 'utf-8');\n        return customInstructions.trim();\n    }\n    catch (error) {\n        console.warn('Failed to load custom instructions:', error);\n        return null;\n    }\n}\n//# sourceMappingURL=custom-instructions.js.map"
  },
  "dist/utils/confirmation-service.js": {
    "path": "dist/utils/confirmation-service.js",
    "hash": "07e8ea56dc042c31f0f2d7308e45da906d5996ebb19c96f097868250d34e4622",
    "size": 3801,
    "timestamp": 1764704879299,
    "content": "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { EventEmitter } from \"events\";\nconst execAsync = promisify(exec);\nexport class ConfirmationService extends EventEmitter {\n    static instance;\n    skipConfirmationThisSession = false;\n    pendingConfirmation = null;\n    resolveConfirmation = null;\n    // Session flags for different operation types\n    sessionFlags = {\n        fileOperations: false,\n        bashCommands: false,\n        allOperations: false,\n    };\n    static getInstance() {\n        if (!ConfirmationService.instance) {\n            ConfirmationService.instance = new ConfirmationService();\n        }\n        return ConfirmationService.instance;\n    }\n    constructor() {\n        super();\n    }\n    async requestConfirmation(options, operationType = \"file\") {\n        // Check session flags\n        if (this.sessionFlags.allOperations ||\n            (operationType === \"file\" && this.sessionFlags.fileOperations) ||\n            (operationType === \"bash\" && this.sessionFlags.bashCommands)) {\n            return { confirmed: true };\n        }\n        // If VS Code should be opened, try to open it\n        if (options.showVSCodeOpen) {\n            try {\n                await this.openInVSCode(options.filename);\n            }\n            catch (error) {\n                // If VS Code opening fails, continue without it\n                options.showVSCodeOpen = false;\n            }\n        }\n        // Create a promise that will be resolved by the UI component\n        this.pendingConfirmation = new Promise((resolve) => {\n            this.resolveConfirmation = resolve;\n        });\n        // Emit custom event that the UI can listen to (using setImmediate to ensure the UI updates)\n        setImmediate(() => {\n            this.emit(\"confirmation-requested\", options);\n        });\n        const result = await this.pendingConfirmation;\n        if (result.dontAskAgain) {\n            // Set the appropriate session flag based on operation type\n            if (operationType === \"file\") {\n                this.sessionFlags.fileOperations = true;\n            }\n            else if (operationType === \"bash\") {\n                this.sessionFlags.bashCommands = true;\n            }\n            // Could also set allOperations for global skip\n        }\n        return result;\n    }\n    confirmOperation(confirmed, dontAskAgain) {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({ confirmed, dontAskAgain });\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n    rejectOperation(feedback) {\n        if (this.resolveConfirmation) {\n            this.resolveConfirmation({ confirmed: false, feedback });\n            this.resolveConfirmation = null;\n            this.pendingConfirmation = null;\n        }\n    }\n    async openInVSCode(filename) {\n        // Try different VS Code commands\n        const commands = [\"code\", \"code-insiders\", \"codium\"];\n        for (const cmd of commands) {\n            try {\n                await execAsync(`which ${cmd}`);\n                await execAsync(`${cmd} \"${filename}\"`);\n                return;\n            }\n            catch (error) {\n                // Continue to next command\n                continue;\n            }\n        }\n        throw new Error(\"VS Code not found\");\n    }\n    isPending() {\n        return this.pendingConfirmation !== null;\n    }\n    resetSession() {\n        this.sessionFlags = {\n            fileOperations: false,\n            bashCommands: false,\n            allOperations: false,\n        };\n    }\n    getSessionFlags() {\n        return { ...this.sessionFlags };\n    }\n    setSessionFlag(flagType, value) {\n        this.sessionFlags[flagType] = value;\n    }\n}\n//# sourceMappingURL=confirmation-service.js.map"
  },
  "dist/utils/settings-manager.js": {
    "path": "dist/utils/settings-manager.js",
    "hash": "b3bc0b304acb9a5e2b8fbd4d28e171c0718e6c4696ac892d63cfc725d90a3862",
    "size": 13489,
    "timestamp": 1764704879299,
    "content": "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\n/**\n * Default values for user settings\n */\nconst DEFAULT_USER_SETTINGS = {\n    baseURL: \"https://api.x.ai/v1\",\n    defaultModel: \"grok-4-latest\",\n    models: [\n        // === GROK (X.AI) ===\n        \"grok-4-latest\",\n        \"grok-code-fast-1\",\n        \"grok-3-latest\",\n        \"grok-3-fast\",\n        \"grok-3-mini-fast\",\n        \"grok2-vision-beta\",\n        // === CLAUDE (Anthropic) - Verified names ===\n        \"claude-sonnet-4-5-20250514\", // Latest Sonnet 4.5 (May 2025)\n        \"claude-3-5-sonnet-20241022\",\n        \"claude-3-5-haiku-20241022\",\n        \"claude-3-opus-20240229\",\n        // === OPENAI - Verified ‚úÖ (Tested 2025-11-22) ===\n        \"gpt-5\", // ‚úÖ Latest GPT-5 (Aug 2025)\n        \"gpt-5-2025-08-07\", // ‚úÖ Explicit date version\n        \"o3\", // ‚úÖ Latest O3 reasoning (Apr 2025)\n        \"o3-mini\", // ‚úÖ O3 Mini (Jan 2025)\n        \"o1\", // ‚úÖ O1 reasoning (Dec 2024)\n        \"gpt-4o\", // ‚úÖ Latest GPT-4o\n        \"gpt-4o-2024-11-20\", // ‚úÖ Nov 2024 version\n        \"gpt-4o-2024-08-06\", // ‚úÖ Aug 2024 version\n        \"gpt-4o-mini\", // ‚úÖ Mini version\n        \"chatgpt-4o-latest\", // ‚úÖ ChatGPT version\n        \"gpt-4-turbo\", // ‚úÖ GPT-4 Turbo\n        \"gpt-3.5-turbo\", // ‚úÖ GPT-3.5\n        // === DEEPSEEK - Verified ‚úÖ (Tested 2025-11-22) ===\n        \"deepseek-chat\", // ‚úÖ General chat\n        \"deepseek-coder\", // ‚úÖ Coding (‚Üí deepseek-chat)\n        \"deepseek-reasoner\", // ‚úÖ R1 reasoning model\n        // === MISTRAL - Verified ‚úÖ (Tested 2025-11-22) ===\n        \"mistral-large-latest\", // ‚úÖ\n        \"mistral-large-2407\", // ‚úÖ\n        \"mistral-medium-latest\", // ‚úÖ\n        \"mistral-small-latest\", // ‚úÖ\n        \"mistral-tiny\", // ‚úÖ\n        \"codestral-latest\", // ‚úÖ\n        \"codestral-2405\", // ‚úÖ\n        \"open-mistral-7b\", // ‚úÖ\n        \"open-mixtral-8x7b\", // ‚úÖ\n        \"open-mixtral-8x22b\", // ‚úÖ\n    ],\n    persistInputHistory: true,\n};\n/**\n * Default values for execution viewer\n */\nconst DEFAULT_EXECUTION_VIEWER_SETTINGS = {\n    enabled: true,\n    defaultMode: 'hidden',\n    autoShow: true,\n    autoHide: false,\n    autoHideDelay: 5000,\n    splitRatio: 0.6,\n    layout: 'horizontal',\n    showCOT: true,\n    showCommands: true,\n    detailsMode: false,\n    maxExecutionsShown: 10,\n    colorScheme: 'default',\n};\n/**\n * Default values for project settings\n */\nconst DEFAULT_PROJECT_SETTINGS = {\n    model: \"grok-code-fast-1\",\n    persistSession: true,\n    autoRestoreSession: true,\n    executionViewer: DEFAULT_EXECUTION_VIEWER_SETTINGS,\n};\n/**\n * Unified settings manager that handles both user-level and project-level settings\n */\nexport class SettingsManager {\n    static instance;\n    userSettingsPath;\n    projectSettingsPath;\n    constructor() {\n        // User settings path: ~/.grok/user-settings.json\n        this.userSettingsPath = path.join(os.homedir(), \".grok\", \"user-settings.json\");\n        // Project settings path: .grok/settings.json (in current working directory)\n        this.projectSettingsPath = path.join(process.cwd(), \".grok\", \"settings.json\");\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!SettingsManager.instance) {\n            SettingsManager.instance = new SettingsManager();\n            SettingsManager.instance.migrateModelsIfNeeded();\n        }\n        return SettingsManager.instance;\n    }\n    /**\n     * Auto-migrate old model list to include all providers\n     */\n    migrateModelsIfNeeded() {\n        try {\n            const currentModels = this.getUserSetting(\"models\") || [];\n            const defaultCount = DEFAULT_USER_SETTINGS.models?.length || 35;\n            // Check if migration is needed\n            // Migrate if:\n            // 1. List is significantly smaller than default (< 50% of default models)\n            // 2. OR list is empty\n            const needsMigration = currentModels.length === 0 ||\n                currentModels.length < (defaultCount / 2);\n            if (needsMigration) {\n                console.log(`üîÑ Migrating model list from ${currentModels.length} to ${defaultCount} models...`);\n                this.updateUserSetting(\"models\", DEFAULT_USER_SETTINGS.models);\n                console.log(`‚úÖ Model list updated: ${currentModels.length} ‚Üí ${defaultCount} models`);\n            }\n            else if (currentModels.length < defaultCount - 5) {\n                // List exists but is slightly outdated\n                // Don't auto-migrate (user might have customized), but log a warning\n                console.log(`‚ÑπÔ∏è  Your model list has ${currentModels.length} models (default: ${defaultCount})`);\n                console.log(`   Run /models to see all available models, or manually update ~/.grok/user-settings.json`);\n            }\n        }\n        catch (error) {\n            // Silent fail - not critical\n        }\n    }\n    /**\n     * Ensure directory exists for a given file path\n     */\n    ensureDirectoryExists(filePath) {\n        const dir = path.dirname(filePath);\n        if (!fs.existsSync(dir)) {\n            fs.mkdirSync(dir, { recursive: true, mode: 0o700 });\n        }\n    }\n    /**\n     * Load user settings from ~/.grok/user-settings.json\n     */\n    loadUserSettings() {\n        try {\n            if (!fs.existsSync(this.userSettingsPath)) {\n                // Create default user settings if file doesn't exist\n                this.saveUserSettings(DEFAULT_USER_SETTINGS);\n                return { ...DEFAULT_USER_SETTINGS };\n            }\n            const content = fs.readFileSync(this.userSettingsPath, \"utf-8\");\n            const settings = JSON.parse(content);\n            // Merge with defaults to ensure all required fields exist\n            return { ...DEFAULT_USER_SETTINGS, ...settings };\n        }\n        catch (error) {\n            console.warn(\"Failed to load user settings:\", error instanceof Error ? error.message : \"Unknown error\");\n            return { ...DEFAULT_USER_SETTINGS };\n        }\n    }\n    /**\n     * Save user settings to ~/.grok/user-settings.json\n     */\n    saveUserSettings(settings) {\n        try {\n            this.ensureDirectoryExists(this.userSettingsPath);\n            // Read existing settings directly to avoid recursion\n            let existingSettings = { ...DEFAULT_USER_SETTINGS };\n            if (fs.existsSync(this.userSettingsPath)) {\n                try {\n                    const content = fs.readFileSync(this.userSettingsPath, \"utf-8\");\n                    const parsed = JSON.parse(content);\n                    existingSettings = { ...DEFAULT_USER_SETTINGS, ...parsed };\n                }\n                catch (error) {\n                    // If file is corrupted, use defaults\n                    console.warn(\"Corrupted user settings file, using defaults\");\n                }\n            }\n            const mergedSettings = { ...existingSettings, ...settings };\n            fs.writeFileSync(this.userSettingsPath, JSON.stringify(mergedSettings, null, 2), { mode: 0o600 } // Secure permissions for API key\n            );\n        }\n        catch (error) {\n            console.error(\"Failed to save user settings:\", error instanceof Error ? error.message : \"Unknown error\");\n            throw error;\n        }\n    }\n    /**\n     * Update a specific user setting\n     */\n    updateUserSetting(key, value) {\n        const settings = { [key]: value };\n        this.saveUserSettings(settings);\n    }\n    /**\n     * Get a specific user setting\n     */\n    getUserSetting(key) {\n        const settings = this.loadUserSettings();\n        return settings[key];\n    }\n    /**\n     * Load project settings from .grok/settings.json\n     */\n    loadProjectSettings() {\n        try {\n            if (!fs.existsSync(this.projectSettingsPath)) {\n                // Create default project settings if file doesn't exist\n                this.saveProjectSettings(DEFAULT_PROJECT_SETTINGS);\n                return { ...DEFAULT_PROJECT_SETTINGS };\n            }\n            const content = fs.readFileSync(this.projectSettingsPath, \"utf-8\");\n            const settings = JSON.parse(content);\n            // Merge with defaults\n            return { ...DEFAULT_PROJECT_SETTINGS, ...settings };\n        }\n        catch (error) {\n            console.warn(\"Failed to load project settings:\", error instanceof Error ? error.message : \"Unknown error\");\n            return { ...DEFAULT_PROJECT_SETTINGS };\n        }\n    }\n    /**\n     * Save project settings to .grok/settings.json\n     */\n    saveProjectSettings(settings) {\n        try {\n            this.ensureDirectoryExists(this.projectSettingsPath);\n            // Read existing settings directly to avoid recursion\n            let existingSettings = { ...DEFAULT_PROJECT_SETTINGS };\n            if (fs.existsSync(this.projectSettingsPath)) {\n                try {\n                    const content = fs.readFileSync(this.projectSettingsPath, \"utf-8\");\n                    const parsed = JSON.parse(content);\n                    existingSettings = { ...DEFAULT_PROJECT_SETTINGS, ...parsed };\n                }\n                catch (error) {\n                    // If file is corrupted, use defaults\n                    console.warn(\"Corrupted project settings file, using defaults\");\n                }\n            }\n            const mergedSettings = { ...existingSettings, ...settings };\n            fs.writeFileSync(this.projectSettingsPath, JSON.stringify(mergedSettings, null, 2));\n        }\n        catch (error) {\n            console.error(\"Failed to save project settings:\", error instanceof Error ? error.message : \"Unknown error\");\n            throw error;\n        }\n    }\n    /**\n     * Update a specific project setting\n     */\n    updateProjectSetting(key, value) {\n        const settings = { [key]: value };\n        this.saveProjectSettings(settings);\n    }\n    /**\n     * Get a specific project setting\n     */\n    getProjectSetting(key) {\n        const settings = this.loadProjectSettings();\n        return settings[key];\n    }\n    /**\n     * Get the current model with proper fallback logic:\n     * 1. Project-specific model setting\n     * 2. User's default model\n     * 3. System default\n     */\n    getCurrentModel() {\n        const projectModel = this.getProjectSetting(\"model\");\n        if (projectModel) {\n            return projectModel;\n        }\n        const userDefaultModel = this.getUserSetting(\"defaultModel\");\n        if (userDefaultModel) {\n            return userDefaultModel;\n        }\n        return DEFAULT_PROJECT_SETTINGS.model || \"grok-code-fast-1\";\n    }\n    /**\n     * Set the current model for the project\n     */\n    setCurrentModel(model) {\n        this.updateProjectSetting(\"model\", model);\n    }\n    /**\n     * Get available models list from user settings\n     */\n    getAvailableModels() {\n        const models = this.getUserSetting(\"models\");\n        return models || DEFAULT_USER_SETTINGS.models || [];\n    }\n    /**\n     * Get API key from user settings or environment (legacy - for backward compatibility)\n     */\n    getApiKey() {\n        // First check environment variable\n        const envApiKey = process.env.GROK_API_KEY;\n        if (envApiKey) {\n            return envApiKey;\n        }\n        // Then check user settings\n        return this.getUserSetting(\"apiKey\");\n    }\n    /**\n     * Get all API keys (multi-provider)\n     */\n    getApiKeys() {\n        const apiKeys = this.getUserSetting(\"apiKeys\");\n        // Backward compatibility: if apiKeys not set but apiKey is, use it for grok\n        if (!apiKeys || Object.keys(apiKeys).length === 0) {\n            const legacyKey = this.getApiKey();\n            if (legacyKey) {\n                return { grok: legacyKey };\n            }\n        }\n        return apiKeys;\n    }\n    /**\n     * Get API key for a specific provider\n     */\n    getApiKeyForProvider(provider) {\n        const apiKeys = this.getApiKeys();\n        return apiKeys?.[provider];\n    }\n    /**\n     * Set API key for a specific provider\n     */\n    setApiKey(provider, apiKey) {\n        const apiKeys = this.getApiKeys() || {};\n        apiKeys[provider] = apiKey;\n        this.updateUserSetting(\"apiKeys\", apiKeys);\n    }\n    /**\n     * Get provider configurations\n     */\n    getProviders() {\n        return this.getUserSetting(\"providers\");\n    }\n    /**\n     * Get base URL from user settings or environment\n     */\n    getBaseURL() {\n        // First check environment variable\n        const envBaseURL = process.env.GROK_BASE_URL;\n        if (envBaseURL) {\n            return envBaseURL;\n        }\n        // Then check user settings\n        const userBaseURL = this.getUserSetting(\"baseURL\");\n        return (userBaseURL || DEFAULT_USER_SETTINGS.baseURL || \"https://api.x.ai/v1\");\n    }\n    /**\n     * Get execution viewer settings (merged with defaults)\n     */\n    getExecutionViewerSettings() {\n        const projectSettings = this.getProjectSetting(\"executionViewer\") || {};\n        return {\n            ...DEFAULT_EXECUTION_VIEWER_SETTINGS,\n            ...projectSettings,\n        };\n    }\n    /**\n     * Update execution viewer setting\n     */\n    updateExecutionViewerSetting(key, value) {\n        const current = this.getProjectSetting(\"executionViewer\") || {};\n        this.updateProjectSetting(\"executionViewer\", {\n            ...current,\n            [key]: value,\n        });\n    }\n}\n/**\n * Convenience function to get the singleton instance\n */\nexport function getSettingsManager() {\n    return SettingsManager.getInstance();\n}\n//# sourceMappingURL=settings-manager.js.map"
  },
  "dist/utils/session-manager.js": {
    "path": "dist/utils/session-manager.js",
    "hash": "e8b9f1493fe311ce9c145879e720ffe1a5c39091ae19329e7202833862a1deb6",
    "size": 3067,
    "timestamp": 1764704879299,
    "content": "import * as fs from \"node:fs\";\nimport * as fsp from \"node:fs/promises\";\nimport * as path from \"node:path\";\nfunction getProjectGrokDir() {\n    return path.join(process.cwd(), \".grok\");\n}\nfunction ensureDirSync(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true, mode: 0o700 });\n    }\n}\nfunction getSessionFiles() {\n    const dir = getProjectGrokDir();\n    const sessionLines = path.join(dir, \"session.jsonl\");\n    const stateFile = path.join(dir, \"session.state.json\");\n    return { dir, sessionLines, stateFile };\n}\nfunction serializeEntry(entry) {\n    // Convert Date to ISO\n    const plain = {\n        ...entry,\n        timestamp: entry.timestamp instanceof Date ? entry.timestamp.toISOString() : entry.timestamp,\n        // Ensure undefined fields don't get dropped in an inconsistent way\n        toolCalls: entry.toolCalls || undefined,\n        toolCall: entry.toolCall || undefined,\n        toolResult: entry.toolResult || undefined,\n        isStreaming: false,\n    };\n    return JSON.stringify(plain);\n}\nfunction deserializeEntry(line) {\n    try {\n        const obj = JSON.parse(line);\n        return {\n            type: obj.type,\n            content: obj.content,\n            timestamp: obj.timestamp ? new Date(obj.timestamp) : new Date(),\n            toolCalls: obj.toolCalls,\n            toolCall: obj.toolCall,\n            toolResult: obj.toolResult,\n            isStreaming: false,\n        };\n    }\n    catch {\n        return null;\n    }\n}\nexport async function appendChatEntry(entry) {\n    const { dir, sessionLines } = getSessionFiles();\n    ensureDirSync(dir);\n    const payload = serializeEntry(entry) + \"\\n\";\n    await fsp.appendFile(sessionLines, payload, { encoding: \"utf-8\" });\n}\nexport async function loadChatHistory() {\n    const { sessionLines } = getSessionFiles();\n    try {\n        const data = await fsp.readFile(sessionLines, \"utf-8\");\n        const lines = data.split(\"\\n\").filter(Boolean);\n        const entries = [];\n        for (const line of lines) {\n            const e = deserializeEntry(line);\n            if (e)\n                entries.push(e);\n        }\n        return entries;\n    }\n    catch (e) {\n        if (e && e.code === \"ENOENT\")\n            return [];\n        // Corruption: return empty history\n        return [];\n    }\n}\nexport async function saveState(state) {\n    const { dir, stateFile } = getSessionFiles();\n    ensureDirSync(dir);\n    const payload = JSON.stringify(state, null, 2);\n    await fsp.writeFile(stateFile, payload, { encoding: \"utf-8\", mode: 0o600 });\n}\nexport async function loadState() {\n    const { stateFile } = getSessionFiles();\n    try {\n        const data = await fsp.readFile(stateFile, \"utf-8\");\n        return JSON.parse(data);\n    }\n    catch (e) {\n        return null;\n    }\n}\nexport async function clearSession() {\n    const { sessionLines, stateFile } = getSessionFiles();\n    try {\n        await fsp.unlink(sessionLines);\n    }\n    catch { }\n    try {\n        await fsp.unlink(stateFile);\n    }\n    catch { }\n}\n//# sourceMappingURL=session-manager.js.map"
  },
  "dist/utils/debug-logger.js": {
    "path": "dist/utils/debug-logger.js",
    "hash": "52400554d0ec1aad93984e66dacdbc0e38c2a0225fe9d06302ac51163ff980f0",
    "size": 1303,
    "timestamp": 1764704879299,
    "content": "import fs from 'fs';\nimport path from 'path';\n/**\n * Simple file logger for debugging (bypasses Ink stdout capture)\n */\nclass DebugLogger {\n    logPath;\n    enabled = true;\n    constructor() {\n        // Log to ~/.grok/debug.log\n        const logDir = path.join(process.env.HOME || '~', '.grok');\n        if (!fs.existsSync(logDir)) {\n            fs.mkdirSync(logDir, { recursive: true });\n        }\n        this.logPath = path.join(logDir, 'debug.log');\n        // Clear log on startup\n        try {\n            fs.writeFileSync(this.logPath, `=== DEBUG LOG - ${new Date().toISOString()} ===\\n\\n`);\n        }\n        catch (error) {\n            this.enabled = false;\n        }\n    }\n    log(...args) {\n        if (!this.enabled)\n            return;\n        try {\n            const timestamp = new Date().toISOString();\n            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');\n            fs.appendFileSync(this.logPath, `[${timestamp}] ${message}\\n`);\n        }\n        catch (error) {\n            // Silently fail\n        }\n    }\n    error(...args) {\n        this.log('ERROR:', ...args);\n    }\n    getLogPath() {\n        return this.logPath;\n    }\n}\nexport const debugLog = new DebugLogger();\n//# sourceMappingURL=debug-logger.js.map"
  },
  "dist/utils/image-path-detector.js": {
    "path": "dist/utils/image-path-detector.js",
    "hash": "b116b385c2665a37022f6a37f20cc61ad66456e989005cdad478c510a5c14a2c",
    "size": 5481,
    "timestamp": 1764704879299,
    "content": "/**\n * Image Path Detector - Simple approach like Codex\n *\n * Detects if pasted text is a path to an image file.\n * Much simpler than clipboard pixel capture!\n *\n * How it works:\n * 1. User copies image file in file manager\n * 2. Clipboard contains: /home/user/screenshot.png\n * 3. User pastes (Ctrl+V) - terminal handles natively\n * 4. We detect it's an image path\n * 5. Create placeholder: [screenshot.png 1920x1080]\n * 6. Attach for Vision API\n */\nimport { existsSync, statSync, readFileSync } from 'fs';\nimport { extname, basename, resolve } from 'path';\nimport sizeOf from 'image-size';\n/**\n * Normalize pasted path (handle quotes, tildes, etc.)\n */\nfunction normalizePath(pasted) {\n    let path = pasted.trim();\n    // Remove quotes\n    if ((path.startsWith('\"') && path.endsWith('\"')) ||\n        (path.startsWith(\"'\") && path.endsWith(\"'\"))) {\n        path = path.slice(1, -1);\n    }\n    // Expand tilde\n    if (path.startsWith('~/')) {\n        const home = process.env.HOME || process.env.USERPROFILE;\n        if (home) {\n            path = path.replace(/^~/, home);\n        }\n    }\n    // Make absolute\n    if (!path.startsWith('/')) {\n        path = resolve(process.cwd(), path);\n    }\n    return path;\n}\n/**\n * Check if file extension is an image\n */\nfunction isImageExtension(filepath) {\n    const ext = extname(filepath).toLowerCase();\n    const imageExts = [\n        '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp',\n        '.tiff', '.tif', '.svg', '.ico', '.heic', '.heif'\n    ];\n    return imageExts.includes(ext);\n}\n/**\n * Try to detect if pasted text is an image path\n * Returns DetectedImage if valid, null otherwise\n */\nexport function detectImagePath(pasted) {\n    // Quick filter: must look like a path\n    if (!pasted.includes('/') && !pasted.includes('\\\\')) {\n        return null;\n    }\n    const path = normalizePath(pasted);\n    if (!path) {\n        return null;\n    }\n    // Check if file exists\n    if (!existsSync(path)) {\n        return null;\n    }\n    // Check if it's a file (not directory)\n    const stats = statSync(path);\n    if (!stats.isFile()) {\n        return null;\n    }\n    // Check extension\n    if (!isImageExtension(path)) {\n        return null;\n    }\n    // Try to get dimensions\n    try {\n        const buffer = readFileSync(path);\n        const dimensions = sizeOf(buffer);\n        const width = dimensions.width || 0;\n        const height = dimensions.height || 0;\n        const format = dimensions.type?.toUpperCase() || 'IMG';\n        const filename = basename(path);\n        // Create placeholder like Codex\n        const placeholder = `[${filename} ${width}x${height}]`;\n        return {\n            path,\n            filename,\n            width,\n            height,\n            format,\n            placeholder,\n        };\n    }\n    catch (error) {\n        // Not a valid image file\n        return null;\n    }\n}\n/**\n * Image Path Manager - Manages attached images\n */\nexport class ImagePathManager {\n    attachedImages = new Map();\n    /**\n     * Process pasted content, detect if it's an image path\n     * Returns placeholder if image detected, original text otherwise\n     */\n    processPaste(pasted) {\n        const detected = detectImagePath(pasted);\n        if (detected) {\n            // Store the image\n            this.attachedImages.set(detected.placeholder, detected);\n            return {\n                isImage: true,\n                textToInsert: detected.placeholder,\n                image: detected,\n            };\n        }\n        // Not an image, return as-is\n        return {\n            isImage: false,\n            textToInsert: pasted,\n        };\n    }\n    /**\n     * Get all attached images\n     */\n    getAttachedImages() {\n        return Array.from(this.attachedImages.values());\n    }\n    /**\n     * Get image by placeholder\n     */\n    getImage(placeholder) {\n        return this.attachedImages.get(placeholder);\n    }\n    /**\n     * Check if text contains image placeholder\n     */\n    isImagePlaceholder(text) {\n        return this.attachedImages.has(text);\n    }\n    /**\n     * Remove image by placeholder\n     */\n    removeImage(placeholder) {\n        return this.attachedImages.delete(placeholder);\n    }\n    /**\n     * Find image placeholder at cursor position\n     */\n    findImagePlaceholderAtCursor(text, cursorPos) {\n        for (const image of this.attachedImages.values()) {\n            const { placeholder } = image;\n            let index = 0;\n            while ((index = text.indexOf(placeholder, index)) !== -1) {\n                const start = index;\n                const end = index + placeholder.length;\n                if (cursorPos >= start && cursorPos <= end) {\n                    return { placeholder, start, end };\n                }\n                index += placeholder.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * Sync with text (remove images no longer present)\n     */\n    syncWithText(currentText) {\n        const toRemove = [];\n        for (const [placeholder] of this.attachedImages) {\n            if (!currentText.includes(placeholder)) {\n                toRemove.push(placeholder);\n            }\n        }\n        for (const placeholder of toRemove) {\n            this.attachedImages.delete(placeholder);\n        }\n    }\n    /**\n     * Clear all images\n     */\n    clearAll() {\n        this.attachedImages.clear();\n    }\n}\n// Singleton\nexport const imagePathManager = new ImagePathManager();\n//# sourceMappingURL=image-path-detector.js.map"
  },
  "dist/utils/settings.js": {
    "path": "dist/utils/settings.js",
    "hash": "d1727f6badf04c6c395983b22d4dd3e89105c3b842a1a076ce6828970b9ea1d4",
    "size": 248,
    "timestamp": 1764704879299,
    "content": "// This file is kept for potential future convenience functions\n// All settings management should use getSettingsManager() from './settings-manager.js'\nexport { getSettingsManager } from './settings-manager.js';\n//# sourceMappingURL=settings.js.map"
  },
  "dist/utils/clipboard-manager.js": {
    "path": "dist/utils/clipboard-manager.js",
    "hash": "e6e0b116f26c23817b45d8c6d9481411b455ab884e825dc09b066fc2f7042262",
    "size": 3529,
    "timestamp": 1764704879299,
    "content": "import clipboard from 'clipboardy';\n/**\n * Manages clipboard operations for search results\n */\nexport class ClipboardManager {\n    /**\n     * Copy single message to system clipboard (Markdown format)\n     */\n    async copySingleMessage(message, context, options = {}) {\n        const { includeMetadata = true, format = 'markdown' } = options;\n        const formatted = this.formatMessage(message, context, { includeMetadata, format });\n        await clipboard.write(formatted);\n        return formatted.length;\n    }\n    /**\n     * Copy conversation pair (user + assistant) to clipboard\n     */\n    async copyConversationPair(userMessage, assistantMessage, context, options = {}) {\n        const { includeMetadata = true, format = 'markdown' } = options;\n        let output = '';\n        // Header\n        if (includeMetadata) {\n            output += this.formatHeader(context);\n            output += '\\n\\n';\n        }\n        // User message\n        output += this.formatMessageContent(userMessage, format);\n        output += '\\n\\n';\n        // Assistant message\n        output += this.formatMessageContent(assistantMessage, format);\n        // Footer\n        if (includeMetadata) {\n            output += '\\n\\n';\n            output += this.formatFooter();\n        }\n        await clipboard.write(output);\n        return output.length;\n    }\n    /**\n     * Read from system clipboard\n     */\n    async readClipboard() {\n        try {\n            return await clipboard.read();\n        }\n        catch (error) {\n            console.error('Failed to read clipboard:', error);\n            return '';\n        }\n    }\n    /**\n     * Format message header with metadata\n     */\n    formatHeader(context) {\n        return [\n            `---`,\n            `**Session**: ${context.sessionDate}`,\n            `**Working Directory**: \\`${context.workdir}\\``,\n            `**Provider**: ${context.provider} (${context.model})`,\n            `---`,\n        ].join('\\n');\n    }\n    /**\n     * Format message footer\n     */\n    formatFooter() {\n        return `*Copied from Grok CLI*`;\n    }\n    /**\n     * Format single message with metadata\n     */\n    formatMessage(message, context, options) {\n        let output = '';\n        // Header\n        if (options.includeMetadata) {\n            output += this.formatHeader(context);\n            output += '\\n\\n';\n        }\n        // Content\n        output += this.formatMessageContent(message, options.format);\n        // Footer\n        if (options.includeMetadata) {\n            output += '\\n\\n';\n            output += this.formatFooter();\n        }\n        return output;\n    }\n    /**\n     * Format message content based on role\n     */\n    formatMessageContent(message, format) {\n        const roleIcon = message.role === 'user' ? 'üë§' : 'ü§ñ';\n        const roleLabel = message.role === 'user' ? 'User' : 'Assistant';\n        if (format === 'markdown') {\n            return [\n                `### ${roleIcon} ${roleLabel}`,\n                '',\n                message.content,\n            ].join('\\n');\n        }\n        // Plain format\n        return [\n            `${roleIcon} ${roleLabel}:`,\n            message.content,\n        ].join('\\n');\n    }\n    /**\n     * Check if clipboard functionality is available\n     */\n    async isAvailable() {\n        try {\n            await clipboard.read();\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\nexport const clipboardManager = new ClipboardManager();\n//# sourceMappingURL=clipboard-manager.js.map"
  },
  "dist/utils/help-formatter.js": {
    "path": "dist/utils/help-formatter.js",
    "hash": "9b3ff10dd893f66dcda24a0f388d89ffdda52a6e2f535afc41fa6a86ba267bf6",
    "size": 22674,
    "timestamp": 1764704879300,
    "content": "import chalk from 'chalk';\nimport { sessionManager } from './session-manager-sqlite.js';\n/**\n * Modern help formatter with beautiful tables and colors\n * Dashboard Style (Option 5) - 2025 Edition\n */\nexport class HelpFormatter {\n    /**\n     * Generate the main help dashboard\n     */\n    static generateHelp(agent) {\n        const currentSession = sessionManager.getCurrentSession();\n        const currentModel = agent?.getCurrentModel() || 'N/A';\n        const currentCwd = process.cwd();\n        // Session info\n        const sessionInfo = currentSession\n            ? `#${currentSession.id} (${currentSession.message_count || 0} msg)`\n            : 'No session';\n        let help = '';\n        // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n        // ‚ïë                    HEADER WITH STATUS BAR                                  ‚ïë\n        // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n        help += chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n');\n        help += chalk.cyan('‚ïë') + chalk.yellow.bold('                    üöÄ GROKINOU CLI v2.0 - COMMAND CENTER                   ') + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïë') + chalk.yellow('                    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ                      ') + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïë') + chalk.gray(`  Session: ${sessionInfo} ‚îÇ Model: ${currentModel}              `) + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ QUICK START                                                                ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' üìö QUICK START                                                             ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  üí¨ Chat normally                    ‚Üí Just type your message              ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  üìÇ New project                      ‚Üí /new-session ~/project --clone-git  ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  ‚è∞ Time travel                      ‚Üí /rewind \"2025-11-28T10:00:00Z\"      ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  üîç Search history                   ‚Üí /search <query>                     ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  ü§ñ Change model                     ‚Üí /models                             ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ CORE COMMANDS                                                              ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' üîß CORE COMMANDS                                                           ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Command          ') + chalk.cyan('‚îÇ') + chalk.white(' What it does                                            ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /help [cmd]      ') + chalk.cyan('‚îÇ') + chalk.white(' Show help (this screen) or specific command help       ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /status          ') + chalk.cyan('‚îÇ') + chalk.white(' Current config (model, provider, session, API keys)    ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /clear           ') + chalk.cyan('‚îÇ') + chalk.white(' Clear chat history (memory + disk)                     ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /exit            ') + chalk.cyan('‚îÇ') + chalk.white(' Quit Grokinou                                           ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ SESSIONS (Git-like branches for conversations)                            ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' üóÇÔ∏è  SESSIONS (Git-like branches for conversations)                        ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /list_sessions   ') + chalk.cyan('‚îÇ') + chalk.white(' List all sessions in current directory                 ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /switch-session  ') + chalk.cyan('‚îÇ') + chalk.white(' Switch to different session: /switch-session 5          ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /rename_session  ') + chalk.cyan('‚îÇ') + chalk.white(' Rename current session: /rename_session my-project     ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /new-session     ') + chalk.cyan('‚îÇ') + chalk.white(' Create new session (see full options below)            ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        help += '\\n';\n        // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        // ‚îÇ üì¶ /new-session - Full Options                                      ‚îÇ\n        // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n        help += chalk.blue('   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.magenta.bold(' üì¶ /new-session - Full Options                                      ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.yellow(' Init Mode    ') + chalk.blue('‚îÇ') + chalk.white(' --clone-git ‚îÇ --copy-files ‚îÇ --from-rewind <time>  ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.yellow(' History      ') + chalk.blue('‚îÇ') + chalk.white(' --import-history --from-session <id> --date-range   ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.yellow(' Model        ') + chalk.blue('‚îÇ') + chalk.white(' --model <name> --provider <name>                     ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ TIMELINE & TIME MACHINE (Event Sourcing)                                  ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' ‚è∞ TIMELINE & TIME MACHINE (Event Sourcing)                                ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /timeline        ') + chalk.cyan('‚îÇ') + chalk.white(' Query events: /timeline --type FILE --since today      ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /rewind          ') + chalk.cyan('‚îÇ') + chalk.white(' Time travel: /rewind \"2025-11-28T10:00:00Z\"            ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /snapshots       ') + chalk.cyan('‚îÇ') + chalk.white(' List available rewind points                           ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' /rewind-history  ') + chalk.cyan('‚îÇ') + chalk.white(' Show past rewind operations                            ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        help += '\\n';\n        // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        // ‚îÇ ‚öôÔ∏è  /rewind Git Modes Compared                                       ‚îÇ\n        // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n        help += chalk.blue('   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.magenta.bold(' ‚öôÔ∏è  /rewind Git Modes Compared                                       ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.yellow(' Mode     ') + chalk.blue('‚îÇ') + chalk.yellow(' Speed      ') + chalk.blue('‚îÇ') + chalk.yellow(' What you get    ') + chalk.blue('‚îÇ') + chalk.yellow(' Best for                 ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.white(' none     ') + chalk.blue('‚îÇ') + chalk.green(' ‚ö°‚ö°‚ö°     ') + chalk.blue('‚îÇ') + chalk.white(' Files only      ') + chalk.blue('‚îÇ') + chalk.white(' Quick preview            ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.white(' metadata ') + chalk.blue('‚îÇ') + chalk.green(' ‚ö°‚ö°       ') + chalk.blue('‚îÇ') + chalk.white(' + git state     ') + chalk.blue('‚îÇ') + chalk.cyan(' Audit trail (default ‚úì) ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îÇ') + chalk.white(' full     ') + chalk.blue('‚îÇ') + chalk.yellow(' ‚ö°         ') + chalk.blue('‚îÇ') + chalk.white(' + complete .git ') + chalk.blue('‚îÇ') + chalk.white(' Continue development     ') + chalk.blue('‚îÇ\\n');\n        help += chalk.blue('   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ KEYBOARD SHORTCUTS                                                         ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' ‚å®Ô∏è  KEYBOARD SHORTCUTS                                                     ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Ctrl+E           ') + chalk.cyan('‚îÇ') + chalk.white(' Toggle Execution Viewer (hide/split/fullscreen)        ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Ctrl+F           ') + chalk.cyan('‚îÇ') + chalk.white(' Fullscreen Execution Viewer                            ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Ctrl+C           ') + chalk.cyan('‚îÇ') + chalk.white(' Cancel / Clear input                                   ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' ‚Üë / ‚Üì            ') + chalk.cyan('‚îÇ') + chalk.white(' Navigate command history                               ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Tab              ') + chalk.cyan('‚îÇ') + chalk.white(' Autocomplete commands                                  ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.green(' Shift+Tab        ') + chalk.cyan('‚îÇ') + chalk.white(' Toggle auto-edit mode (bypass confirmations)           ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        help += '\\n';\n        // ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n        // ‚îÇ üí° TIPS                                                                    ‚îÇ\n        // ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n        help += chalk.cyan('‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.yellow.bold(' üí° TIPS                                                                    ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  ‚Ä¢ Full docs: cat HELP.md or visit github.com/zackbeyond/grok-cli         ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  ‚Ä¢ Execution Viewer: Press Ctrl+E to see LLM\\'s thinking + command output ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚îÇ') + chalk.white('  ‚Ä¢ Need help? Type: /help <command> (ex: /help rewind)                   ') + chalk.cyan('‚îÇ\\n');\n        help += chalk.cyan('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\\n');\n        return help;\n    }\n    /**\n     * Generate help for a specific command\n     */\n    static generateCommandHelp(command) {\n        switch (command) {\n            case 'rewind':\n                return this.generateRewindHelp();\n            case 'timeline':\n                return this.generateTimelineHelp();\n            case 'new-session':\n                return this.generateNewSessionHelp();\n            case 'snapshots':\n                return this.generateSnapshotsHelp();\n            default:\n                return chalk.red(`‚ùå No detailed help available for: ${command}\\n\\n`) +\n                    chalk.gray(`Use /help to see all commands`);\n        }\n    }\n    /**\n     * Generate detailed help for /rewind command\n     */\n    static generateRewindHelp() {\n        let help = '';\n        help += chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n');\n        help += chalk.cyan('‚ïë') + chalk.yellow.bold('                         ‚è∞ /REWIND - TIME MACHINE                          ') + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n');\n        help += '\\n';\n        help += chalk.white('Reconstruct your project\\'s exact state at any point in time.\\n');\n        help += chalk.white('Non-destructive: creates a new directory with the rewinded state.\\n\\n');\n        help += chalk.yellow('üìã Usage:\\n');\n        help += chalk.gray('  /rewind <timestamp> [options]\\n\\n');\n        help += chalk.yellow('üîß Options:\\n');\n        help += chalk.green('  <timestamp>         ') + chalk.white('Target time (ISO: \"2025-11-28T12:00:00Z\")\\n');\n        help += chalk.green('  --output <dir>      ') + chalk.white('Custom output directory (default: .rewind_*)\\n');\n        help += chalk.green('  --git-mode <mode>   ') + chalk.white('Git materialization:\\n');\n        help += chalk.gray('      none            ') + chalk.white('No git (just files + conversations)\\n');\n        help += chalk.gray('      metadata        ') + chalk.white('git_state.json only (fast, default)\\n');\n        help += chalk.gray('      full            ') + chalk.white('Complete .git repo you can work with (slow)\\n');\n        help += chalk.green('  --auto-checkout     ') + chalk.white('Automatically cd to rewinded directory after rewind\\n');\n        help += chalk.green('  --compare-with <dir>') + chalk.white('Compare rewinded state with another directory\\n');\n        help += chalk.green('  --no-files          ') + chalk.white('Don\\'t restore file contents\\n');\n        help += chalk.green('  --no-conversations  ') + chalk.white('Don\\'t restore chat history\\n\\n');\n        help += chalk.yellow('üìö Examples:\\n');\n        help += chalk.gray('  /rewind \"2025-11-28T10:00:00Z\"\\n');\n        help += chalk.gray('  /rewind \"2025-11-27T18:00:00Z\" --output ~/recovered\\n');\n        help += chalk.gray('  /rewind \"2025-11-28T12:00:00Z\" --git-mode full --auto-checkout\\n');\n        help += chalk.gray('  /rewind \"2025-11-28T12:00:00Z\" --compare-with ~/current-project\\n\\n');\n        help += chalk.blue('üí° See /snapshots for available rewind points\\n');\n        return help;\n    }\n    /**\n     * Generate detailed help for /timeline command\n     */\n    static generateTimelineHelp() {\n        let help = '';\n        help += chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n');\n        help += chalk.cyan('‚ïë') + chalk.yellow.bold('                       üìÖ /TIMELINE - EVENT QUERY                           ') + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n');\n        help += '\\n';\n        help += chalk.white('Query the complete event log of your project.\\n\\n');\n        help += chalk.yellow('üìã Usage:\\n');\n        help += chalk.gray('  /timeline [options]\\n\\n');\n        help += chalk.yellow('üîß Options:\\n');\n        help += chalk.green('  --start <time>      ') + chalk.white('Start time (ISO or relative: \"2 hours ago\")\\n');\n        help += chalk.green('  --end <time>        ') + chalk.white('End time\\n');\n        help += chalk.green('  --category <cat>    ') + chalk.white('Filter: SESSION, LLM, TOOL, FILE, GIT, REWIND\\n');\n        help += chalk.green('  --session <id>      ') + chalk.white('Filter by session ID\\n');\n        help += chalk.green('  --limit <n>         ') + chalk.white('Max results (default: 100)\\n');\n        help += chalk.green('  --search <text>     ') + chalk.white('Search text in event payloads\\n');\n        help += chalk.green('  --stats             ') + chalk.white('Show statistics only\\n\\n');\n        help += chalk.yellow('üìö Examples:\\n');\n        help += chalk.gray('  /timeline --category FILE --limit 20\\n');\n        help += chalk.gray('  /timeline --start \"2025-11-28T10:00:00Z\" --category GIT\\n');\n        help += chalk.gray('  /timeline --session 5 --stats\\n');\n        help += chalk.gray('  /timeline --search \"error\" --limit 10\\n');\n        return help;\n    }\n    /**\n     * Generate detailed help for /new-session command\n     */\n    static generateNewSessionHelp() {\n        let help = '';\n        help += chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n');\n        help += chalk.cyan('‚ïë') + chalk.yellow.bold('                    üóÇÔ∏è  /NEW-SESSION - CREATE SESSION                      ') + chalk.cyan('‚ïë\\n');\n        help += chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n');\n        help += '\\n';\n        help += chalk.white('Create a new conversation session (Git-like branching).\\n\\n');\n        help += chalk.yellow('üìã Usage:\\n');\n        help += chalk.gray('  /new-session [options]\\n\\n');\n        help += chalk.yellow('üìÅ Directory Options:\\n');\n        help += chalk.green('  --directory <path>     ') + chalk.white('Create session in different directory\\n\\n');\n        help += chalk.yellow('üîÑ Initialization Options (choose one):\\n');\n        help += chalk.green('  --clone-git            ') + chalk.white('Clone current Git repository to target directory\\n');\n        help += chalk.green('  --copy-files           ') + chalk.white('Copy files from current directory (excluding .git)\\n');\n        help += chalk.green('  --from-rewind <time>   ') + chalk.white('Initialize from a rewind state (uses event sourcing)\\n\\n');\n        help += chalk.yellow('üí¨ History Import Options:\\n');\n        help += chalk.green('  --import-history       ') + chalk.white('Import messages from source session\\n');\n        help += chalk.green('  --from-session <id>    ') + chalk.white('Import from specific session (default: current)\\n');\n        help += chalk.green('  --from-date <date>     ') + chalk.white('Import messages from this date onwards\\n');\n        help += chalk.green('  --to-date <date>       ') + chalk.white('Import messages up to this date\\n');\n        help += chalk.green('  --date-range <s> <e>   ') + chalk.white('Import messages between dates\\n\\n');\n        help += chalk.yellow('ü§ñ Model Options:\\n');\n        help += chalk.green('  --model <name>         ') + chalk.white('Start with specific model\\n');\n        help += chalk.green('  --provider <name>      ') + chalk.white('Start with specific provider\\n\\n');\n        help += chalk.yellow('üìö Examples:\\n');\n        help += chalk.gray('  /new-session --directory ~/project --clone-git\\n');\n        help += chalk.gray('  /new-session --copy-files --import-history\\n');\n        help += chalk.gray('  /new-session --from-rewind \"2025-11-28T10:00:00Z\" --directory ~/recovered\\n');\n        help += chalk.gray('  /new-session --from-session 5 --date-range 01/11/2025 03/11/2025\\n');\n        return help;\n    }\n    /**\n     * Generate help for /snapshots command\n     */\n    static generateSnapshotsHelp() {\n        return chalk.cyan('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n') +\n            chalk.cyan('‚ïë') + chalk.yellow.bold('                      üì∏ /SNAPSHOTS - REWIND POINTS                         ') + chalk.cyan('‚ïë\\n') +\n            chalk.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n') +\n            '\\n' +\n            chalk.white('List all available time points for rewinding.\\n\\n') +\n            chalk.yellow('üìã Usage:\\n') +\n            chalk.gray('  /snapshots\\n\\n') +\n            chalk.blue('üí° Use /rewind <timestamp> to time-travel to any point\\n');\n    }\n}\n//# sourceMappingURL=help-formatter.js.map"
  },
  "dist/utils/session-manager-sqlite.js": {
    "path": "dist/utils/session-manager-sqlite.js",
    "hash": "f45230def7744fbb8fa7e8a75300173c1d2aaaef2a910b9ba5ab8f75f0bb6db1",
    "size": 25309,
    "timestamp": 1764704879300,
    "content": "import { db } from '../db/database.js';\nimport { SessionRepository } from '../db/repositories/session-repository.js';\nimport { MessageRepository } from '../db/repositories/message-repository.js';\nimport crypto from 'crypto';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { getSessionHook } from '../timeline/hooks/session-hook.js';\n/**\n * Session-specific debug logger\n */\nclass SessionDebugLogger {\n    logPath;\n    constructor() {\n        const logDir = path.join(os.homedir(), '.grok');\n        this.logPath = path.join(logDir, 'debug_session.log');\n        // Clear log on startup\n        try {\n            if (!fs.existsSync(logDir)) {\n                fs.mkdirSync(logDir, { recursive: true });\n            }\n            fs.writeFileSync(this.logPath, `=== Session Debug Log - ${new Date().toISOString()} ===\\n`);\n        }\n        catch (error) {\n            // Ignore errors\n        }\n    }\n    log(...args) {\n        try {\n            const timestamp = new Date().toISOString();\n            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');\n            fs.appendFileSync(this.logPath, `[${timestamp}] ${message}\\n`);\n        }\n        catch (error) {\n            // Ignore errors\n        }\n    }\n}\nconst sessionDebugLog = new SessionDebugLogger();\n/**\n * Singleton for managing SQLite-based sessions\n */\nexport class SessionManagerSQLite {\n    static instance;\n    sessionRepo;\n    messageRepo;\n    currentSession = null;\n    currentProvider = 'grok';\n    currentModel = 'grok-code-fast-1';\n    sessionHook = getSessionHook();\n    constructor() {\n        this.sessionRepo = new SessionRepository(db.getDb());\n        this.messageRepo = new MessageRepository(db.getDb());\n    }\n    static getInstance() {\n        if (!SessionManagerSQLite.instance) {\n            SessionManagerSQLite.instance = new SessionManagerSQLite();\n        }\n        return SessionManagerSQLite.instance;\n    }\n    /**\n     * Initialize or resume session for current working directory\n     */\n    initSession(workdir, provider, model, apiKey) {\n        const apiKeyHash = apiKey ? this.hashApiKey(apiKey) : undefined;\n        this.currentProvider = provider;\n        this.currentModel = model;\n        sessionDebugLog.log(`üîç [initSession] CALLED with:`);\n        sessionDebugLog.log(`   workdir=\"${workdir}\"`);\n        sessionDebugLog.log(`   provider=\"${provider}\"`);\n        sessionDebugLog.log(`   model=\"${model}\"`);\n        sessionDebugLog.log(`   apiKeyHash=\"${apiKeyHash?.substring(0, 8)}...\"`);\n        // Try to find existing session by workdir first (for continuity)\n        const existingSession = this.sessionRepo.findLastSessionByWorkdir(workdir);\n        if (existingSession) {\n            sessionDebugLog.log(`üîç [initSession] existingSession FOUND:`);\n            sessionDebugLog.log(`   id=${existingSession.id}`);\n            sessionDebugLog.log(`   status=\"${existingSession.status}\"`);\n            sessionDebugLog.log(`   default_provider=\"${existingSession.default_provider}\"`);\n            sessionDebugLog.log(`   default_model=\"${existingSession.default_model}\"`);\n            sessionDebugLog.log(`   working_dir=\"${existingSession.working_dir}\"`);\n        }\n        else {\n            sessionDebugLog.log(`üîç [initSession] existingSession: NULL`);\n        }\n        if (existingSession) {\n            // Reuse existing session, update provider/model if changed\n            sessionDebugLog.log(`‚úÖ [initSession] Reusing existing session ${existingSession.id}`);\n            this.sessionRepo.updateSessionProviderAndModel(existingSession.id, provider, model, apiKeyHash);\n            this.currentSession = this.sessionRepo.findById(existingSession.id);\n            sessionDebugLog.log(`‚úÖ [initSession] Session updated successfully:`);\n            sessionDebugLog.log(`   id=${this.currentSession.id}`);\n            sessionDebugLog.log(`   status=\"${this.currentSession.status}\"`);\n            sessionDebugLog.log(`   default_provider=\"${this.currentSession.default_provider}\"`);\n            sessionDebugLog.log(`   default_model=\"${this.currentSession.default_model}\"`);\n        }\n        else {\n            // No existing session, create new one\n            sessionDebugLog.log(`üÜï [initSession] No existing session, calling findOrCreate()`);\n            this.currentSession = this.sessionRepo.findOrCreate(workdir, provider, model, apiKeyHash);\n            sessionDebugLog.log(`üÜï [initSession] New session created: id=${this.currentSession.id}`);\n            // üïê Timeline: Capture session created\n            try {\n                this.sessionHook.captureSessionCreated(this.currentSession.id, this.currentSession.session_name, workdir, model, provider).catch(err => sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed:', err));\n            }\n            catch (error) {\n                sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed for session created:', error);\n            }\n        }\n        sessionDebugLog.log(`‚úÖ [initSession] FINAL currentSession: id=${this.currentSession.id}\\n`);\n        return this.currentSession;\n    }\n    /**\n     * Create a new session (Git-like branching for conversations)\n     *\n     * @param workdir - Working directory for the new session (can be different from current)\n     * @param provider - AI provider (e.g., 'openai', 'grok')\n     * @param model - Model name (e.g., 'gpt-4o')\n     * @param apiKey - Optional API key (will be hashed)\n     * @param options - Import options\n     *   - importHistory: Copy all messages from source session\n     *   - fromSessionId: Import from specific session (default: current session)\n     *   - dateRange: { start: Date, end: Date } - Filter messages by date\n     * @returns The newly created session and its history\n     */\n    async createNewSession(workdir, provider, model, apiKey, options) {\n        const apiKeyHash = apiKey ? this.hashApiKey(apiKey) : undefined;\n        const importHistory = options?.importHistory || false;\n        const fromSessionId = options?.fromSessionId;\n        const dateRange = options?.dateRange;\n        sessionDebugLog.log(`üÜï [createNewSession] CALLED with:`);\n        sessionDebugLog.log(`   workdir=\"${workdir}\"`);\n        sessionDebugLog.log(`   provider=\"${provider}\"`);\n        sessionDebugLog.log(`   model=\"${model}\"`);\n        sessionDebugLog.log(`   importHistory=${importHistory}`);\n        sessionDebugLog.log(`   fromSessionId=${fromSessionId}`);\n        sessionDebugLog.log(`   dateRange=${dateRange ? `${dateRange.start} ‚Üí ${dateRange.end}` : 'none'}`);\n        // Determine source session for history import\n        let sourceSession = null;\n        if (importHistory) {\n            if (fromSessionId) {\n                // Import from specific session\n                sourceSession = this.sessionRepo.findById(fromSessionId);\n                if (!sourceSession) {\n                    throw new Error(`Source session not found: ${fromSessionId}`);\n                }\n                sessionDebugLog.log(`üìã [createNewSession] Importing from session ${fromSessionId}`);\n            }\n            else {\n                // Import from current session\n                sourceSession = this.currentSession;\n                if (!sourceSession) {\n                    throw new Error('No current session to import from. Use --from-session <id>');\n                }\n                sessionDebugLog.log(`üìã [createNewSession] Importing from current session ${sourceSession.id}`);\n            }\n        }\n        // Force creation of a new session (don't reuse existing)\n        const newSession = this.sessionRepo.create(workdir, provider, model, apiKeyHash);\n        sessionDebugLog.log(`‚úÖ [createNewSession] New session created: id=${newSession.id}`);\n        // Update current session reference\n        this.currentSession = newSession;\n        this.currentProvider = provider;\n        this.currentModel = model;\n        let history = [];\n        // Import history from source session if requested\n        let importWarning;\n        if (importHistory && sourceSession) {\n            sessionDebugLog.log(`üìã [createNewSession] Importing history from session ${sourceSession.id}`);\n            let messages = this.messageRepo.getBySession(sourceSession.id);\n            const originalCount = messages.length;\n            // Calculate actual date range of messages (for warning)\n            let actualMinDate = null;\n            let actualMaxDate = null;\n            if (messages.length > 0) {\n                const timestamps = messages.map(m => new Date(m.timestamp).getTime());\n                actualMinDate = new Date(Math.min(...timestamps));\n                actualMaxDate = new Date(Math.max(...timestamps));\n            }\n            // Filter by date range if specified\n            if (dateRange) {\n                const startTime = dateRange.start.getTime();\n                const endTime = dateRange.end.getTime();\n                messages = messages.filter(msg => {\n                    const msgTime = new Date(msg.timestamp).getTime();\n                    return msgTime >= startTime && msgTime <= endTime;\n                });\n                sessionDebugLog.log(`üìÖ [createNewSession] Date filter: ${originalCount} ‚Üí ${messages.length} messages`);\n                sessionDebugLog.log(`   Range: ${dateRange.start.toISOString()} ‚Üí ${dateRange.end.toISOString()}`);\n                // Warning if date range excluded all messages\n                if (messages.length === 0 && originalCount > 0 && actualMinDate && actualMaxDate) {\n                    const formatDate = (date) => {\n                        return date.toLocaleDateString('en-US', {\n                            year: 'numeric',\n                            month: '2-digit',\n                            day: '2-digit'\n                        });\n                    };\n                    importWarning =\n                        `‚ö†Ô∏è  Date range excluded all ${originalCount} messages!\\n\\n` +\n                            `   Requested range:\\n` +\n                            `      ${formatDate(dateRange.start)} ‚Üí ${formatDate(dateRange.end)}\\n\\n` +\n                            `   Actual message range:\\n` +\n                            `      ${formatDate(actualMinDate)} ‚Üí ${formatDate(actualMaxDate)}\\n\\n` +\n                            `   üí° To import all messages, use:\\n` +\n                            `      /new-session --from-session ${sourceSession.id} --date-range ${formatDate(actualMinDate)} ${formatDate(actualMaxDate)}`;\n                    sessionDebugLog.log(`‚ö†Ô∏è  [createNewSession] ${importWarning}`);\n                }\n            }\n            // Copy filtered messages to new session\n            for (const message of messages) {\n                const newMessage = this.messageRepo.save({\n                    session_id: newSession.id,\n                    type: message.type,\n                    role: message.role,\n                    content: message.content,\n                    content_type: message.content_type,\n                    provider: message.provider,\n                    model: message.model,\n                    api_key_hash: message.api_key_hash,\n                    tool_calls: message.tool_calls,\n                    tool_call_id: message.tool_call_id,\n                    is_streaming: false,\n                    token_count: message.token_count,\n                    timestamp: new Date().toISOString() // Use current timestamp for imported messages\n                });\n                // Convert to ChatEntry\n                history.push(this.messageToEntry(newMessage));\n            }\n            sessionDebugLog.log(`‚úÖ [createNewSession] Imported ${messages.length} messages`);\n            // Update stats for the new session\n            this.sessionRepo.updateSessionStats(newSession.id);\n        }\n        sessionDebugLog.log(`‚úÖ [createNewSession] COMPLETE: session=${newSession.id}, history=${history.length} messages\\n`);\n        return { session: newSession, history, importWarning };\n    }\n    /**\n     * Get current session\n     */\n    getCurrentSession() {\n        return this.currentSession;\n    }\n    /**\n     * Find last session by working directory (for session restoration)\n     */\n    findLastSessionByWorkdir(workdir) {\n        return this.sessionRepo.findLastSessionByWorkdir(workdir);\n    }\n    /**\n     * List sessions with enriched metadata\n     *\n     * @param workdir - Filter by working directory (defaults to current, null = all directories)\n     * @param options - Additional filtering options\n     * @returns Array of enriched session list items\n     */\n    listSessions(workdir, options) {\n        // If workdir is explicitly null, don't filter by directory (list all)\n        // If workdir is undefined, default to current directory\n        // If workdir is a string, use that directory\n        const targetWorkdir = workdir === null ? null : (workdir || process.cwd());\n        return this.sessionRepo.listSessions(targetWorkdir, options);\n    }\n    /**\n     * Rename the specified session\n     * @param sessionId - Session ID to rename\n     * @param newName - New name for the session\n     */\n    renameSession(sessionId, newName) {\n        sessionDebugLog.log(`\\nüìù [renameSession] CALLED with:`);\n        sessionDebugLog.log(`   sessionId=${sessionId}`);\n        sessionDebugLog.log(`   newName=\"${newName}\"`);\n        // Get old name before update\n        const session = this.sessionRepo.findById(sessionId);\n        const oldName = session?.session_name || '';\n        this.sessionRepo.updateSessionName(sessionId, newName);\n        // Update current session cache if it's the one being renamed\n        if (this.currentSession && this.currentSession.id === sessionId) {\n            this.currentSession.session_name = newName;\n        }\n        // üïê Timeline: Capture session renamed\n        try {\n            this.sessionHook.captureSessionRenamed(sessionId, oldName, newName).catch(err => sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed:', err));\n        }\n        catch (error) {\n            sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed for session renamed:', error);\n        }\n        sessionDebugLog.log(`‚úÖ [renameSession] Session ${sessionId} renamed to \"${newName}\"`);\n    }\n    /**\n     * Switch to a different session\n     *\n     * @param sessionId - ID of the session to switch to\n     * @returns The new active session and its history\n     * @throws Error if session not found or on failure\n     */\n    async switchSession(sessionId) {\n        sessionDebugLog.log(`\\nüîÑ [switchSession] CALLED with sessionId=${sessionId}`);\n        const fromSessionId = this.currentSession?.id;\n        // Find the session\n        const targetSession = this.sessionRepo.findById(sessionId);\n        if (!targetSession) {\n            sessionDebugLog.log(`‚ùå [switchSession] Session ${sessionId} not found`);\n            throw new Error(`Session ${sessionId} not found`);\n        }\n        sessionDebugLog.log(`‚úÖ [switchSession] Target session found:`);\n        sessionDebugLog.log(`   working_dir=\"${targetSession.working_dir}\"`);\n        sessionDebugLog.log(`   provider=\"${targetSession.default_provider}\"`);\n        sessionDebugLog.log(`   model=\"${targetSession.default_model}\"`);\n        sessionDebugLog.log(`   status=\"${targetSession.status}\"`);\n        // Close current session if exists\n        if (this.currentSession) {\n            sessionDebugLog.log(`üìã [switchSession] Closing previous session ${this.currentSession.id}`);\n            this.sessionRepo.updateLastActivity(this.currentSession.id);\n        }\n        // Update target session to active\n        if (targetSession.status !== 'active') {\n            sessionDebugLog.log(`üîì [switchSession] Reactivating session ${sessionId}`);\n            this.sessionRepo.updateStatus(sessionId, 'active');\n            targetSession.status = 'active';\n        }\n        // Update current session reference\n        this.currentSession = targetSession;\n        this.currentProvider = targetSession.default_provider;\n        this.currentModel = targetSession.default_model;\n        // Update last activity\n        this.sessionRepo.updateLastActivity(sessionId);\n        // Load history from the new session\n        const messages = this.messageRepo.getBySession(sessionId);\n        const history = messages.map(this.messageToEntry);\n        sessionDebugLog.log(`‚úÖ [switchSession] Switched successfully:`);\n        sessionDebugLog.log(`   currentSession.id=${this.currentSession.id}`);\n        sessionDebugLog.log(`   currentProvider=\"${this.currentProvider}\"`);\n        sessionDebugLog.log(`   currentModel=\"${this.currentModel}\"`);\n        sessionDebugLog.log(`   history.length=${history.length}`);\n        // üïê Timeline: Capture session switched\n        if (fromSessionId) {\n            try {\n                this.sessionHook.captureSessionSwitched(fromSessionId, sessionId, targetSession.working_dir).catch(err => sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed:', err));\n            }\n            catch (error) {\n                sessionDebugLog.log('‚ö†Ô∏è  Timeline logging failed for session switch:', error);\n            }\n        }\n        return {\n            session: this.currentSession,\n            history\n        };\n    }\n    /**\n     * Load chat history from current session\n     */\n    async loadChatHistory() {\n        if (!this.currentSession) {\n            return [];\n        }\n        const messages = this.messageRepo.getBySession(this.currentSession.id);\n        return messages.map(this.messageToEntry);\n    }\n    /**\n     * Append chat entry to current session\n     */\n    async appendChatEntry(entry) {\n        if (!this.currentSession) {\n            throw new Error('No active session. Call initSession first.');\n        }\n        const message = await this.saveMessage(entry);\n        // Update session last activity\n        this.sessionRepo.updateLastActivity(this.currentSession.id);\n        // Update session stats (message_count, total_tokens, previews)\n        // This is fast (~1-5ms) and keeps denormalized fields fresh\n        this.sessionRepo.updateSessionStats(this.currentSession.id);\n        // Auto-generate session name from first user message\n        if (entry.type === 'user' && !this.currentSession.session_name) {\n            const sessionName = this.generateSessionName(entry.content);\n            this.sessionRepo.updateSessionName(this.currentSession.id, sessionName);\n            // Update cached session\n            this.currentSession.session_name = sessionName;\n        }\n    }\n    /**\n     * Save a message to the database\n     */\n    async saveMessage(entry) {\n        if (!this.currentSession) {\n            throw new Error('No active session');\n        }\n        const message = this.messageRepo.save({\n            session_id: this.currentSession.id,\n            type: entry.type,\n            role: this.getRole(entry.type),\n            content: entry.content,\n            provider: this.currentProvider,\n            model: this.currentModel,\n            timestamp: entry.timestamp.toISOString(),\n            tool_calls: entry.toolCalls,\n            tool_call_id: entry.toolCall?.id,\n            is_streaming: entry.isStreaming || false,\n        });\n        return message;\n    }\n    /**\n     * Convert message type to OpenAI role\n     */\n    getRole(type) {\n        switch (type) {\n            case 'user':\n                return 'user';\n            case 'assistant':\n                return 'assistant';\n            case 'tool_result':\n                return 'tool';\n            default:\n                return 'user';\n        }\n    }\n    /**\n     * Convert DB Message to ChatEntry\n     */\n    messageToEntry(message) {\n        return {\n            type: message.type,\n            content: message.content,\n            timestamp: new Date(message.timestamp),\n            toolCalls: message.tool_calls ? JSON.parse(message.tool_calls) : undefined,\n            toolCall: message.tool_call_id ? { id: message.tool_call_id } : undefined,\n            isStreaming: false,\n        };\n    }\n    /**\n     * Generate a session name from first user message\n     * Extracts meaningful text, cleans it, and truncates to 50 chars\n     *\n     * Examples:\n     *   \"Help me debug this React component\" ‚Üí \"Help me debug this React component\"\n     *   \"Create a new API endpoint\\nfor user management\" ‚Üí \"Create a new API endpoint for user manag...\"\n     *   \"/list_sessions\" ‚Üí \"list_sessions\"\n     *\n     * @param content - First user message content\n     * @returns Clean, readable session name\n     */\n    generateSessionName(content) {\n        if (!content || content.trim().length === 0) {\n            return 'New Session';\n        }\n        // Clean the content\n        let name = content\n            .replace(/[\\r\\n]+/g, ' ') // Replace newlines with spaces\n            .replace(/\\s{2,}/g, ' ') // Collapse multiple spaces\n            .replace(/[^\\w\\s\\-_.!?]/g, '') // Remove special chars except basic punctuation\n            .trim();\n        // Handle commands (starts with /)\n        if (name.startsWith('/')) {\n            name = name.substring(1); // Remove leading /\n        }\n        // Truncate to 50 characters\n        if (name.length > 50) {\n            name = name.substring(0, 47) + '...';\n        }\n        // Fallback if empty after cleaning\n        if (name.length === 0) {\n            return 'New Session';\n        }\n        return name;\n    }\n    /**\n     * Switch to a different provider in current session\n     */\n    switchProvider(provider, model, apiKey) {\n        this.currentProvider = provider;\n        this.currentModel = model;\n        // ‚úÖ Update session in database\n        if (this.currentSession) {\n            try {\n                const database = db.getDb();\n                database.prepare(`\n          UPDATE sessions \n          SET default_provider = ?, \n              default_model = ?,\n              last_activity = CURRENT_TIMESTAMP\n          WHERE id = ?\n        `).run(provider, model, this.currentSession.id);\n                // Update currentSession object\n                this.currentSession.default_provider = provider;\n                this.currentSession.default_model = model;\n                console.log(`‚úÖ Switched to ${provider} (${model}) - DB updated`);\n            }\n            catch (error) {\n                console.error(`‚ö†Ô∏è  Failed to update session in DB:`, error);\n                console.log(`‚úÖ Switched to ${provider} (${model}) - Memory only`);\n            }\n        }\n        else {\n            console.log(`‚úÖ Switched to ${provider} (${model}) - No active session`);\n        }\n    }\n    /**\n     * Close current session\n     */\n    closeSession() {\n        if (this.currentSession) {\n            this.sessionRepo.closeSession(this.currentSession.id);\n            this.currentSession = null;\n        }\n    }\n    /**\n     * Save session state (for backward compatibility)\n     */\n    async saveState(state) {\n        if (this.currentSession && state.model) {\n            // Update session title if it's new\n            if (!this.currentSession.title) {\n                this.sessionRepo.updateTitle(this.currentSession.id, `Session in ${this.currentSession.working_dir}`);\n            }\n        }\n    }\n    /**\n     * Load session state (for backward compatibility)\n     */\n    async loadState() {\n        if (!this.currentSession) {\n            return null;\n        }\n        return {\n            version: 1,\n            model: this.currentSession.default_model,\n            cwd: this.currentSession.working_dir,\n            sessionId: this.currentSession.id,\n        };\n    }\n    /**\n     * Clear session (close and delete all messages)\n     */\n    async clearSession() {\n        if (this.currentSession) {\n            this.messageRepo.deleteBySession(this.currentSession.id);\n            this.sessionRepo.closeSession(this.currentSession.id);\n            this.currentSession = null;\n        }\n    }\n    /**\n     * Hash API key for tracking (not storing the key itself!)\n     */\n    hashApiKey(apiKey) {\n        return crypto\n            .createHash('sha256')\n            .update(apiKey)\n            .digest('hex')\n            .substring(0, 16);\n    }\n    /**\n     * Get session statistics\n     */\n    getSessionStats(sessionId) {\n        const id = sessionId || this.currentSession?.id;\n        if (!id) {\n            return { messageCount: 0, providers: [] };\n        }\n        const messages = this.messageRepo.getBySession(id);\n        const providers = [...new Set(messages.map(m => m.provider))];\n        return {\n            messageCount: messages.length,\n            providers,\n        };\n    }\n}\n// Export singleton instance (for backward compatibility with old session-manager)\nexport const sessionManager = SessionManagerSQLite.getInstance();\n// Export functions that mimic old API\nexport async function loadChatHistory() {\n    return sessionManager.loadChatHistory();\n}\nexport async function appendChatEntry(entry) {\n    return sessionManager.appendChatEntry(entry);\n}\nexport async function saveState(state) {\n    return sessionManager.saveState(state);\n}\nexport async function loadState() {\n    return sessionManager.loadState();\n}\nexport async function clearSession() {\n    return sessionManager.clearSession();\n}\n//# sourceMappingURL=session-manager-sqlite.js.map"
  },
  "dist/utils/model-config.js": {
    "path": "dist/utils/model-config.js",
    "hash": "d8e5aea1b670a03c515fbd632091c0f465fc8691920cf29eb2b15b08cfae9e08",
    "size": 1178,
    "timestamp": 1764704879300,
    "content": "import { getSettingsManager } from './settings-manager.js';\n/**\n * Get the effective current model\n * Priority: project current model > user default model > system default\n */\nexport function getCurrentModel() {\n    const manager = getSettingsManager();\n    return manager.getCurrentModel();\n}\n/**\n * Load model configuration\n * Priority: user-settings.json models > default hardcoded\n */\nexport function loadModelConfig() {\n    const manager = getSettingsManager();\n    const models = manager.getAvailableModels();\n    return models.map(model => ({\n        model: model.trim()\n    }));\n}\n/**\n * Get default models list\n */\nexport function getDefaultModels() {\n    const manager = getSettingsManager();\n    return manager.getAvailableModels();\n}\n/**\n * Update the current model in project settings\n */\nexport function updateCurrentModel(modelName) {\n    const manager = getSettingsManager();\n    manager.setCurrentModel(modelName);\n}\n/**\n * Update the user's default model preference\n */\nexport function updateDefaultModel(modelName) {\n    const manager = getSettingsManager();\n    manager.updateUserSetting('defaultModel', modelName);\n}\n//# sourceMappingURL=model-config.js.map"
  },
  "dist/utils/status-message.js": {
    "path": "dist/utils/status-message.js",
    "hash": "62d49e4b83deffb26cbe391ae1b7a3fe82e592eac2ad9f847ad90f52ae67570f",
    "size": 4648,
    "timestamp": 1764704879300,
    "content": "import { providerManager } from './provider-manager.js';\nimport { sessionManager } from './session-manager-sqlite.js';\n/**\n * Generate session status message\n * Used by:\n * - /status command (in use-input-handler.ts)\n * - Startup message (in chat-interface.tsx)\n */\nexport function generateStatusMessage(agent) {\n    try {\n        const currentModel = agent.getCurrentModel();\n        const currentApiKey = agent.getApiKey();\n        const providerConfig = providerManager.getProviderForModel(currentModel);\n        // Get session with fallback for robustness\n        // After restart, currentSession might be null until initSession() is called\n        let session = sessionManager.getCurrentSession();\n        if (!session) {\n            // Fallback: try to find last session for current directory\n            const workdir = process.cwd();\n            session = sessionManager.findLastSessionByWorkdir(workdir);\n        }\n        // Format directory (shorten home path)\n        const homeDir = require('os').homedir();\n        const workdir = process.cwd();\n        const displayDir = workdir.replace(homeDir, '~');\n        // Format last activity\n        let lastActivityStr = 'Just now';\n        let messageCountStr = '0';\n        let sessionNameStr = '';\n        if (session) {\n            messageCountStr = String(session.message_count || 0);\n            if (session.session_name) {\n                sessionNameStr = `\\nüìù Session Name: ${session.session_name}`;\n            }\n            if (session.last_activity) {\n                const lastActivity = new Date(session.last_activity);\n                const now = new Date();\n                const diffMs = now.getTime() - lastActivity.getTime();\n                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n                const diffMins = Math.floor(diffMs / (1000 * 60));\n                if (diffDays > 0) {\n                    lastActivityStr = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\n                }\n                else if (diffHours > 0) {\n                    lastActivityStr = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\n                }\n                else if (diffMins > 0) {\n                    lastActivityStr = `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;\n                }\n            }\n        }\n        const statusEntry = {\n            type: \"assistant\",\n            content: `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\\n` +\n                `‚ïë  üìã SESSION STATUS                                     ‚ïë\\n` +\n                `‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\\n` +\n                `‚ïë  üìÇ Directory: ${displayDir}\\n` +\n                `‚ïë  ü§ñ Model: ${currentModel} (${providerConfig?.name || 'unknown'})\\n` +\n                `‚ïë  üîó Endpoint: ${providerConfig?.baseURL || 'unknown'}\\n` +\n                `‚ïë  üîë API Key: ${currentApiKey.slice(0, 10)}...${currentApiKey.slice(-4)}\\n` +\n                `‚ïë  üí¨ Messages: ${messageCountStr}\\n` +\n                `‚ïë  üìÖ Last activity: ${lastActivityStr}${sessionNameStr}\\n` +\n                `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\n\\n` +\n                `Available commands:\\n` +\n                `  /models           - List & switch models\\n` +\n                `  /model <name>     - Switch to specific model\\n` +\n                `  /apikey           - Manage API keys\\n` +\n                `  /list_sessions    - List all sessions\\n` +\n                `  /help             - Show all commands`,\n            timestamp: new Date(),\n        };\n        return statusEntry;\n    }\n    catch (error) {\n        // Fallback to basic status\n        const currentModel = agent.getCurrentModel();\n        const currentApiKey = agent.getApiKey();\n        const providerConfig = providerManager.getProviderForModel(currentModel);\n        const statusEntry = {\n            type: \"assistant\",\n            content: `üìä Current Configuration\\n` +\n                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                `ü§ñ Model: ${currentModel}\\n` +\n                `üìù Provider: ${providerConfig?.name || 'unknown'}\\n` +\n                `üîó Endpoint: ${providerConfig?.baseURL || 'unknown'}\\n` +\n                `üîë API Key: ${currentApiKey.slice(0, 10)}...${currentApiKey.slice(-4)}\\n` +\n                `üìÅ Work Dir: ${process.cwd()}\\n\\n` +\n                `Use /models to switch model\\n` +\n                `Use /apikey to manage API keys`,\n            timestamp: new Date(),\n        };\n        return statusEntry;\n    }\n}\n//# sourceMappingURL=status-message.js.map"
  },
  "dist/utils/input-history-manager.js": {
    "path": "dist/utils/input-history-manager.js",
    "hash": "e24e11617e1bb9f0f4024ba5d22344d95fc8d37b1cbf6e87879049aee3ab3ecb",
    "size": 1835,
    "timestamp": 1764704879300,
    "content": "import * as fs from \"node:fs\";\nimport * as fsp from \"node:fs/promises\";\nimport * as path from \"node:path\";\nimport * as os from \"node:os\";\nimport { getSettingsManager } from \"./settings-manager.js\";\nfunction getUserGrokDir() {\n    return path.join(os.homedir(), \".grok\");\n}\nfunction ensureDirSync(dir) {\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true, mode: 0o700 });\n    }\n}\nfunction getInputHistoryFile() {\n    const dir = getUserGrokDir();\n    ensureDirSync(dir);\n    return path.join(dir, \"input-history.jsonl\");\n}\nexport async function appendInputHistory(entry) {\n    try {\n        const manager = getSettingsManager();\n        const persist = manager.getUserSetting(\"persistInputHistory\");\n        if (persist === false)\n            return;\n    }\n    catch { }\n    const file = getInputHistoryFile();\n    await fsp.appendFile(file, JSON.stringify({ input: entry, ts: Date.now() }) + \"\\n\", {\n        encoding: \"utf-8\",\n        mode: 0o600,\n    });\n}\nexport async function loadInputHistory() {\n    try {\n        const manager = getSettingsManager();\n        const persist = manager.getUserSetting(\"persistInputHistory\");\n        if (persist === false)\n            return [];\n    }\n    catch { }\n    const file = getInputHistoryFile();\n    try {\n        const data = await fsp.readFile(file, \"utf-8\");\n        const lines = data.split(\"\\n\").filter(Boolean);\n        const items = [];\n        for (const line of lines) {\n            try {\n                const obj = JSON.parse(line);\n                if (typeof obj.input === \"string\")\n                    items.push(obj.input);\n            }\n            catch { }\n        }\n        return items;\n    }\n    catch (e) {\n        if (e && e.code === \"ENOENT\")\n            return [];\n        return [];\n    }\n}\n//# sourceMappingURL=input-history-manager.js.map"
  },
  "dist/utils/exec-async.js": {
    "path": "dist/utils/exec-async.js",
    "hash": "e2b580cc9def60c950b9923fe374b2870e0d9f52380bf04429b000f4eb6ae2ae",
    "size": 186,
    "timestamp": 1764704879300,
    "content": "/**\n * Async wrapper for exec\n */\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nexport const execAsync = promisify(exec);\n//# sourceMappingURL=exec-async.js.map"
  },
  "dist/utils/provider-manager.js": {
    "path": "dist/utils/provider-manager.js",
    "hash": "bf7d1ddb1cbc5cd572a979ea4488a3f40453d74bf85fc924c0fed5a2781d8211",
    "size": 9144,
    "timestamp": 1764704879300,
    "content": "/**\n * Provider Manager - Multi-provider support with auto-detection\n *\n * Features:\n * - Auto-detect provider from model name\n * - Manage API keys per provider\n * - Handle baseURL per provider\n * - Support: Grok, Claude, OpenAI, DeepSeek, Mistral\n */\nimport { getSettingsManager } from './settings-manager.js';\n/**\n * Default provider configurations\n */\nconst DEFAULT_PROVIDERS = {\n    grok: {\n        baseURL: 'https://api.x.ai/v1',\n        models: [\n            'grok-4-latest',\n            'grok-code-fast-1',\n            'grok-3-latest',\n            'grok-3-fast',\n            'grok-3-mini-fast',\n            'grok2-vision-beta',\n        ],\n    },\n    claude: {\n        baseURL: 'https://api.anthropic.com/v1',\n        models: [\n            'claude-sonnet-4-5-20250514',\n            'claude-3-5-sonnet-20241022',\n            'claude-3-5-haiku-20241022',\n            'claude-3-opus-20240229',\n            'claude-3-sonnet-20240229',\n        ],\n    },\n    openai: {\n        baseURL: 'https://api.openai.com/v1',\n        models: [\n            // GPT-5 (Latest)\n            'gpt-5',\n            'gpt-5-2025-08-07',\n            // O3 Reasoning (New)\n            'o3',\n            'o3-mini',\n            // O1 Reasoning\n            'o1',\n            'o1-preview',\n            'o1-mini',\n            // GPT-4o\n            'gpt-4o',\n            'gpt-4o-2024-11-20',\n            'gpt-4o-2024-08-06',\n            'gpt-4o-mini',\n            'gpt-4o-mini-2024-07-18',\n            'chatgpt-4o-latest',\n            // GPT-4 Turbo\n            'gpt-4-turbo',\n            'gpt-4-turbo-preview',\n            'gpt-4-turbo-2024-04-09',\n            'gpt-4',\n            // GPT-3.5\n            'gpt-3.5-turbo',\n            'gpt-3.5-turbo-0125',\n        ],\n    },\n    deepseek: {\n        baseURL: 'https://api.deepseek.com/v1',\n        models: [\n            'deepseek-chat',\n            'deepseek-coder',\n            'deepseek-reasoner',\n        ],\n    },\n    mistral: {\n        baseURL: 'https://api.mistral.ai/v1',\n        models: [\n            'mistral-large-latest',\n            'mistral-large-2407',\n            'mistral-medium-latest',\n            'mistral-small-latest',\n            'mistral-tiny',\n            'codestral-latest',\n            'codestral-2405',\n            'open-mistral-7b',\n            'open-mixtral-8x7b',\n            'open-mixtral-8x22b',\n        ],\n    },\n};\nexport class ProviderManager {\n    providers = new Map();\n    constructor() {\n        this.initializeProviders();\n    }\n    /**\n     * Initialize provider configurations from settings\n     */\n    initializeProviders() {\n        const settingsManager = getSettingsManager();\n        // Get API keys from user settings\n        const apiKeys = settingsManager.getApiKeys();\n        // Load provider configs (user can override in settings)\n        const userProviders = settingsManager.getProviders();\n        // Merge default providers with user overrides\n        for (const [name, defaultConfig] of Object.entries(DEFAULT_PROVIDERS)) {\n            const userConfig = userProviders?.[name];\n            this.providers.set(name, {\n                name,\n                baseURL: userConfig?.baseURL || defaultConfig.baseURL,\n                models: userConfig?.models || defaultConfig.models,\n                apiKey: apiKeys?.[name],\n            });\n        }\n        // Add any additional user-defined providers\n        if (userProviders) {\n            for (const [name, config] of Object.entries(userProviders)) {\n                if (!this.providers.has(name)) {\n                    this.providers.set(name, {\n                        name,\n                        baseURL: config.baseURL,\n                        models: config.models || [],\n                        apiKey: apiKeys?.[name],\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Detect provider from model name\n     */\n    detectProvider(modelName) {\n        // First, try exact match in provider models\n        for (const [providerName, config] of this.providers.entries()) {\n            if (config.models.includes(modelName)) {\n                return providerName;\n            }\n        }\n        // Fallback: heuristic detection from model name\n        const lowerModel = modelName.toLowerCase();\n        if (lowerModel.includes('grok'))\n            return 'grok';\n        if (lowerModel.includes('claude'))\n            return 'claude';\n        if (lowerModel.includes('gpt') || lowerModel.includes('o1'))\n            return 'openai';\n        if (lowerModel.includes('deepseek'))\n            return 'deepseek';\n        if (lowerModel.includes('mistral') || lowerModel.includes('codestral'))\n            return 'mistral';\n        // Default to grok if can't detect\n        return 'grok';\n    }\n    /**\n     * Get provider config by name\n     */\n    getProvider(name) {\n        return this.providers.get(name);\n    }\n    /**\n     * Get all registered providers\n     */\n    getAllProviders() {\n        const result = {};\n        for (const [name, config] of this.providers.entries()) {\n            result[name] = config;\n        }\n        return result;\n    }\n    /**\n     * Get provider config for a specific model\n     */\n    getProviderForModel(modelName) {\n        const providerName = this.detectProvider(modelName);\n        if (!providerName)\n            return null;\n        return this.getProvider(providerName) || null;\n    }\n    /**\n     * Check if provider has API key configured\n     */\n    hasApiKey(providerName) {\n        const provider = this.getProvider(providerName);\n        return !!provider?.apiKey;\n    }\n    /**\n     * Set API key for provider (in memory + persist)\n     */\n    setApiKey(providerName, apiKey) {\n        const provider = this.getProvider(providerName);\n        if (!provider) {\n            // Create provider if doesn't exist (for custom providers)\n            this.providers.set(providerName, {\n                name: providerName,\n                baseURL: DEFAULT_PROVIDERS[providerName]?.baseURL || 'https://api.example.com/v1',\n                models: DEFAULT_PROVIDERS[providerName]?.models || [],\n                apiKey,\n            });\n        }\n        else {\n            // Update existing provider\n            provider.apiKey = apiKey;\n        }\n        // Persist to user settings\n        const settingsManager = getSettingsManager();\n        settingsManager.setApiKey(providerName, apiKey);\n    }\n    /**\n     * Get masked API key for display (security)\n     */\n    getMaskedApiKey(providerName) {\n        const provider = this.getProvider(providerName);\n        if (!provider?.apiKey)\n            return 'Not configured';\n        const key = provider.apiKey;\n        if (key.length <= 8)\n            return '***';\n        // Show prefix and last 3 chars: sk-ant-***xxx\n        const firstDash = key.indexOf('-');\n        if (firstDash !== -1) {\n            return key.slice(0, firstDash + 1) + '***' + key.slice(-3);\n        }\n        // Fallback\n        return key.slice(0, 3) + '***' + key.slice(-3);\n    }\n    /**\n     * List all providers with status\n     */\n    listProviders() {\n        const result = [];\n        for (const [name, config] of this.providers.entries()) {\n            result.push({\n                name,\n                hasApiKey: !!config.apiKey,\n                maskedKey: this.getMaskedApiKey(name),\n                baseURL: config.baseURL,\n                modelCount: config.models.length,\n            });\n        }\n        // Sort: configured first, then alphabetically\n        return result.sort((a, b) => {\n            if (a.hasApiKey && !b.hasApiKey)\n                return -1;\n            if (!a.hasApiKey && b.hasApiKey)\n                return 1;\n            return a.name.localeCompare(b.name);\n        });\n    }\n    /**\n     * Format provider list for display\n     */\n    formatProviderList(currentProvider) {\n        const providers = this.listProviders();\n        let output = 'üîê API Keys Configuration:\\n\\n';\n        output += 'Configured Providers:\\n';\n        for (const provider of providers) {\n            const status = provider.hasApiKey ? '‚úÖ' : '‚ùå';\n            const active = provider.name === currentProvider ? ' (active)' : '';\n            const key = provider.hasApiKey ? provider.maskedKey : 'Not configured';\n            output += `  ${status} ${provider.name.padEnd(10)} - ${key}${active}\\n`;\n        }\n        output += '\\nUsage:\\n';\n        output += '  /apikey <provider> <key>  - Set API key for provider\\n';\n        output += '  /apikey show <provider>   - Show full key (for debugging)\\n';\n        output += '\\nExamples:\\n';\n        output += '  /apikey claude sk-ant-api03-xxx\\n';\n        output += '  /apikey openai sk-proj-xxx\\n';\n        return output;\n    }\n    /**\n     * Get all provider names\n     */\n    getProviderNames() {\n        return Array.from(this.providers.keys());\n    }\n    /**\n     * Reload providers from settings (after changes)\n     */\n    reload() {\n        this.providers.clear();\n        this.initializeProviders();\n    }\n}\n// Singleton instance\nexport const providerManager = new ProviderManager();\n//# sourceMappingURL=provider-manager.js.map"
  },
  "dist/utils/search-manager.js": {
    "path": "dist/utils/search-manager.js",
    "hash": "9a5d6ec904e3023b72da87646c3e74ea3326bdb9700c90806ed88defec0fd2d1",
    "size": 5780,
    "timestamp": 1764704879300,
    "content": "import { db } from '../db/database.js';\n/**\n * Manages search operations across conversation history\n */\nexport class SearchManager {\n    db;\n    constructor() {\n        this.db = db.getDb();\n    }\n    /**\n     * Search messages using LIKE (simple but functional)\n     */\n    search(options) {\n        const { query, sessionId, messageType, limit = 50, caseSensitive = false } = options;\n        // Build query\n        let sql = `\n      SELECT \n        m.*,\n        s.id as session_id,\n        s.working_dir,\n        s.default_provider,\n        s.default_model,\n        s.started_at\n      FROM messages m\n      JOIN sessions s ON m.session_id = s.id\n      WHERE m.content LIKE ?\n    `;\n        const params = [\n            caseSensitive ? `%${query}%` : `%${query}%`\n        ];\n        if (!caseSensitive) {\n            sql = sql.replace('m.content LIKE ?', 'LOWER(m.content) LIKE LOWER(?)');\n        }\n        if (sessionId) {\n            sql += ' AND m.session_id = ?';\n            params.push(sessionId);\n        }\n        if (messageType) {\n            sql += ' AND m.role = ?';\n            params.push(messageType);\n        }\n        sql += ' ORDER BY m.timestamp DESC LIMIT ?';\n        params.push(limit);\n        // Execute query\n        const stmt = this.db.prepare(sql);\n        const rows = stmt.all(...params);\n        // Enrich results\n        return rows.map(row => this.enrichResult(row, query));\n    }\n    /**\n     * Search in current session only\n     */\n    searchCurrentSession(query, sessionId, limit = 20) {\n        return this.search({\n            query,\n            sessionId,\n            limit,\n            caseSensitive: false,\n        });\n    }\n    /**\n     * Search globally across all sessions\n     */\n    searchGlobal(query, limit = 50) {\n        return this.search({\n            query,\n            limit,\n            caseSensitive: false,\n        });\n    }\n    /**\n     * Get total match count for a query\n     */\n    getMatchCount(query) {\n        const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count\n      FROM messages\n      WHERE LOWER(content) LIKE LOWER(?)\n    `);\n        const result = stmt.get(`%${query}%`);\n        return result.count;\n    }\n    /**\n     * Enrich search result with context and match positions\n     */\n    enrichResult(row, query) {\n        const message = {\n            id: row.id,\n            session_id: row.session_id,\n            type: row.type,\n            role: row.role,\n            content: row.content,\n            content_type: row.content_type,\n            provider: row.provider,\n            model: row.model,\n            api_key_hash: row.api_key_hash,\n            timestamp: row.timestamp,\n            token_count: row.token_count,\n            tool_calls: row.tool_calls,\n            tool_call_id: row.tool_call_id,\n            is_streaming: row.is_streaming,\n            parent_message_id: row.parent_message_id,\n        };\n        // Session info\n        const session = {\n            id: row.session_id,\n            workdir: row.working_dir,\n            provider: row.default_provider,\n            model: row.default_model,\n            sessionDate: this.formatDate(row.started_at),\n        };\n        // Find match positions\n        const matchPositions = this.findMatchPositions(row.content, query);\n        // Get context messages\n        const contextBefore = this.getContextMessage(row.id, row.session_id, 'before');\n        const contextAfter = this.getContextMessage(row.id, row.session_id, 'after');\n        return {\n            message,\n            session,\n            matchCount: matchPositions.length,\n            matchPositions,\n            contextBefore,\n            contextAfter,\n        };\n    }\n    /**\n     * Find all positions where query matches in text\n     */\n    findMatchPositions(text, query) {\n        const positions = [];\n        const lowerText = text.toLowerCase();\n        const lowerQuery = query.toLowerCase();\n        let pos = lowerText.indexOf(lowerQuery);\n        while (pos !== -1) {\n            positions.push(pos);\n            pos = lowerText.indexOf(lowerQuery, pos + 1);\n        }\n        return positions;\n    }\n    /**\n     * Get message before or after for context\n     */\n    getContextMessage(messageId, sessionId, direction) {\n        const operator = direction === 'before' ? '<' : '>';\n        const order = direction === 'before' ? 'DESC' : 'ASC';\n        const stmt = this.db.prepare(`\n      SELECT * FROM messages\n      WHERE session_id = ? AND id ${operator} ?\n      ORDER BY id ${order}\n      LIMIT 1\n    `);\n        const result = stmt.get(sessionId, messageId);\n        return result;\n    }\n    /**\n     * Format date for display\n     */\n    formatDate(isoString) {\n        const date = new Date(isoString);\n        const now = new Date();\n        const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));\n        if (diffDays === 0) {\n            return 'Today ' + date.toLocaleTimeString('en-US', {\n                hour: '2-digit',\n                minute: '2-digit'\n            });\n        }\n        else if (diffDays === 1) {\n            return 'Yesterday ' + date.toLocaleTimeString('en-US', {\n                hour: '2-digit',\n                minute: '2-digit'\n            });\n        }\n        else {\n            return date.toLocaleDateString('en-US', {\n                month: 'short',\n                day: 'numeric',\n                hour: '2-digit',\n                minute: '2-digit'\n            });\n        }\n    }\n    /**\n     * Get search suggestions based on recent queries (future feature)\n     */\n    getSuggestions(prefix, limit = 5) {\n        // TODO: Implement search history\n        return [];\n    }\n}\nexport const searchManager = new SearchManager();\n//# sourceMappingURL=search-manager.js.map"
  },
  "dist/utils/paste-manager.js": {
    "path": "dist/utils/paste-manager.js",
    "hash": "62c546010de7b7e93bea9d0891ce7600b64292a4db1cdef56de9c9addb6cc320",
    "size": 5437,
    "timestamp": 1764704879300,
    "content": "/**\n * Paste Manager - Handles large paste content with placeholder links\n *\n * Inspired by Codex implementation:\n * - Large pastes (>500 chars) are replaced with placeholders\n * - Placeholders are styled distinctly (cyan color)\n * - On submit, placeholders are expanded to full content\n * - Multiple pastes supported\n */\nexport const LARGE_PASTE_THRESHOLD = 500; // chars\nexport class PasteManager {\n    pendingPastes = new Map();\n    pasteCounter = 0;\n    /**\n     * Process pasted content and determine if it should be replaced with a placeholder\n     *\n     * @param content - The pasted content\n     * @returns Object with the text to insert and optional pending paste info\n     */\n    processPaste(content) {\n        const charCount = content.length;\n        // If content is small enough, insert normally\n        if (charCount <= LARGE_PASTE_THRESHOLD) {\n            // Normalize whitespace: replace newlines/tabs with single spaces\n            // to avoid rendering issues in single-line input\n            const normalizedContent = content\n                .replace(/[\\r\\n]+/g, ' ') // Replace newlines with spaces\n                .replace(/\\t/g, ' ') // Replace tabs with spaces\n                .replace(/\\s{2,}/g, ' '); // Collapse multiple spaces into one\n            return { textToInsert: normalizedContent, pendingPaste: null };\n        }\n        // Create placeholder for large content\n        this.pasteCounter++;\n        const id = `paste-${this.pasteCounter}-${Date.now()}`;\n        // Format character count with thousand separators for readability\n        const formattedCount = charCount.toLocaleString('en-US');\n        const placeholder = `[Pasted ${formattedCount} chars]`;\n        const pendingPaste = {\n            id,\n            placeholder,\n            content,\n            charCount,\n        };\n        this.pendingPastes.set(id, pendingPaste);\n        return { textToInsert: placeholder, pendingPaste };\n    }\n    /**\n     * Expand all placeholders in the given text to their full content\n     *\n     * @param text - The text containing placeholders\n     * @returns The text with all placeholders expanded\n     */\n    expandPlaceholders(text) {\n        let expandedText = text;\n        for (const [id, paste] of this.pendingPastes.entries()) {\n            if (expandedText.includes(paste.placeholder)) {\n                expandedText = expandedText.replace(paste.placeholder, paste.content);\n            }\n        }\n        return expandedText;\n    }\n    /**\n     * Clear all pending pastes (typically called after successful submission)\n     */\n    clearAll() {\n        this.pendingPastes.clear();\n    }\n    /**\n     * Remove a specific pending paste by its placeholder text\n     *\n     * @param placeholder - The placeholder text to remove\n     * @returns true if a paste was removed\n     */\n    removeByPlaceholder(placeholder) {\n        for (const [id, paste] of this.pendingPastes.entries()) {\n            if (paste.placeholder === placeholder) {\n                this.pendingPastes.delete(id);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given text is a paste placeholder\n     *\n     * @param text - The text to check\n     * @returns true if the text is a placeholder\n     */\n    isPlaceholder(text) {\n        for (const paste of this.pendingPastes.values()) {\n            if (paste.placeholder === text) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Find placeholder at the given position in the text\n     *\n     * @param text - The full text\n     * @param cursorPos - The cursor position\n     * @returns Placeholder info if found, null otherwise\n     */\n    findPlaceholderAtCursor(text, cursorPos) {\n        for (const paste of this.pendingPastes.values()) {\n            const { placeholder } = paste;\n            // Check if cursor is within a placeholder (cursor at end or inside)\n            let index = 0;\n            while ((index = text.indexOf(placeholder, index)) !== -1) {\n                const start = index;\n                const end = index + placeholder.length;\n                // Cursor is at the end of placeholder or inside it\n                if (cursorPos >= start && cursorPos <= end) {\n                    return { placeholder, start, end };\n                }\n                index += placeholder.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * Sync pending pastes with current text (remove placeholders no longer present)\n     *\n     * @param currentText - The current input text\n     */\n    syncWithText(currentText) {\n        const toRemove = [];\n        for (const [id, paste] of this.pendingPastes.entries()) {\n            if (!currentText.includes(paste.placeholder)) {\n                toRemove.push(id);\n            }\n        }\n        for (const id of toRemove) {\n            this.pendingPastes.delete(id);\n        }\n    }\n    /**\n     * Get all pending pastes\n     */\n    getPendingPastes() {\n        return Array.from(this.pendingPastes.values());\n    }\n    /**\n     * Check if there are any pending pastes\n     */\n    hasPendingPastes() {\n        return this.pendingPastes.size > 0;\n    }\n    /**\n     * Get the count of pending pastes\n     */\n    getPendingCount() {\n        return this.pendingPastes.size;\n    }\n}\n// Singleton instance\nexport const pasteManager = new PasteManager();\n//# sourceMappingURL=paste-manager.js.map"
  },
  "dist/utils/text-utils.js": {
    "path": "dist/utils/text-utils.js",
    "hash": "80e236ba12fc950027845e985810fa9f836b72aac4983b3e3f928a7b2e270022",
    "size": 5180,
    "timestamp": 1764704879300,
    "content": "/**\n * Text manipulation utilities for terminal input handling\n * Inspired by Gemini CLI's text processing capabilities\n */\n/**\n * Check if a character is a word boundary\n */\nexport function isWordBoundary(char) {\n    if (!char)\n        return true;\n    return /\\s/.test(char) || /[^\\w]/.test(char);\n}\n/**\n * Find the start of the current word at the given position\n */\nexport function findWordStart(text, position) {\n    if (position <= 0)\n        return 0;\n    let pos = position - 1;\n    while (pos > 0 && !isWordBoundary(text[pos])) {\n        pos--;\n    }\n    // If we stopped at a word boundary, move forward to the actual word start\n    if (pos > 0 && isWordBoundary(text[pos])) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Find the end of the current word at the given position\n */\nexport function findWordEnd(text, position) {\n    if (position >= text.length)\n        return text.length;\n    let pos = position;\n    while (pos < text.length && !isWordBoundary(text[pos])) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Move cursor to the previous word boundary\n */\nexport function moveToPreviousWord(text, position) {\n    if (position <= 0)\n        return 0;\n    let pos = position - 1;\n    // Skip whitespace\n    while (pos > 0 && isWordBoundary(text[pos])) {\n        pos--;\n    }\n    // Find start of the word\n    while (pos > 0 && !isWordBoundary(text[pos - 1])) {\n        pos--;\n    }\n    return pos;\n}\n/**\n * Move cursor to the next word boundary\n */\nexport function moveToNextWord(text, position) {\n    if (position >= text.length)\n        return text.length;\n    let pos = position;\n    // Skip current word\n    while (pos < text.length && !isWordBoundary(text[pos])) {\n        pos++;\n    }\n    // Skip whitespace\n    while (pos < text.length && isWordBoundary(text[pos])) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Delete the word before the cursor\n */\nexport function deleteWordBefore(text, position) {\n    const wordStart = moveToPreviousWord(text, position);\n    const newText = text.slice(0, wordStart) + text.slice(position);\n    return {\n        text: newText,\n        position: wordStart,\n    };\n}\n/**\n * Delete the word after the cursor\n */\nexport function deleteWordAfter(text, position) {\n    const wordEnd = moveToNextWord(text, position);\n    const newText = text.slice(0, position) + text.slice(wordEnd);\n    return {\n        text: newText,\n        position,\n    };\n}\n/**\n * Get the current line and column from text position\n */\nexport function getTextPosition(text, index) {\n    const lines = text.slice(0, index).split('\\n');\n    return {\n        index,\n        line: lines.length - 1,\n        column: lines[lines.length - 1].length,\n    };\n}\n/**\n * Move to the beginning of the current line\n */\nexport function moveToLineStart(text, position) {\n    const beforeCursor = text.slice(0, position);\n    const lastNewlineIndex = beforeCursor.lastIndexOf('\\n');\n    return lastNewlineIndex === -1 ? 0 : lastNewlineIndex + 1;\n}\n/**\n * Move to the end of the current line\n */\nexport function moveToLineEnd(text, position) {\n    const afterCursor = text.slice(position);\n    const nextNewlineIndex = afterCursor.indexOf('\\n');\n    return nextNewlineIndex === -1 ? text.length : position + nextNewlineIndex;\n}\n/**\n * Handle proper Unicode-aware character deletion\n */\nexport function deleteCharBefore(text, position) {\n    if (position <= 0) {\n        return { text, position };\n    }\n    // Handle surrogate pairs and combining characters\n    let deleteCount = 1;\n    const charBefore = text.charAt(position - 1);\n    // Check for high surrogate (first part of surrogate pair)\n    if (position >= 2) {\n        const charBeforeBefore = text.charAt(position - 2);\n        if (charBeforeBefore >= '\\uD800' && charBeforeBefore <= '\\uDBFF' &&\n            charBefore >= '\\uDC00' && charBefore <= '\\uDFFF') {\n            deleteCount = 2;\n        }\n    }\n    const newText = text.slice(0, position - deleteCount) + text.slice(position);\n    return {\n        text: newText,\n        position: position - deleteCount,\n    };\n}\n/**\n * Handle proper Unicode-aware character deletion forward\n */\nexport function deleteCharAfter(text, position) {\n    if (position >= text.length) {\n        return { text, position };\n    }\n    // Handle surrogate pairs and combining characters\n    let deleteCount = 1;\n    const charAfter = text.charAt(position);\n    // Check for high surrogate (first part of surrogate pair)\n    if (position + 1 < text.length) {\n        const charAfterAfter = text.charAt(position + 1);\n        if (charAfter >= '\\uD800' && charAfter <= '\\uDBFF' &&\n            charAfterAfter >= '\\uDC00' && charAfterAfter <= '\\uDFFF') {\n            deleteCount = 2;\n        }\n    }\n    const newText = text.slice(0, position) + text.slice(position + deleteCount);\n    return {\n        text: newText,\n        position,\n    };\n}\n/**\n * Insert text at the given position with proper Unicode handling\n */\nexport function insertText(text, position, insert) {\n    const newText = text.slice(0, position) + insert + text.slice(position);\n    return {\n        text: newText,\n        position: position + insert.length,\n    };\n}\n//# sourceMappingURL=text-utils.js.map"
  },
  "dist/utils/config.js": {
    "path": "dist/utils/config.js",
    "hash": "176e9d17094c90f5b69aa00a59f2f2e0f355d5c256a11e7778be72dd36092ceb",
    "size": 4341,
    "timestamp": 1764704879300,
    "content": "import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport * as os from \"node:os\";\n// Minimal TOML-like parser for simple key/value and [section] headers\nfunction parseTomlSimple(raw) {\n    const result = {};\n    let current = result;\n    const sectionStack = [];\n    const getOrCreatePath = (obj, path) => {\n        let node = obj;\n        for (const key of path) {\n            if (!node[key] || typeof node[key] !== \"object\")\n                node[key] = {};\n            node = node[key];\n        }\n        return node;\n    };\n    const lines = raw.split(/\\r?\\n/);\n    for (let line of lines) {\n        line = line.trim();\n        if (!line || line.startsWith(\"#\"))\n            continue;\n        if (line.startsWith(\"[\") && line.endsWith(\"]\")) {\n            const section = line.slice(1, -1).trim();\n            const parts = section.split(\".\").map((s) => s.trim()).filter(Boolean);\n            sectionStack.length = 0;\n            sectionStack.push(...parts);\n            current = getOrCreatePath(result, sectionStack);\n            continue;\n        }\n        const eq = line.indexOf(\"=\");\n        if (eq === -1)\n            continue;\n        const k = line.slice(0, eq).trim();\n        let v = line.slice(eq + 1).trim();\n        // strip comments at end\n        const hash = v.indexOf(\" #\");\n        if (hash !== -1)\n            v = v.slice(0, hash).trim();\n        // remove quotes if present\n        if ((v.startsWith('\"') && v.endsWith('\"')) || (v.startsWith(\"'\") && v.endsWith(\"'\"))) {\n            v = v.slice(1, -1);\n        }\n        else if (v === \"true\") {\n            v = true;\n        }\n        else if (v === \"false\") {\n            v = false;\n        }\n        else if (!isNaN(Number(v))) {\n            v = Number(v);\n        }\n        const target = getOrCreatePath(result, sectionStack);\n        target[k] = v;\n    }\n    return result;\n}\nfunction getConfigPath() {\n    const dir = path.join(os.homedir(), \".grok\");\n    return path.join(dir, \"config.toml\");\n}\nexport function loadTomlConfig() {\n    const p = getConfigPath();\n    if (!fs.existsSync(p))\n        return null;\n    try {\n        const raw = fs.readFileSync(p, \"utf-8\");\n        const parsed = parseTomlSimple(raw);\n        return parsed || null;\n    }\n    catch {\n        return null;\n    }\n}\n// Supports dot notation: a.b.c=value\nexport function applyKeyValue(overrides, key, value) {\n    const parts = key.split(\".\");\n    let cursor = overrides;\n    for (let i = 0; i < parts.length - 1; i++) {\n        const k = parts[i];\n        if (!cursor[k] || typeof cursor[k] !== \"object\")\n            cursor[k] = {};\n        cursor = cursor[k];\n    }\n    // Best-effort type coercion\n    const leaf = parts[parts.length - 1];\n    let coerced = value;\n    if (value === \"true\")\n        coerced = true;\n    else if (value === \"false\")\n        coerced = false;\n    else if (!isNaN(Number(value)))\n        coerced = Number(value);\n    cursor[leaf] = coerced;\n}\nexport function resolveEffectiveConfig(cliOverrides, tomlConfig) {\n    const cfg = {};\n    const merged = { ...(tomlConfig || {}) };\n    // Apply CLI overrides (highest precedence)\n    if (cliOverrides) {\n        const deepMerge = (target, src) => {\n            for (const k of Object.keys(src)) {\n                if (src[k] && typeof src[k] === \"object\" && !Array.isArray(src[k])) {\n                    if (!target[k] || typeof target[k] !== \"object\")\n                        target[k] = {};\n                    deepMerge(target[k], src[k]);\n                }\n                else {\n                    target[k] = src[k];\n                }\n            }\n            return target;\n        };\n        deepMerge(merged, cliOverrides);\n    }\n    cfg.model = merged.model;\n    cfg.features = merged.features || {};\n    const providerId = merged.model_provider;\n    if (providerId && merged.model_providers && merged.model_providers[providerId]) {\n        const pc = merged.model_providers[providerId];\n        const apiKey = pc.env_key ? process.env[pc.env_key] : undefined;\n        cfg.provider = {\n            id: providerId,\n            baseURL: pc.base_url,\n            apiKey,\n            wireAPI: pc.wire_api,\n            requestMaxRetries: pc.request_max_retries,\n            streamIdleTimeoutMs: pc.stream_idle_timeout_ms,\n        };\n    }\n    return cfg;\n}\n//# sourceMappingURL=config.js.map"
  },
  "dist/utils/git-rewind.js": {
    "path": "dist/utils/git-rewind.js",
    "hash": "bc3fa10d9d2bd1ae54a414bf3dd377ba142a5b29fbf0b72058352d76f586866d",
    "size": 7465,
    "timestamp": 1764704879300,
    "content": "/**\n * Git Rewind Manager\n * Synchronize conversation history and code state to specific dates\n */\nimport { execAsync } from './exec-async.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nexport class GitRewindManager {\n    /**\n     * Perform Git rewind to specific date range\n     */\n    async performRewind(sourceWorkdir, targetWorkdir, dateRange, sessionId, options) {\n        // Check if source is Git repo\n        if (!await this.isGitRepo(sourceWorkdir)) {\n            throw new Error('Source directory is not a Git repository');\n        }\n        // Find commits in date range\n        const commits = await this.findCommitsInRange(sourceWorkdir, dateRange);\n        if (commits.length === 0) {\n            // Fallback: find closest commit before end date\n            const closestCommit = await this.findClosestCommitBefore(sourceWorkdir, dateRange.end);\n            if (!closestCommit) {\n                throw new Error(`No commits found before ${dateRange.end.toISOString()}`);\n            }\n            console.warn(`‚ö†Ô∏è  No commits in date range. Using closest commit before:\\n` +\n                `   ${closestCommit.hash} (${closestCommit.date.toLocaleString()})`);\n            commits.push(closestCommit);\n        }\n        // Target commit = last commit in range\n        const targetCommit = commits[commits.length - 1];\n        // Extract files using chosen method\n        let fileCount;\n        let extractionMethod;\n        if (options?.preserveGitHistory) {\n            // Option: Clone + Checkout (full history)\n            fileCount = await this.extractWithClone(sourceWorkdir, targetWorkdir, targetCommit.hash);\n            extractionMethod = 'clone';\n        }\n        else {\n            // Default: git archive (lightweight, RECOMMENDED)\n            fileCount = await this.extractWithArchive(sourceWorkdir, targetWorkdir, targetCommit.hash);\n            extractionMethod = 'archive';\n        }\n        // Create rewind info\n        const rewindInfo = {\n            rewind_date: new Date(),\n            source_repo: sourceWorkdir,\n            source_session_id: sessionId,\n            date_range: dateRange,\n            git_commits: commits,\n            target_commit: targetCommit.hash,\n            files_copied: fileCount,\n            conversation_messages: 0, // Will be filled by caller\n            extraction_method: extractionMethod\n        };\n        await this.createRewindInfo(targetWorkdir, rewindInfo);\n        return rewindInfo;\n    }\n    /**\n     * Find Git commits in date range\n     */\n    async findCommitsInRange(workdir, dateRange) {\n        const startStr = dateRange.start.toISOString();\n        const endStr = dateRange.end.toISOString();\n        // git log with date filtering\n        const cmd = `git log --since=\"${startStr}\" --until=\"${endStr}\" --pretty=format:\"%H|%aI|%an|%s\" --all`;\n        try {\n            const { stdout } = await execAsync(cmd, { cwd: workdir });\n            if (!stdout.trim()) {\n                return [];\n            }\n            const commits = stdout.split('\\n')\n                .filter(line => line.trim())\n                .map(line => {\n                const [hash, dateStr, author, message] = line.split('|');\n                return {\n                    hash,\n                    date: new Date(dateStr),\n                    author,\n                    message\n                };\n            });\n            return commits;\n        }\n        catch (error) {\n            return [];\n        }\n    }\n    /**\n     * Find closest commit before a date\n     */\n    async findClosestCommitBefore(workdir, beforeDate) {\n        const beforeStr = beforeDate.toISOString();\n        const cmd = `git log --until=\"${beforeStr}\" --pretty=format:\"%H|%aI|%an|%s\" --max-count=1 --all`;\n        try {\n            const { stdout } = await execAsync(cmd, { cwd: workdir });\n            if (!stdout.trim()) {\n                return null;\n            }\n            const [hash, dateStr, author, message] = stdout.trim().split('|');\n            return {\n                hash,\n                date: new Date(dateStr),\n                author,\n                message\n            };\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    /**\n     * Extract files using git archive (lightweight)\n     */\n    async extractWithArchive(sourceWorkdir, targetWorkdir, commitHash) {\n        // Create target directory\n        fs.mkdirSync(targetWorkdir, { recursive: true });\n        // Extract files using git archive\n        const cmd = `git archive ${commitHash} | tar -x -C \"${targetWorkdir}\"`;\n        await execAsync(cmd, { cwd: sourceWorkdir });\n        // Count files\n        const fileCount = await this.countFiles(targetWorkdir);\n        return fileCount;\n    }\n    /**\n     * Extract files using clone (full history)\n     */\n    async extractWithClone(sourceWorkdir, targetWorkdir, commitHash) {\n        // Clone repository\n        await execAsync(`git clone \"${sourceWorkdir}\" \"${targetWorkdir}\"`);\n        // Checkout target commit\n        await execAsync(`git checkout ${commitHash}`, { cwd: targetWorkdir });\n        // Count files\n        const fileCount = await this.countFiles(targetWorkdir);\n        return fileCount;\n    }\n    /**\n     * Count files in directory (excluding .git)\n     */\n    async countFiles(directory) {\n        let count = 0;\n        const walkDir = (dir) => {\n            const files = fs.readdirSync(dir);\n            for (const file of files) {\n                // Skip .git directory\n                if (file === '.git')\n                    continue;\n                const filePath = path.join(dir, file);\n                const stat = fs.statSync(filePath);\n                if (stat.isDirectory()) {\n                    walkDir(filePath);\n                }\n                else {\n                    count++;\n                }\n            }\n        };\n        walkDir(directory);\n        return count;\n    }\n    /**\n     * Check if directory is a Git repository\n     */\n    async isGitRepo(workdir) {\n        try {\n            await execAsync('git rev-parse --is-inside-work-tree', { cwd: workdir });\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Create rewind metadata file\n     */\n    async createRewindInfo(targetDir, info) {\n        const infoPath = path.join(targetDir, '.git-rewind-info.json');\n        const json = JSON.stringify({\n            rewind_date: info.rewind_date.toISOString(),\n            source_repo: info.source_repo,\n            source_session_id: info.source_session_id,\n            date_range: {\n                start: info.date_range.start.toISOString(),\n                end: info.date_range.end.toISOString()\n            },\n            git_commits: info.git_commits.map(c => ({\n                hash: c.hash,\n                date: c.date.toISOString(),\n                author: c.author,\n                message: c.message\n            })),\n            target_commit: info.target_commit,\n            files_copied: info.files_copied,\n            conversation_messages: info.conversation_messages,\n            extraction_method: info.extraction_method\n        }, null, 2);\n        fs.writeFileSync(infoPath, json, 'utf-8');\n    }\n    /**\n     * Update rewind info (e.g., with conversation message count)\n     */\n    async updateRewindInfo(targetDir, info) {\n        await this.createRewindInfo(targetDir, info);\n    }\n}\n//# sourceMappingURL=git-rewind.js.map"
  },
  "dist/utils/token-counter.js": {
    "path": "dist/utils/token-counter.js",
    "hash": "43f719e2450e33b613294bf2d802344b2f6b07c178ac5e491068a60c060f9122",
    "size": 2400,
    "timestamp": 1764704879300,
    "content": "import { get_encoding, encoding_for_model } from 'tiktoken';\nexport class TokenCounter {\n    encoder;\n    constructor(model = 'gpt-4') {\n        try {\n            // Try to get encoding for specific model\n            this.encoder = encoding_for_model(model);\n        }\n        catch {\n            // Fallback to cl100k_base (used by GPT-4 and most modern models)\n            this.encoder = get_encoding('cl100k_base');\n        }\n    }\n    /**\n     * Count tokens in a string\n     */\n    countTokens(text) {\n        if (!text)\n            return 0;\n        return this.encoder.encode(text).length;\n    }\n    /**\n     * Count tokens in messages array (for chat completions)\n     */\n    countMessageTokens(messages) {\n        let totalTokens = 0;\n        for (const message of messages) {\n            // Every message follows <|start|>{role/name}\\n{content}<|end|\\>\\n\n            totalTokens += 3; // Base tokens per message\n            if (message.content && typeof message.content === 'string') {\n                totalTokens += this.countTokens(message.content);\n            }\n            if (message.role) {\n                totalTokens += this.countTokens(message.role);\n            }\n            // Add extra tokens for tool calls if present\n            if (message.tool_calls) {\n                totalTokens += this.countTokens(JSON.stringify(message.tool_calls));\n            }\n        }\n        totalTokens += 3; // Every reply is primed with <|start|>assistant<|message|>\n        return totalTokens;\n    }\n    /**\n     * Estimate tokens for streaming content\n     * This is an approximation since we don't have the full response yet\n     */\n    estimateStreamingTokens(accumulatedContent) {\n        return this.countTokens(accumulatedContent);\n    }\n    /**\n     * Clean up resources\n     */\n    dispose() {\n        this.encoder.free();\n    }\n}\n/**\n * Format token count for display (e.g., 1.2k for 1200)\n */\nexport function formatTokenCount(count) {\n    if (count <= 999) {\n        return count.toString();\n    }\n    if (count < 1_000_000) {\n        const k = count / 1000;\n        return k % 1 === 0 ? `${k}k` : `${k.toFixed(1)}k`;\n    }\n    const m = count / 1_000_000;\n    return m % 1 === 0 ? `${m}m` : `${m.toFixed(1)}m`;\n}\n/**\n * Create a token counter instance\n */\nexport function createTokenCounter(model) {\n    return new TokenCounter(model);\n}\n//# sourceMappingURL=token-counter.js.map"
  },
  "dist/utils/paste-burst-detector.js": {
    "path": "dist/utils/paste-burst-detector.js",
    "hash": "7a8d600b8df04bf1c0cb849fb54e7226dc172ae654194bf0d9f284bbbd786400",
    "size": 2797,
    "timestamp": 1764704879300,
    "content": "/**\n * Paste Burst Detector - Buffers rapid input chunks into complete pastes\n *\n * Inspired by Codex's paste_burst.rs implementation.\n *\n * Problem: Terminals split long pastes into multiple chunks.\n * Solution: Detect rapid inputs (< 8ms apart) and buffer them together.\n */\nconst PASTE_BURST_CHAR_INTERVAL_MS = 8; // Chars arriving within 8ms = paste burst\nconst PASTE_BURST_FLUSH_TIMEOUT_MS = 100; // Wait 100ms for more chunks before flushing (handles large pastes)\nexport class PasteBurstDetector {\n    buffer = '';\n    lastInputTime = null;\n    flushTimer = null;\n    isActive = false;\n    onFlush = null;\n    /**\n     * Process input character/string\n     * Returns true if buffering (don't insert yet), false if should insert normally\n     */\n    handleInput(inputChar, onFlushCallback) {\n        const now = Date.now();\n        this.onFlush = onFlushCallback;\n        // Check if this input arrives quickly after the last one (paste burst)\n        const isPasteBurst = this.lastInputTime !== null &&\n            (now - this.lastInputTime) <= PASTE_BURST_CHAR_INTERVAL_MS;\n        // If we're in an active burst or this looks like a new burst\n        if (this.isActive || isPasteBurst || inputChar.length > 10) {\n            // Activate burst mode\n            if (!this.isActive) {\n                this.isActive = true;\n            }\n            // Append to buffer\n            this.buffer += inputChar;\n            this.lastInputTime = now;\n            // Clear existing timer\n            if (this.flushTimer) {\n                clearTimeout(this.flushTimer);\n            }\n            // Set new timer to flush after timeout\n            this.flushTimer = setTimeout(() => {\n                this.flush();\n            }, PASTE_BURST_FLUSH_TIMEOUT_MS);\n            return true; // Buffering, don't insert yet\n        }\n        // Normal single character input\n        this.lastInputTime = now;\n        return false; // Insert normally\n    }\n    /**\n     * Flush buffered content\n     */\n    flush() {\n        if (this.buffer && this.onFlush) {\n            const content = this.buffer;\n            this.clear();\n            this.onFlush(content);\n        }\n    }\n    /**\n     * Clear buffer and state\n     */\n    clear() {\n        this.buffer = '';\n        this.lastInputTime = null;\n        this.isActive = false;\n        if (this.flushTimer) {\n            clearTimeout(this.flushTimer);\n            this.flushTimer = null;\n        }\n    }\n    /**\n     * Get current buffer (for debugging)\n     */\n    getBuffer() {\n        return this.buffer;\n    }\n    /**\n     * Check if currently buffering\n     */\n    isBuffering() {\n        return this.isActive;\n    }\n}\n// Singleton instance\nexport const pasteBurstDetector = new PasteBurstDetector();\n//# sourceMappingURL=paste-burst-detector.js.map"
  },
  "dist/hooks/use-input-history.js": {
    "path": "dist/hooks/use-input-history.js",
    "hash": "82d8f0c83ff92a5f253541f4a77e6c28ce1f6289f11c0a3510da8100fa0fd974",
    "size": 2672,
    "timestamp": 1764704879300,
    "content": "import { useState, useCallback, useEffect } from \"react\";\nimport { appendInputHistory, loadInputHistory } from \"../utils/input-history-manager.js\";\nexport function useInputHistory() {\n    const [history, setHistory] = useState([]);\n    const [currentIndex, setCurrentIndex] = useState(-1);\n    const [originalInput, setOriginalInput] = useState(\"\");\n    // Load persisted input history on mount\n    useEffect(() => {\n        (async () => {\n            try {\n                const items = await loadInputHistory();\n                if (items.length > 0)\n                    setHistory(items);\n            }\n            catch { }\n        })();\n    }, []);\n    const addToHistory = useCallback((input) => {\n        const trimmed = input.trim();\n        if (trimmed && !history.includes(trimmed)) {\n            setHistory(prev => [...prev, trimmed]);\n            // Fire and forget append to JSONL (async, non-blocking)\n            appendInputHistory(trimmed).catch(() => { });\n        }\n        setCurrentIndex(-1);\n        setOriginalInput(\"\");\n    }, [history]);\n    const navigateHistory = useCallback((direction) => {\n        if (history.length === 0)\n            return null;\n        let newIndex;\n        if (direction === \"up\") {\n            if (currentIndex === -1) {\n                newIndex = history.length - 1;\n            }\n            else {\n                newIndex = Math.max(0, currentIndex - 1);\n            }\n        }\n        else {\n            if (currentIndex === -1) {\n                return null;\n            }\n            else if (currentIndex === history.length - 1) {\n                newIndex = -1;\n                return originalInput;\n            }\n            else {\n                newIndex = Math.min(history.length - 1, currentIndex + 1);\n            }\n        }\n        setCurrentIndex(newIndex);\n        return newIndex === -1 ? originalInput : history[newIndex];\n    }, [history, currentIndex, originalInput]);\n    const getCurrentHistoryIndex = useCallback(() => currentIndex, [currentIndex]);\n    const resetHistory = useCallback(() => {\n        setHistory([]);\n        setCurrentIndex(-1);\n        setOriginalInput(\"\");\n    }, []);\n    const isNavigatingHistory = useCallback(() => currentIndex !== -1, [currentIndex]);\n    const setOriginalInputCallback = useCallback((input) => {\n        if (currentIndex === -1) {\n            setOriginalInput(input);\n        }\n    }, [currentIndex]);\n    return {\n        addToHistory,\n        navigateHistory,\n        getCurrentHistoryIndex,\n        resetHistory,\n        isNavigatingHistory,\n        setOriginalInput: setOriginalInputCallback,\n    };\n}\n//# sourceMappingURL=use-input-history.js.map"
  },
  "dist/hooks/use-input-handler.js": {
    "path": "dist/hooks/use-input-handler.js",
    "hash": "33bb3b9b7e1fa592e0f2bb9d1054a1f957752c90006672e70df9fa19fffa1aa9",
    "size": 110902,
    "timestamp": 1764704879301,
    "content": "import { useState, useMemo, useEffect, useRef } from \"react\";\nimport { useInput } from \"ink\";\nimport { ConfirmationService } from \"../utils/confirmation-service.js\";\nimport { useEnhancedInput } from \"./use-enhanced-input.js\";\nimport { filterCommandSuggestions } from \"../ui/components/command-suggestions.js\";\nimport { loadModelConfig, updateCurrentModel, updateDefaultModel } from \"../utils/model-config.js\";\nimport { clearSession } from \"../utils/session-manager.js\";\nimport { pasteManager } from \"../utils/paste-manager.js\";\nimport { providerManager } from \"../utils/provider-manager.js\";\nimport { sessionManager } from \"../utils/session-manager-sqlite.js\";\nimport { generateStatusMessage } from \"../utils/status-message.js\";\nimport { HelpFormatter } from \"../utils/help-formatter.js\";\n/**\n * Parse date from various formats:\n * - DD/MM/YYYY (e.g., 01/11/2025)\n * - YYYY-MM-DD (e.g., 2025-11-01)\n * - Relative: \"today\", \"yesterday\"\n */\nfunction parseDate(dateStr) {\n    // Relative dates\n    if (dateStr === 'today') {\n        return new Date();\n    }\n    if (dateStr === 'yesterday') {\n        const d = new Date();\n        d.setDate(d.getDate() - 1);\n        return d;\n    }\n    // DD/MM/YYYY format\n    if (/^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/.test(dateStr)) {\n        const [day, month, year] = dateStr.split('/').map(Number);\n        return new Date(year, month - 1, day);\n    }\n    // YYYY-MM-DD format\n    if (/^\\d{4}-\\d{1,2}-\\d{1,2}$/.test(dateStr)) {\n        return new Date(dateStr);\n    }\n    throw new Error(`Invalid date format: ${dateStr}. Use DD/MM/YYYY or YYYY-MM-DD`);\n}\nexport function useInputHandler({ agent, chatHistory, setChatHistory, setCommittedHistory, setActiveMessages, isSwitchingRef, setIsProcessing, setIsStreaming, setStreamingContent, setStreamingTools, setStreamingToolResults, setTokenCount, setProcessingTime, processingStartTime, isProcessing, isStreaming, isConfirmationActive = false, searchMode = false, streamingBus, onSearchCommand, inputInjectionRef, }) {\n    const [showCommandSuggestions, setShowCommandSuggestions] = useState(false);\n    const [selectedCommandIndex, setSelectedCommandIndex] = useState(0);\n    const [showModelSelection, setShowModelSelection] = useState(false);\n    const [selectedModelIndex, setSelectedModelIndex] = useState(0);\n    const [autoEditEnabled, setAutoEditEnabled] = useState(() => {\n        const confirmationService = ConfirmationService.getInstance();\n        const sessionFlags = confirmationService.getSessionFlags();\n        return sessionFlags.allOperations;\n    });\n    const handleSpecialKey = (key) => {\n        // Don't handle input if confirmation dialog is active\n        if (isConfirmationActive) {\n            return true; // Prevent default handling\n        }\n        // Handle shift+tab to toggle auto-edit mode\n        if (key.shift && key.tab) {\n            const newAutoEditState = !autoEditEnabled;\n            setAutoEditEnabled(newAutoEditState);\n            const confirmationService = ConfirmationService.getInstance();\n            if (newAutoEditState) {\n                // Enable auto-edit: set all operations to be accepted\n                confirmationService.setSessionFlag(\"allOperations\", true);\n            }\n            else {\n                // Disable auto-edit: reset session flags\n                confirmationService.resetSession();\n            }\n            return true; // Handled\n        }\n        // Handle escape key for closing menus\n        if (key.escape) {\n            if (showCommandSuggestions) {\n                setShowCommandSuggestions(false);\n                setSelectedCommandIndex(0);\n                return true;\n            }\n            if (showModelSelection) {\n                setShowModelSelection(false);\n                setSelectedModelIndex(0);\n                return true;\n            }\n            if (isProcessing || isStreaming) {\n                agent.abortCurrentOperation();\n                setIsProcessing(false);\n                setIsStreaming(false);\n                setTokenCount(0);\n                setProcessingTime(0);\n                processingStartTime.current = 0;\n                return true;\n            }\n            return false; // Let default escape handling work\n        }\n        // Handle command suggestions navigation\n        if (showCommandSuggestions) {\n            const filteredSuggestions = filterCommandSuggestions(commandSuggestions, input);\n            if (filteredSuggestions.length === 0) {\n                setShowCommandSuggestions(false);\n                setSelectedCommandIndex(0);\n                return false; // Continue processing\n            }\n            else {\n                if (key.upArrow) {\n                    setSelectedCommandIndex((prev) => prev === 0 ? filteredSuggestions.length - 1 : prev - 1);\n                    return true;\n                }\n                if (key.downArrow) {\n                    setSelectedCommandIndex((prev) => (prev + 1) % filteredSuggestions.length);\n                    return true;\n                }\n                if (key.tab || key.return) {\n                    const safeIndex = Math.min(selectedCommandIndex, filteredSuggestions.length - 1);\n                    const selectedCommand = filteredSuggestions[safeIndex];\n                    const newInput = selectedCommand.command + \" \";\n                    setInput(newInput);\n                    setCursorPosition(newInput.length);\n                    setShowCommandSuggestions(false);\n                    setSelectedCommandIndex(0);\n                    return true;\n                }\n            }\n        }\n        // Handle model selection navigation\n        if (showModelSelection) {\n            if (key.upArrow) {\n                setSelectedModelIndex((prev) => prev === 0 ? availableModels.length - 1 : prev - 1);\n                return true;\n            }\n            if (key.downArrow) {\n                setSelectedModelIndex((prev) => (prev + 1) % availableModels.length);\n                return true;\n            }\n            if (key.tab || key.return) {\n                const selectedModel = availableModels[selectedModelIndex];\n                // ‚úÖ NEW: Use multi-provider logic (same as /models <name>)\n                const providerConfig = providerManager.getProviderForModel(selectedModel.model);\n                if (!providerConfig) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `‚ùå Could not detect provider for model: ${selectedModel.model}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    setShowModelSelection(false);\n                    return true;\n                }\n                // Check API key\n                if (!providerConfig.apiKey) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `‚ùå API key not configured for provider: ${providerConfig.name}\\n\\n` +\n                            `Set it now:\\n` +\n                            `  /apikey ${providerConfig.name} your-api-key-here`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    setShowModelSelection(false);\n                    return true;\n                }\n                // ‚úÖ Switch with new provider config (async)\n                (async () => {\n                    const identityInfo = await agent.switchToModel(selectedModel.model, providerConfig.apiKey, providerConfig.baseURL);\n                    updateCurrentModel(selectedModel.model);\n                    const confirmEntry = {\n                        type: \"assistant\",\n                        content: `‚úÖ Switched to ${selectedModel.model}\\n` +\n                            `üìù Provider: ${providerConfig.name}\\n` +\n                            `üîó Endpoint: ${providerConfig.baseURL}\\n` +\n                            `üíæ Saved to: .grok/settings.json\\n\\n` +\n                            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n                            `üîç Identity Verification:\\n${identityInfo}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, confirmEntry]);\n                })();\n                setShowModelSelection(false);\n                setSelectedModelIndex(0);\n                return true;\n            }\n        }\n        return false; // Let default handling proceed\n    };\n    // Guard against duplicate submissions\n    const isSubmittingRef = useRef(false);\n    const handleInputSubmit = async (userInput) => {\n        // Prevent duplicate submissions\n        if (isSubmittingRef.current) {\n            return;\n        }\n        if (userInput === \"exit\" || userInput === \"quit\") {\n            process.exit(0);\n            return;\n        }\n        // Expand placeholders before processing\n        const expandedInput = pasteManager.expandPlaceholders(userInput);\n        if (expandedInput.trim()) {\n            isSubmittingRef.current = true;\n            try {\n                const directCommandResult = await handleDirectCommand(expandedInput);\n                if (!directCommandResult) {\n                    await processUserMessage(expandedInput);\n                }\n                // Clear pending pastes after successful submit\n                pasteManager.clearAll();\n            }\n            finally {\n                isSubmittingRef.current = false;\n            }\n        }\n    };\n    const handleInputChange = (newInput) => {\n        // Update command suggestions based on input\n        if (newInput.startsWith(\"/\")) {\n            setShowCommandSuggestions(true);\n            setSelectedCommandIndex(0);\n        }\n        else {\n            setShowCommandSuggestions(false);\n            setSelectedCommandIndex(0);\n        }\n    };\n    const { input, cursorPosition, setInput, setCursorPosition, clearInput, resetHistory, handleInput, } = useEnhancedInput({\n        onSubmit: handleInputSubmit,\n        onSpecialKey: handleSpecialKey,\n        disabled: isConfirmationActive,\n    });\n    // Expose input injection function for external use (e.g., paste from search)\n    useEffect(() => {\n        if (inputInjectionRef) {\n            inputInjectionRef.current = (text) => {\n                // Append text to current input\n                const newInput = input + text;\n                setInput(newInput);\n                setCursorPosition(newInput.length);\n            };\n        }\n    }, [input, setInput, setCursorPosition, inputInjectionRef]);\n    // Hook up the actual input handling\n    useInput((inputChar, key) => {\n        // Don't process input in search mode (SearchResults component handles it)\n        if (searchMode) {\n            return;\n        }\n        handleInput(inputChar, key);\n    });\n    // Update command suggestions when input changes\n    useEffect(() => {\n        handleInputChange(input);\n    }, [input]);\n    const commandSuggestions = [\n        { command: \"/help\", description: \"Show help information\" },\n        { command: \"/status\", description: \"Show current model and provider info\" },\n        { command: \"/search\", description: \"Search in conversation history\" },\n        { command: \"/list_sessions\", description: \"List all sessions in current directory\" },\n        { command: \"/switch-session\", description: \"Switch to a different session by ID\" },\n        { command: \"/rename_session\", description: \"Rename the current session\" },\n        { command: \"/new-session\", description: \"Create a new session in current directory\" },\n        { command: \"/timeline\", description: \"Query timeline events (files, git, conversations)\" },\n        { command: \"/rewind\", description: \"Time machine: rewind to specific timestamp\" },\n        { command: \"/snapshots\", description: \"List available snapshots for rewinding\" },\n        { command: \"/rewind-history\", description: \"Show history of all rewind operations\" },\n        { command: \"/list_tools\", description: \"List all tools available to LLMs\" },\n        { command: \"/models\", description: \"Switch model (interactive)\" },\n        { command: \"/model-default\", description: \"Set global default model\" },\n        { command: \"/apikey\", description: \"Manage API keys\" },\n        { command: \"/clear\", description: \"Clear chat history\" },\n        { command: \"/clear-session\", description: \"Clear in-memory session only\" },\n        { command: \"/clear-disk-session\", description: \"Delete persisted session and clear memory\" },\n        { command: \"/commit-and-push\", description: \"AI commit & push to remote\" },\n        { command: \"/exit\", description: \"Exit the application\" },\n    ];\n    // Load models from configuration with fallback to defaults\n    const availableModels = useMemo(() => {\n        return loadModelConfig(); // Return directly, interface already matches\n    }, []);\n    const handleDirectCommand = async (input) => {\n        const trimmedInput = input.trim();\n        // Handle /search command\n        if (trimmedInput.startsWith(\"/search\")) {\n            if (onSearchCommand) {\n                const handled = onSearchCommand(trimmedInput);\n                if (handled) {\n                    clearInput();\n                    return true;\n                }\n            }\n            // If not handled, show error\n            const errorEntry = {\n                type: \"assistant\",\n                content: \"‚ùå Search feature is not available. Usage: /search <query>\",\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, errorEntry]);\n            clearInput();\n            return true;\n        }\n        if (trimmedInput === \"/clear\") {\n            // Reset chat history\n            setChatHistory([]);\n            // Reset processing states\n            setIsProcessing(false);\n            setIsStreaming(false);\n            setTokenCount(0);\n            setProcessingTime(0);\n            processingStartTime.current = 0;\n            // Reset confirmation service session flags\n            const confirmationService = ConfirmationService.getInstance();\n            confirmationService.resetSession();\n            clearInput();\n            resetHistory();\n            return true;\n        }\n        if (trimmedInput === \"/help\" || trimmedInput.startsWith(\"/help \")) {\n            const parts = trimmedInput.split(/\\s+/);\n            const subCommand = parts.length > 1 ? parts[1] : undefined;\n            const helpContent = subCommand\n                ? HelpFormatter.generateCommandHelp(subCommand)\n                : HelpFormatter.generateHelp(agent);\n            const helpEntry = {\n                type: \"assistant\",\n                content: helpContent,\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, helpEntry]);\n            clearInput();\n            return true;\n        }\n        if (trimmedInput === \"/clear-session\") {\n            // Clear in-memory session only (no disk changes)\n            setChatHistory([]);\n            setIsProcessing(false);\n            setIsStreaming(false);\n            setTokenCount(0);\n            setProcessingTime(0);\n            processingStartTime.current = 0;\n            const confirmationService = ConfirmationService.getInstance();\n            confirmationService.resetSession();\n            clearInput();\n            resetHistory();\n            return true;\n        }\n        if (trimmedInput === \"/clear-disk-session\") {\n            try {\n                await clearSession();\n                // Also clear in-memory session\n                setChatHistory([]);\n                setIsProcessing(false);\n                setIsStreaming(false);\n                setTokenCount(0);\n                setProcessingTime(0);\n                processingStartTime.current = 0;\n                const confirmationService = ConfirmationService.getInstance();\n                confirmationService.resetSession();\n                const infoEntry = {\n                    type: \"assistant\",\n                    content: \"‚úì Deleted persisted session and cleared memory\",\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, infoEntry]);\n            }\n            catch (e) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `Failed to clear disk session: ${e?.message || \"Unknown error\"}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            resetHistory();\n            return true;\n        }\n        if (trimmedInput === \"/exit\") {\n            process.exit(0);\n            return true;\n        }\n        // ============================================\n        // /status - Show enriched session status\n        // ============================================\n        if (trimmedInput === \"/status\") {\n            const statusEntry = generateStatusMessage(agent);\n            setChatHistory((prev) => [...prev, statusEntry]);\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /list_sessions - List ALL sessions from ALL directories\n        // ============================================\n        if (trimmedInput === \"/list_sessions\") {\n            try {\n                // Pass null to get sessions from ALL directories (not just current)\n                const sessions = sessionManager.listSessions(null, {\n                    sortBy: 'last_activity',\n                    sortOrder: 'DESC',\n                    limit: 50 // Increased limit for multi-directory view\n                });\n                if (sessions.length === 0) {\n                    const noSessionEntry = {\n                        type: \"assistant\",\n                        content: `üìÇ No sessions found\\n\\n` +\n                            `Start chatting to create your first session!`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, noSessionEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Group sessions by working directory\n                const sessionsByDir = new Map();\n                sessions.forEach(session => {\n                    const dir = session.working_dir;\n                    if (!sessionsByDir.has(dir)) {\n                        sessionsByDir.set(dir, []);\n                    }\n                    sessionsByDir.get(dir).push(session);\n                });\n                // Format sessions list grouped by directory\n                const dirCount = sessionsByDir.size;\n                let content = `üìö All Sessions (${dirCount} ${dirCount === 1 ? 'directory' : 'directories'})\\n` +\n                    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                // Iterate through directories (sorted by most recent activity)\n                const sortedDirs = Array.from(sessionsByDir.entries()).sort((a, b) => {\n                    const latestA = Math.max(...a[1].map(s => new Date(s.last_activity).getTime()));\n                    const latestB = Math.max(...b[1].map(s => new Date(s.last_activity).getTime()));\n                    return latestB - latestA;\n                });\n                sortedDirs.forEach(([dir, dirSessions], dirIndex) => {\n                    // Highlight current directory\n                    const isCurrent = dir === process.cwd();\n                    const dirMarker = isCurrent ? 'üìç' : 'üìÅ';\n                    const dirLabel = isCurrent ? ` (current)` : '';\n                    content += `${dirMarker} **${dir}**${dirLabel}\\n`;\n                    content += `   ${dirSessions.length} ${dirSessions.length === 1 ? 'session' : 'sessions'}\\n\\n`;\n                    dirSessions.forEach((session, sessionIndex) => {\n                        const status = session.status === 'active' ? 'üü¢' :\n                            session.status === 'completed' ? '‚ö™' : 'üì¶';\n                        const favorite = session.is_favorite ? '‚≠ê' : '';\n                        content += `   ${status} #${session.id}${favorite}`;\n                        if (session.session_name) {\n                            content += ` - ${session.session_name}`;\n                        }\n                        content += `\\n`;\n                        content += `      üì± Model: ${session.default_model} | üí¨ ${session.message_count} msgs`;\n                        // Add creation date\n                        if (session.created_at) {\n                            const createdDate = new Date(session.created_at);\n                            const createdFormatted = createdDate.toLocaleString('fr-FR', {\n                                year: 'numeric',\n                                month: '2-digit',\n                                day: '2-digit',\n                                hour: '2-digit',\n                                minute: '2-digit'\n                            });\n                            content += `\\n      üïê Created: ${createdFormatted}`;\n                            // Add age if available\n                            if (session.age_days !== undefined) {\n                                const ageStr = session.age_days === 0\n                                    ? 'today'\n                                    : session.age_days === 1\n                                        ? '1 day ago'\n                                        : `${session.age_days} days ago`;\n                                content += ` (${ageStr})`;\n                            }\n                        }\n                        // Add last activity\n                        if (session.last_activity_relative) {\n                            content += `\\n      ‚è∞ Last active: ${session.last_activity_relative}`;\n                        }\n                        content += `\\n`;\n                    });\n                    // Add spacing between directories\n                    if (dirIndex < sortedDirs.length - 1) {\n                        content += `\\n`;\n                    }\n                });\n                content += `\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n`;\n                content += `\\nüí° Use \\`/switch-session <id>\\` to switch (changes directory automatically)\\n`;\n                content += `üí° Legend: üü¢ Active  ‚ö™ Completed  üì¶ Archived  ‚≠ê Favorite  üìç Current dir`;\n                const sessionListEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, sessionListEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to list sessions: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /switch-session <id> - Switch to a different session\n        // ============================================\n        if (trimmedInput.startsWith(\"/switch-session\")) {\n            const parts = trimmedInput.split(/\\s+/);\n            if (parts.length < 2 || !parts[1]) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Usage: /switch-session <session_id>\\n\\n` +\n                        `Example: /switch-session 5\\n\\n` +\n                        `üí° Use /list_sessions to see available session IDs`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n                clearInput();\n                return true;\n            }\n            const sessionId = parseInt(parts[1], 10);\n            if (isNaN(sessionId)) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Invalid session ID: \"${parts[1]}\"\\n\\n` +\n                        `Session ID must be a number.\\n\\n` +\n                        `üí° Use /list_sessions to see available session IDs`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n                clearInput();\n                return true;\n            }\n            try {\n                // CRITICAL: Set switching flag to prevent auto-commit during state updates\n                if (isSwitchingRef) {\n                    isSwitchingRef.current = true;\n                }\n                // Switch session\n                const { session, history } = await sessionManager.switchSession(sessionId);\n                // CRITICAL: Change working directory to match the session's working_dir\n                // This prevents path confusion when the LLM thinks it's in one directory\n                // but the Node process is actually in another\n                const targetWorkdir = session.working_dir;\n                const currentWorkdir = process.cwd();\n                if (targetWorkdir !== currentWorkdir) {\n                    // Verify target directory exists\n                    const fs = await import('fs');\n                    if (!fs.existsSync(targetWorkdir)) {\n                        throw new Error(`Session's working directory does not exist: ${targetWorkdir}\\n` +\n                            `The directory may have been moved or deleted.`);\n                    }\n                    // Change the Node process's current working directory\n                    process.chdir(targetWorkdir);\n                    // Verify the change was successful\n                    const newCwd = process.cwd();\n                    if (newCwd !== targetWorkdir) {\n                        throw new Error(`Failed to change directory from ${currentWorkdir} to ${targetWorkdir}\\n` +\n                            `Current directory is: ${newCwd}`);\n                    }\n                }\n                // Update agent with new session's model/provider\n                const providerConfig = providerManager.getProviderForModel(session.default_model);\n                if (!providerConfig) {\n                    throw new Error(`Unknown provider for model: ${session.default_model}`);\n                }\n                const apiKey = agent.getApiKey(); // Keep current API key\n                await agent.switchToModel(session.default_model, apiKey, providerConfig.baseURL);\n                // Add confirmation message\n                const dirChanged = targetWorkdir !== currentWorkdir;\n                const confirmEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ Switched to Session #${session.id}\\n\\n` +\n                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                        `üìù Name: ${session.session_name || 'Unnamed'}\\n` +\n                        `ü§ñ Provider: ${session.default_provider}\\n` +\n                        `üì± Model: ${session.default_model}\\n` +\n                        `üí¨ Messages: ${history.length}\\n` +\n                        `üìÅ Working Directory: ${session.working_dir}\\n` +\n                        `üïê Last Activity: ${new Date(session.last_activity).toLocaleString()}\\n\\n` +\n                        (dirChanged\n                            ? `üìÇ **Directory Changed:**\\n` +\n                                `   From: ${currentWorkdir}\\n` +\n                                `   To:   ${targetWorkdir}\\n\\n` +\n                                `‚ö†Ô∏è  All relative paths now resolve to the new directory.\\n\\n`\n                            : `üìÇ **Directory:** Already in ${targetWorkdir}\\n\\n`) +\n                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                        `Conversation history loaded! Continue chatting...`,\n                    timestamp: new Date(),\n                };\n                // CRITICAL: Replace chat history with the new session's history\n                // We update chatHistory first with just the loaded history (no confirmation yet)\n                // This ensures committedHistory and chatHistory are in sync momentarily\n                setChatHistory(history);\n                // Then update committedHistory to match (all loaded messages are \"committed\")\n                if (setCommittedHistory) {\n                    setCommittedHistory(history);\n                }\n                // Finally add the confirmation message\n                // This makes activeMessages = [confirmEntry] via the automatic useEffect calculation\n                setChatHistory((prev) => [...prev, confirmEntry]);\n                // Allow auto-commit to resume after a small delay (let React finish batching)\n                setTimeout(() => {\n                    if (isSwitchingRef) {\n                        isSwitchingRef.current = false;\n                    }\n                }, 100);\n            }\n            catch (error) {\n                // Reset switching flag on error\n                if (isSwitchingRef) {\n                    isSwitchingRef.current = false;\n                }\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to switch session: ${error?.message || 'Unknown error'}\\n\\n` +\n                        `üí° Use /list_sessions to see available sessions`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /rename_session <new_name> - Rename the current session\n        // ============================================\n        if (trimmedInput.startsWith(\"/rename_session\")) {\n            const parts = trimmedInput.split(/\\s+/);\n            const newName = parts.slice(1).join(' ').trim();\n            if (!newName) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Usage: /rename_session <new_name>\\n\\n` +\n                        `Example: /rename_session My Project Alpha\\n\\n` +\n                        `üí° The new name will replace the current session name`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n                clearInput();\n                return true;\n            }\n            try {\n                const currentSession = sessionManager.getCurrentSession();\n                if (!currentSession) {\n                    throw new Error('No active session found');\n                }\n                // IMPORTANT: Save old name BEFORE renaming (renameSession updates the cache immediately)\n                const oldName = currentSession.session_name || 'Unnamed';\n                // Rename the session\n                sessionManager.renameSession(currentSession.id, newName);\n                const confirmEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ Session Renamed\\n\\n` +\n                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                        `üìù Old Name: ${oldName}\\n` +\n                        `üìù New Name: ${newName}\\n` +\n                        `üîñ Session ID: ${currentSession.id}\\n\\n` +\n                        `The session name has been updated successfully.`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, confirmEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to rename session: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /timeline-check - Run Merkle DAG consistency check\n        // ============================================\n        if (trimmedInput === \"/timeline-check\") {\n            try {\n                const infoEntry = {\n                    type: \"assistant\",\n                    content: `üîç Timeline / Merkle DAG Check\\n\\n` +\n                        `‚è≥ Running: npm run timeline:check\\n` +\n                        `Logs will be written to: logs/timeline-merkle-check.log`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, infoEntry]);\n                const { exec } = await import(\"child_process\");\n                const { promisify } = await import(\"util\");\n                const execAsync = promisify(exec);\n                await execAsync(\"npm run timeline:check\", { cwd: process.cwd() });\n                const doneEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ timeline:check completed\\n\\n` +\n                        `üìÑ Detailed report:\\n` +\n                        `   logs/timeline-merkle-check.log`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, doneEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå timeline:check failed: ${error?.message || \"Unknown error\"}\\n\\n` +\n                        `üìÑ Check logs/timeline-merkle-check.log for details (if created).`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /timeline-rewind-test - Run rewind self-test\n        // ============================================\n        if (trimmedInput === \"/timeline-rewind-test\") {\n            try {\n                const infoEntry = {\n                    type: \"assistant\",\n                    content: `üß™ Timeline Rewind Self-Test\\n\\n` +\n                        `‚è≥ Running: npm run timeline:rewind-test\\n` +\n                        `Logs will be written to: logs/timeline-rewind-test.log`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, infoEntry]);\n                const { exec } = await import(\"child_process\");\n                const { promisify } = await import(\"util\");\n                const execAsync = promisify(exec);\n                await execAsync(\"npm run timeline:rewind-test\", { cwd: process.cwd() });\n                const doneEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ timeline:rewind-test completed\\n\\n` +\n                        `üìÑ Detailed report:\\n` +\n                        `   logs/timeline-rewind-test.log`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, doneEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå timeline:rewind-test failed: ${error?.message || \"Unknown error\"}\\n\\n` +\n                        `üìÑ Check logs/timeline-rewind-test.log for details (if created).`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /timeline - Query timeline events\n        // ============================================\n        if (trimmedInput.startsWith(\"/timeline\")) {\n            try {\n                const { executeTimelineQuery } = await import(\"../tools/timeline-query-tool.js\");\n                // Parse command arguments\n                const args = trimmedInput.slice(9).trim(); // Remove \"/timeline\"\n                const params = {};\n                // Parse args: /timeline --start \"2 hours ago\" --category FILE --limit 50 --stats\n                const matches = args.matchAll(/--([\\w-]+)\\s+(?:\"([^\"]+)\"|(\\S+))/g);\n                for (const match of matches) {\n                    const key = match[1];\n                    const value = match[2] || match[3];\n                    // Time range aliases\n                    if (key === 'start' || key === 'startTime' || key === 'since') {\n                        params.startTime = value;\n                    }\n                    else if (key === 'end' || key === 'endTime' || key === 'before') {\n                        params.endTime = value;\n                        // Category (high-level type)\n                    }\n                    else if (key === 'category' || key === 'categories') {\n                        if (!params.categories) {\n                            params.categories = [];\n                        }\n                        params.categories.push(value);\n                        // Specific event types\n                    }\n                    else if (key === 'type' || key === 'eventType' || key === 'eventTypes') {\n                        if (!params.eventTypes) {\n                            params.eventTypes = [];\n                        }\n                        params.eventTypes.push(value);\n                        // Session filter\n                    }\n                    else if (key === 'session' || key === 'sessionId') {\n                        params.sessionId = parseInt(value);\n                        // Aggregate (e.g. file path)\n                    }\n                    else if (key === 'path' || key === 'aggregateId') {\n                        params.aggregateId = value;\n                        // Actor filter\n                    }\n                    else if (key === 'actor') {\n                        params.actor = value;\n                        // Limit\n                    }\n                    else if (key === 'limit') {\n                        params.limit = parseInt(value);\n                        // Text search in payloads\n                    }\n                    else if (key === 'search') {\n                        params.searchText = value;\n                        // Sort order\n                    }\n                    else if (key === 'order') {\n                        const lower = value.toLowerCase();\n                        if (lower === 'asc' || lower === 'desc') {\n                            params.order = lower;\n                        }\n                    }\n                }\n                // Check for --stats flag\n                if (args.includes('--stats')) {\n                    params.statsOnly = true;\n                }\n                // If no args, show help\n                if (!args || args === '--help') {\n                    const helpEntry = {\n                        type: \"assistant\",\n                        content: `üìÖ Timeline Query Command\\n\\n` +\n                            `Usage: /timeline [options]\\n\\n` +\n                            `Options:\\n` +\n                            `  --start|--since <time>   Start time (ISO or relative)\\n` +\n                            `  --end|--before <time>    End time (ISO)\\n` +\n                            `  --category <cat>         Category: SESSION, LLM, TOOL, FILE, GIT, REWIND\\n` +\n                            `  --type <event>           Specific event type: FILE_MODIFIED, GIT_COMMIT, etc. (repeatable)\\n` +\n                            `  --path <path>            Filter by aggregate ID (e.g. file path)\\n` +\n                            `  --actor <actor>          Filter by actor (e.g. user, system, git:username)\\n` +\n                            `  --session <id>           Filter by session ID\\n` +\n                            `  --limit <n>              Max results (default: 100)\\n` +\n                            `  --search <text>          Search text in event payloads\\n` +\n                            `  --order <asc|desc>       Sort order (default: desc)\\n` +\n                            `  --stats                  Show statistics only\\n\\n` +\n                            `Examples:\\n` +\n                            `  /timeline --category FILE --limit 20\\n` +\n                            `  /timeline --since \"2025-11-28T10:00:00Z\" --category GIT\\n` +\n                            `  /timeline --type FILE_MODIFIED --path src/ --since \"2025-11-28\" --limit 50\\n` +\n                            `  /timeline --session 5 --stats\\n` +\n                            `  /timeline --search \"error\" --limit 10`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, helpEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Execute query\n                const result = await executeTimelineQuery(params);\n                let content = '';\n                if (result.success) {\n                    if (result.stats) {\n                        content = `üìä Timeline Statistics\\n\\n` +\n                            `Total Events: ${result.stats.totalEvents}\\n\\n` +\n                            `By Category:\\n${Object.entries(result.stats.eventsByCategory).map(([k, v]) => `  ${k}: ${v}`).join('\\n')}\\n\\n` +\n                            `By Actor:\\n${Object.entries(result.stats.eventsByActor).slice(0, 10).map(([k, v]) => `  ${k}: ${v}`).join('\\n')}\\n\\n` +\n                            `Time Range:\\n  Earliest: ${result.stats.timeRange.earliest}\\n  Latest: ${result.stats.timeRange.latest}`;\n                    }\n                    else if (result.events) {\n                        content = `üìÖ Timeline Events (${result.events.length} of ${result.total})\\n\\n`;\n                        result.events.forEach((event, i) => {\n                            content += `${i + 1}. [${event.timestamp}] ${event.description}\\n`;\n                            content += `   Actor: ${event.actor} | Aggregate: ${event.aggregate}\\n`;\n                            if (Object.keys(event.payload).length > 0) {\n                                content += `   Payload: ${JSON.stringify(event.payload).substring(0, 100)}...\\n`;\n                            }\n                            content += '\\n';\n                        });\n                        if (result.hasMore) {\n                            content += `\\nüí° More results available. Use --limit to see more.`;\n                        }\n                    }\n                }\n                else {\n                    content = `‚ùå Query failed: ${result.error}`;\n                }\n                const resultEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, resultEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Timeline query failed: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /rewind - Time machine: rewind to timestamp\n        // ============================================\n        if (trimmedInput.startsWith(\"/rewind\")) {\n            try {\n                const { executeRewindTo } = await import(\"../tools/rewind-to-tool.js\");\n                // Parse command: /rewind <timestamp> [--output <dir>] [--no-files]\n                const args = trimmedInput.slice(7).trim();\n                if (!args || args === '--help') {\n                    const helpEntry = {\n                        type: \"assistant\",\n                        content: `‚è∞ Rewind Command (Time Machine)\\n\\n` +\n                            `Usage: /rewind <timestamp> [options]\\n\\n` +\n                            `Options:\\n` +\n                            `  <timestamp>         Target time (ISO format: \"2025-11-28T12:00:00Z\")\\n` +\n                            `  --output <dir>      Custom output directory\\n` +\n                            `  --git-mode <mode>   Git materialization mode:\\n` +\n                            `      none            No git information at all\\n` +\n                            `      metadata        Just git_state.json (default)\\n` +\n                            `      full            Full .git repository + checkout\\n` +\n                            `  --create-session    Create a new grokinou session in rewinded directory\\n` +\n                            `  --auto-checkout     Automatically cd to rewinded directory after rewind\\n` +\n                            `  --compare-with <dir> Compare rewinded state with another directory\\n` +\n                            `  --no-files          Don't include file contents\\n` +\n                            `  --no-conversations  Don't include conversation history\\n` +\n                            `  --no-git            Alias for --git-mode none\\n\\n` +\n                            `Examples:\\n` +\n                            `  /rewind \"2025-11-28T10:00:00Z\"\\n` +\n                            `  /rewind \"2025-11-27T18:00:00Z\" --output ~/recovered\\n` +\n                            `  /rewind \"2025-11-28T12:00:00Z\" --git-mode full --create-session --auto-checkout\\n` +\n                            `  /rewind \"2025-11-28T12:00:00Z\" --compare-with ~/current-project\\n` +\n                            `  /rewind \"2025-11-28T12:00:00Z\" --no-files --git-mode none\\n\\n` +\n                            `‚ö†Ô∏è This creates a NEW directory with reconstructed state (non-destructive)\\n\\n` +\n                            `Git Modes Explained:\\n` +\n                            `  ‚Ä¢ none     : No git data (just files + conversations)\\n` +\n                            `  ‚Ä¢ metadata : git_state.json with commit hash/branch (fast)\\n` +\n                            `  ‚Ä¢ full     : Complete .git repo you can work with (slow)\\n\\n` +\n                            `Advanced Features:\\n` +\n                            `  --auto-checkout: Changes your working directory to the rewinded state\\n` +\n                            `  --compare-with: Shows detailed diff between rewinded and target directory\\n` +\n                            `  --create-session: Bridges /rewind and /new-session functionality`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, helpEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Extract timestamp (first quoted string or first arg)\n                const timestampMatch = args.match(/\"([^\"]+)\"|^(\\S+)/);\n                if (!timestampMatch) {\n                    throw new Error('Missing timestamp. Usage: /rewind \"2025-11-28T12:00:00Z\"');\n                }\n                const targetTimestamp = timestampMatch[1] || timestampMatch[2];\n                const params = { targetTimestamp };\n                // Parse options\n                if (args.includes('--no-files'))\n                    params.includeFiles = false;\n                if (args.includes('--no-conversations'))\n                    params.includeConversations = false;\n                if (args.includes('--no-git'))\n                    params.gitMode = 'none';\n                if (args.includes('--create-session'))\n                    params.createSession = true;\n                if (args.includes('--auto-checkout'))\n                    params.autoCheckout = true;\n                // Parse --git-mode\n                const gitModeMatch = args.match(/--git-mode\\s+(?:\"([^\"]+)\"|(\\S+))/);\n                if (gitModeMatch) {\n                    const mode = gitModeMatch[1] || gitModeMatch[2];\n                    if (['none', 'metadata', 'full'].includes(mode)) {\n                        params.gitMode = mode;\n                    }\n                    else {\n                        throw new Error(`Invalid git-mode: ${mode}. Must be: none, metadata, or full`);\n                    }\n                }\n                const outputMatch = args.match(/--output\\s+(?:\"([^\"]+)\"|(\\S+))/);\n                if (outputMatch) {\n                    params.outputDir = outputMatch[1] || outputMatch[2];\n                }\n                const compareMatch = args.match(/--compare-with\\s+(?:\"([^\"]+)\"|(\\S+))/);\n                if (compareMatch) {\n                    params.compareWith = compareMatch[1] || compareMatch[2];\n                }\n                // Execute rewind\n                const infoEntry = {\n                    type: \"assistant\",\n                    content: `‚è≥ Starting rewind to ${targetTimestamp}...\\n` +\n                        `This may take a few moments...`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, infoEntry]);\n                const result = await executeRewindTo(params);\n                let content = '';\n                if (result.success) {\n                    content = `‚úÖ Rewind Complete!\\n\\n` +\n                        `${result.summary}\\n\\n` +\n                        `üìä Stats:\\n` +\n                        `  Events Replayed: ${result.eventsReplayed}\\n` +\n                        `  Files Restored: ${result.filesRestored}\\n` +\n                        `  Duration: ${result.durationMs}ms\\n` +\n                        `  Snapshot Used: ${result.snapshotUsed || 'None (full replay)'}\\n`;\n                    if (result.sessionCreated) {\n                        content += `  Session Created: #${result.sessionCreated.sessionId} (${result.sessionCreated.sessionName})\\n`;\n                    }\n                    if (result.autoCheckedOut) {\n                        content += `  üìÇ Working Directory Changed:\\n`;\n                        content += `     From: ${result.previousWorkingDir}\\n`;\n                        content += `     To:   ${result.outputDirectory}\\n`;\n                    }\n                    if (result.comparisonReport) {\n                        const report = result.comparisonReport;\n                        content += `\\nüìä Comparison with ${report.compareDirectory}:\\n`;\n                        content += `  Total Files: ${report.totalFiles}\\n`;\n                        content += `  üÜï Added: ${report.added}\\n`;\n                        content += `  ‚ùå Deleted: ${report.deleted}\\n`;\n                        content += `  ‚úèÔ∏è  Modified: ${report.modified}\\n`;\n                        content += `  ‚úÖ Unchanged: ${report.unchanged}\\n`;\n                        if (report.modified > 0 || report.added > 0 || report.deleted > 0) {\n                            content += `\\n  Key Changes:\\n`;\n                            const changes = report.files.filter(f => f.status !== 'unchanged').slice(0, 5);\n                            changes.forEach(f => {\n                                const icon = f.status === 'added' ? 'üÜï' : f.status === 'deleted' ? '‚ùå' : '‚úèÔ∏è';\n                                content += `    ${icon} ${f.path}\\n`;\n                            });\n                            if (report.files.filter(f => f.status !== 'unchanged').length > 5) {\n                                content += `    ... and ${report.files.filter(f => f.status !== 'unchanged').length - 5} more\\n`;\n                            }\n                        }\n                    }\n                    content += `\\n`;\n                    if (result.sessionCreated) {\n                        content += `üí° Use /switch-session ${result.sessionCreated.sessionId} to activate the rewinded session\\n`;\n                    }\n                    if (result.autoCheckedOut) {\n                        content += `üí° You are now in the rewinded directory!\\n`;\n                    }\n                    content += `\\nNext Steps:\\n${result.nextSteps?.join('\\n')}`;\n                }\n                else {\n                    content = `‚ùå Rewind failed: ${result.error}`;\n                }\n                const resultEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, resultEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Rewind failed: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /snapshots - List available snapshots\n        // ============================================\n        if (trimmedInput === \"/snapshots\" || trimmedInput.startsWith(\"/snapshots\")) {\n            try {\n                const { getAvailableTimePoints } = await import(\"../tools/rewind-to-tool.js\");\n                const timePoints = await getAvailableTimePoints();\n                let content = `üì∏ Available Time Points for Rewinding\\n\\n`;\n                // Show snapshots\n                content += `‚îÅ‚îÅ‚îÅ Snapshots (Optimized Rewind Points) ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                if (timePoints.snapshots.length === 0) {\n                    content += `No snapshots available yet.\\n\\n`;\n                }\n                else {\n                    timePoints.snapshots.forEach((snapshot, i) => {\n                        content += `${i + 1}. ${snapshot.timestamp}\\n`;\n                        content += `   Events: ${snapshot.eventCount}`;\n                        if (snapshot.sessionName) {\n                            content += ` | Session: ${snapshot.sessionName}`;\n                        }\n                        content += '\\n\\n';\n                    });\n                }\n                // Show recent events\n                content += `‚îÅ‚îÅ‚îÅ Recent Events (Precise Rewind) ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                if (timePoints.recentEvents.length === 0) {\n                    content += `No recent events.\\n\\n`;\n                }\n                else {\n                    timePoints.recentEvents.slice(0, 10).forEach((event, i) => {\n                        content += `${i + 1}. [${event.timestamp}] ${event.description}\\n`;\n                    });\n                    if (timePoints.recentEvents.length > 10) {\n                        content += `\\n... and ${timePoints.recentEvents.length - 10} more\\n`;\n                    }\n                }\n                content += `\\nüí° Use /rewind \"<timestamp>\" to time-travel to any point above.`;\n                const resultEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, resultEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to list snapshots: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /rewind-history - Show history of all rewind operations\n        // ============================================\n        if (trimmedInput === \"/rewind-history\" || trimmedInput.startsWith(\"/rewind-history\")) {\n            try {\n                const { executeTimelineQuery } = await import(\"../tools/timeline-query-tool.js\");\n                // Query all REWIND events from timeline\n                const result = await executeTimelineQuery({\n                    categories: ['REWIND'],\n                    limit: 50,\n                    order: 'desc',\n                });\n                if (!result.success || !result.events || result.events.length === 0) {\n                    const noRewindsEntry = {\n                        type: \"assistant\",\n                        content: `üï∞Ô∏è  Rewind History\\n\\n` +\n                            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                            `No rewind operations found.\\n\\n` +\n                            `üí° Use /rewind \"<timestamp>\" to perform your first time-travel!`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, noRewindsEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Group rewinds by completed operations\n                const rewindOps = new Map();\n                result.events.forEach((event) => {\n                    const aggregateId = event.aggregate;\n                    if (!rewindOps.has(aggregateId)) {\n                        rewindOps.set(aggregateId, []);\n                    }\n                    rewindOps.get(aggregateId).push(event);\n                });\n                let content = `üï∞Ô∏è  Rewind History (${rewindOps.size} operations)\\n\\n`;\n                content += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                let opIndex = 1;\n                for (const [targetTimestamp, events] of rewindOps) {\n                    // Find REWIND_COMPLETED or REWIND_FAILED event\n                    const completedEvent = events.find(e => e.description.includes('REWIND_COMPLETED'));\n                    const failedEvent = events.find(e => e.description.includes('REWIND_FAILED'));\n                    const startedEvent = events.find(e => e.description.includes('REWIND_STARTED'));\n                    const status = completedEvent ? '‚úÖ' : failedEvent ? '‚ùå' : '‚è≥';\n                    const statusText = completedEvent ? 'Completed' : failedEvent ? 'Failed' : 'In Progress';\n                    const targetDate = new Date(parseInt(targetTimestamp));\n                    const rewindDate = startedEvent ? new Date(startedEvent.timestamp) : new Date();\n                    content += `${opIndex}. ${status} ${statusText}\\n`;\n                    content += `   Target Time: ${targetDate.toLocaleString()}\\n`;\n                    content += `   Performed: ${rewindDate.toLocaleString()}\\n`;\n                    if (completedEvent && completedEvent.payload) {\n                        const payload = completedEvent.payload;\n                        if (payload.duration_ms) {\n                            content += `   Duration: ${payload.duration_ms}ms\\n`;\n                        }\n                        if (payload.session_created) {\n                            content += `   Session Created: Yes\\n`;\n                        }\n                        if (payload.auto_checked_out) {\n                            content += `   Auto Checkout: Yes\\n`;\n                        }\n                    }\n                    if (failedEvent && failedEvent.payload?.error) {\n                        content += `   Error: ${failedEvent.payload.error}\\n`;\n                    }\n                    content += `\\n`;\n                    opIndex++;\n                    if (opIndex > 20) {\n                        content += `... and ${rewindOps.size - 20} more operations\\n`;\n                        break;\n                    }\n                }\n                content += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                content += `üí° Use /rewind \"<timestamp>\" to perform a new time-travel\\n`;\n                content += `üí° Use /timeline --category REWIND for detailed event log`;\n                const resultEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, resultEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to load rewind history: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /list_tools - List all tools available to LLMs\n        // ============================================\n        if (trimmedInput === \"/list_tools\") {\n            try {\n                // Dynamically import getAllGrokTools to get current tools\n                const { getAllGrokTools } = await import(\"../grok/tools.js\");\n                const allTools = await getAllGrokTools();\n                // Check for conditional tools\n                const hasMorphKey = !!process.env.MORPH_API_KEY;\n                // Group tools by category\n                const fileOps = [];\n                const execution = [];\n                const search = [];\n                const taskMgmt = [];\n                const sessionMgmt = [];\n                const system = [];\n                const mcpTools = [];\n                allTools.forEach((tool) => {\n                    const name = tool.function.name;\n                    const desc = tool.function.description;\n                    const firstLine = desc.split('\\n')[0];\n                    const truncatedDesc = firstLine.length > 100 ? firstLine.substring(0, 100) + '...' : firstLine;\n                    const formattedTool = `   üîß ${name}\\n      ${truncatedDesc}`;\n                    // Categorize tools\n                    if (['view_file', 'create_file', 'str_replace_editor', 'edit_file', 'apply_patch'].includes(name)) {\n                        fileOps.push(formattedTool);\n                    }\n                    else if (['bash'].includes(name)) {\n                        execution.push(formattedTool);\n                    }\n                    else if (['search'].includes(name)) {\n                        search.push(formattedTool);\n                    }\n                    else if (['create_todo_list', 'update_todo_list'].includes(name)) {\n                        taskMgmt.push(formattedTool);\n                    }\n                    else if (['session_list', 'session_switch', 'session_new', 'session_rewind'].includes(name)) {\n                        sessionMgmt.push(formattedTool);\n                    }\n                    else if (['timeline_query', 'rewind_to', 'list_time_points'].includes(name)) {\n                        sessionMgmt.push(formattedTool); // Timeline tools in session management\n                    }\n                    else if (['get_my_identity'].includes(name)) {\n                        system.push(formattedTool);\n                    }\n                    else {\n                        // MCP or other external tools\n                        mcpTools.push(formattedTool);\n                    }\n                });\n                // Add Morph edit_file tool if not present (show as unavailable)\n                if (!hasMorphKey && !allTools.some(t => t.function.name === 'edit_file')) {\n                    const morphTool = `   üîß edit_file (Morph Fast Apply)\\n` +\n                        `      ‚ö†Ô∏è  NOT CONFIGURED - Requires MORPH_API_KEY environment variable\\n` +\n                        `      AI-powered fast code editing with intelligent diff application`;\n                    fileOps.push(morphTool);\n                }\n                let content = `üõ†Ô∏è  LLM Tools Available\\n` +\n                    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                    `üìä Total Active Tools: ${allTools.length}\\n`;\n                if (!hasMorphKey) {\n                    content += `‚ö†Ô∏è  1 tool requires configuration\\n`;\n                }\n                content += `\\n`;\n                if (fileOps.length > 0) {\n                    content += `üìÅ File Operations (${fileOps.length}):\\n${fileOps.join('\\n\\n')}\\n\\n`;\n                }\n                if (execution.length > 0) {\n                    content += `‚ö° Execution (${execution.length}):\\n${execution.join('\\n\\n')}\\n\\n`;\n                }\n                if (search.length > 0) {\n                    content += `üîç Search (${search.length}):\\n${search.join('\\n\\n')}\\n\\n`;\n                }\n                if (taskMgmt.length > 0) {\n                    content += `üìã Task Management (${taskMgmt.length}):\\n${taskMgmt.join('\\n\\n')}\\n\\n`;\n                }\n                if (sessionMgmt.length > 0) {\n                    content += `üîÄ Session Management (${sessionMgmt.length}):\\n${sessionMgmt.join('\\n\\n')}\\n\\n`;\n                }\n                if (system.length > 0) {\n                    content += `ü§ñ System (${system.length}):\\n${system.join('\\n\\n')}\\n\\n`;\n                }\n                if (mcpTools.length > 0) {\n                    content += `üîå MCP Tools (${mcpTools.length}):\\n${mcpTools.join('\\n\\n')}\\n\\n`;\n                }\n                else {\n                    // Show MCP section even if empty, to inform users about the feature\n                    content += `üîå MCP Tools (0):\\n` +\n                        `   ‚ÑπÔ∏è  No MCP servers configured\\n` +\n                        `   üìù Configure external tools in ~/.grok/mcp-config.json\\n` +\n                        `   üîó Visit: https://modelcontextprotocol.io/introduction\\n\\n`;\n                }\n                content += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n                if (!hasMorphKey) {\n                    content += `üí° To enable edit_file (Morph):\\n` +\n                        `   export MORPH_API_KEY=your-api-key\\n` +\n                        `   Get your key at: https://morph.so\\n\\n`;\n                }\n                content += `üí° Use /help to see user commands`;\n                const toolsEntry = {\n                    type: \"assistant\",\n                    content,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, toolsEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to list tools: ${error?.message || 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /new-session [options] - Create a new session\n        // ============================================\n        if (trimmedInput.startsWith(\"/new-session\")) {\n            // DEBUG: Log the full command\n            console.log('üêõ [DEBUG] /new-session command:', trimmedInput);\n            try {\n                const parts = trimmedInput.split(/\\s+/);\n                const args = parts.slice(1);\n                console.log('üêõ [DEBUG] Parsed args:', args);\n                // Parse options\n                let importHistory = false;\n                let specificModel;\n                let specificProvider;\n                let targetDirectory;\n                let fromSessionId;\n                let fromDate;\n                let toDate;\n                let cloneGit = false;\n                let copyFiles = false;\n                let fromRewind;\n                for (let i = 0; i < args.length; i++) {\n                    const arg = args[i];\n                    if (arg === '--import-history') {\n                        importHistory = true;\n                    }\n                    else if (arg === '--model' && args[i + 1]) {\n                        specificModel = args[i + 1];\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--provider' && args[i + 1]) {\n                        specificProvider = args[i + 1];\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--directory' && args[i + 1]) {\n                        targetDirectory = args[i + 1];\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--from-session' && args[i + 1]) {\n                        fromSessionId = parseInt(args[i + 1], 10);\n                        if (isNaN(fromSessionId)) {\n                            throw new Error(`Invalid session ID: ${args[i + 1]}`);\n                        }\n                        importHistory = true; // Implicit\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--from-date' && args[i + 1]) {\n                        fromDate = parseDate(args[i + 1]);\n                        importHistory = true; // Implicit\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--to-date' && args[i + 1]) {\n                        toDate = parseDate(args[i + 1]);\n                        importHistory = true; // Implicit\n                        i++; // Skip next arg\n                    }\n                    else if (arg === '--date-range' && args[i + 1] && args[i + 2]) {\n                        fromDate = parseDate(args[i + 1]);\n                        toDate = parseDate(args[i + 2]);\n                        importHistory = true; // Implicit\n                        i += 2; // Skip next 2 args\n                    }\n                    else if (arg === '--clone-git') {\n                        cloneGit = true;\n                    }\n                    else if (arg === '--copy-files') {\n                        copyFiles = true;\n                    }\n                    else if (arg === '--from-rewind' && args[i + 1]) {\n                        fromRewind = args[i + 1];\n                        i++; // Skip next arg\n                    }\n                }\n                // Validate date range\n                if (fromDate && toDate && fromDate > toDate) {\n                    throw new Error('--from-date must be before --to-date');\n                }\n                // Build date range for filtering\n                const dateRange = (fromDate || toDate) ? {\n                    start: fromDate || new Date(0), // Beginning of time if not specified\n                    end: toDate || new Date() // Now if not specified\n                } : undefined;\n                // Determine target directory (default: current directory)\n                const targetWorkdir = targetDirectory\n                    ? (targetDirectory.startsWith('/') ? targetDirectory : `${process.cwd()}/${targetDirectory}`)\n                    : process.cwd();\n                console.log('üêõ [DEBUG] Target directory:', targetWorkdir);\n                console.log('üêõ [DEBUG] Current directory:', process.cwd());\n                // Verify/create target directory\n                const fs = await import('fs');\n                if (!fs.existsSync(targetWorkdir)) {\n                    // Ask for confirmation to create directory\n                    const shouldCreate = true; // TODO: Add confirmation dialog\n                    if (shouldCreate) {\n                        fs.mkdirSync(targetWorkdir, { recursive: true });\n                    }\n                    else {\n                        throw new Error(`Directory does not exist: ${targetWorkdir}`);\n                    }\n                }\n                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n                // Handle directory initialization options\n                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n                // --from-rewind: Use rewind to initialize directory (highest priority)\n                if (fromRewind) {\n                    const infoEntry = {\n                        type: \"assistant\",\n                        content: `‚è≥ Initializing directory from rewind at ${fromRewind}...\\n` +\n                            `This may take a moment...`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, infoEntry]);\n                    const { executeRewindTo } = await import(\"../tools/rewind-to-tool.js\");\n                    const rewindResult = await executeRewindTo({\n                        targetTimestamp: fromRewind,\n                        outputDir: targetWorkdir,\n                        includeFiles: true,\n                        includeConversations: importHistory,\n                        gitMode: 'full', // Always use full git mode for from-rewind\n                        createSession: false, // We'll create session ourselves\n                    });\n                    if (!rewindResult.success) {\n                        throw new Error(`Rewind failed: ${rewindResult.error}`);\n                    }\n                    const rewindInfoEntry = {\n                        type: \"assistant\",\n                        content: `‚úÖ Directory initialized from rewind\\n` +\n                            `   Files Restored: ${rewindResult.filesRestored}\\n` +\n                            `   Events Replayed: ${rewindResult.eventsReplayed}\\n` +\n                            `   Duration: ${rewindResult.durationMs}ms`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, rewindInfoEntry]);\n                }\n                // --clone-git: Clone current git repository\n                else if (cloneGit) {\n                    const infoEntry = {\n                        type: \"assistant\",\n                        content: `‚è≥ Cloning Git repository to ${targetWorkdir}...\\n` +\n                            `This may take a moment...`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, infoEntry]);\n                    const { exec } = await import('child_process');\n                    const { promisify } = await import('util');\n                    const execAsync = promisify(exec);\n                    const currentDir = process.cwd();\n                    const gitDir = `${currentDir}/.git`;\n                    if (!fs.existsSync(gitDir)) {\n                        throw new Error('Not in a Git repository. Cannot use --clone-git');\n                    }\n                    try {\n                        // Clone the current repo to target directory\n                        await execAsync(`git clone \"${currentDir}\" \"${targetWorkdir}_temp\"`);\n                        // Move contents from temp to target\n                        await execAsync(`cp -r \"${targetWorkdir}_temp/\"* \"${targetWorkdir}/\" 2>/dev/null || true`);\n                        await execAsync(`cp -r \"${targetWorkdir}_temp/\".* \"${targetWorkdir}/\" 2>/dev/null || true`);\n                        // Remove temp directory\n                        await execAsync(`rm -rf \"${targetWorkdir}_temp\"`);\n                        const cloneInfoEntry = {\n                            type: \"assistant\",\n                            content: `‚úÖ Git repository cloned successfully`,\n                            timestamp: new Date(),\n                        };\n                        setChatHistory((prev) => [...prev, cloneInfoEntry]);\n                    }\n                    catch (error) {\n                        throw new Error(`Git clone failed: ${error.message}`);\n                    }\n                }\n                // --copy-files: Copy files from current directory (excluding .git)\n                else if (copyFiles) {\n                    const infoEntry = {\n                        type: \"assistant\",\n                        content: `‚è≥ Copying files to ${targetWorkdir}...\\n` +\n                            `This may take a moment...`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, infoEntry]);\n                    const { exec } = await import('child_process');\n                    const { promisify } = await import('util');\n                    const execAsync = promisify(exec);\n                    const currentDir = process.cwd();\n                    try {\n                        // Copy all files except .git, node_modules, and hidden files\n                        await execAsync(`rsync -av --exclude='.git' --exclude='node_modules' --exclude='.*' \"${currentDir}/\" \"${targetWorkdir}/\" 2>/dev/null || ` +\n                            `cp -r \"${currentDir}/\"* \"${targetWorkdir}/\" 2>/dev/null || true`);\n                        const copyInfoEntry = {\n                            type: \"assistant\",\n                            content: `‚úÖ Files copied successfully (excluding .git)`,\n                            timestamp: new Date(),\n                        };\n                        setChatHistory((prev) => [...prev, copyInfoEntry]);\n                    }\n                    catch (error) {\n                        throw new Error(`File copy failed: ${error.message}`);\n                    }\n                }\n                // Determine model and provider\n                const currentSession = sessionManager.getCurrentSession();\n                const targetModel = specificModel || currentSession?.default_model || agent.getCurrentModel();\n                const targetProvider = specificProvider ||\n                    (specificModel ? providerManager.detectProvider(specificModel) : null) ||\n                    currentSession?.default_provider ||\n                    providerManager.detectProvider(agent.getCurrentModel()) ||\n                    'grok';\n                if (!targetProvider) {\n                    throw new Error(`Cannot determine provider for model: ${targetModel}`);\n                }\n                // Get API key for the provider\n                const apiKey = agent.getApiKey();\n                if (!apiKey) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `‚ùå No API key found for provider: ${targetProvider}\\n\\n` +\n                            `Please configure it first:\\n` +\n                            `/apikey ${targetProvider} <your-key>`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Create the new session\n                console.log('üêõ [DEBUG] Calling createNewSession with:', {\n                    workdir: targetWorkdir,\n                    provider: targetProvider,\n                    model: targetModel,\n                    importHistory,\n                    fromSessionId\n                });\n                const { session, history, importWarning } = await sessionManager.createNewSession(targetWorkdir, targetProvider, targetModel, apiKey, {\n                    importHistory,\n                    fromSessionId,\n                    dateRange\n                });\n                console.log('üêõ [DEBUG] Session created:', session.id);\n                console.log('üêõ [DEBUG] History length:', history.length);\n                console.log('üêõ [DEBUG] Import warning:', importWarning || 'none');\n                // Update agent with new session's model/provider\n                const providerConfig = providerManager.getProviderForModel(targetModel);\n                if (!providerConfig) {\n                    throw new Error(`Unknown provider for model: ${targetModel}`);\n                }\n                await agent.switchToModel(targetModel, apiKey, providerConfig.baseURL);\n                // CRITICAL: Set switching flag to prevent auto-commit during state updates\n                // Same behavior as /switch-session for consistency\n                if (isSwitchingRef) {\n                    isSwitchingRef.current = true;\n                }\n                // CRITICAL: Change working directory if creating session in different directory\n                const currentWorkdir = process.cwd();\n                const dirChanged = targetWorkdir !== currentWorkdir;\n                if (dirChanged) {\n                    // Change the Node process's current working directory\n                    process.chdir(targetWorkdir);\n                    // Verify the change was successful\n                    const newCwd = process.cwd();\n                    if (newCwd !== targetWorkdir) {\n                        throw new Error(`Failed to change directory from ${currentWorkdir} to ${targetWorkdir}\\n` +\n                            `Current directory is: ${newCwd}`);\n                    }\n                }\n                // CRITICAL: Replace chat history with the new session's history\n                // We update chatHistory first with just the loaded history (no confirmation yet)\n                // This ensures committedHistory and chatHistory are in sync momentarily\n                console.log('üêõ [DEBUG] Replacing chat history with', history.length, 'messages');\n                setChatHistory(history);\n                // Then update committedHistory to match (all loaded messages are \"committed\")\n                if (setCommittedHistory) {\n                    setCommittedHistory(history);\n                }\n                // Finally add the confirmation message\n                // This makes activeMessages = [confirmEntry] via the automatic useEffect calculation\n                console.log('üêõ [DEBUG] Creating confirmation message');\n                // Determine initialization mode\n                let initMode = '';\n                if (fromRewind) {\n                    initMode = `üï∞Ô∏è  **Directory Initialized:** From rewind at ${fromRewind}\\n\\n`;\n                }\n                else if (cloneGit) {\n                    initMode = `üì¶ **Directory Initialized:** Git repository cloned\\n\\n`;\n                }\n                else if (copyFiles) {\n                    initMode = `üìÑ **Directory Initialized:** Files copied from ${process.cwd()}\\n\\n`;\n                }\n                else {\n                    initMode = `üìÅ **Directory Initialized:** Empty (or existing files)\\n\\n`;\n                }\n                const confirmEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ **New Session Created** #${session.id}\\n\\n` +\n                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                        `üìÇ Working Directory: ${session.working_dir}\\n` +\n                        `ü§ñ Provider: ${session.default_provider}\\n` +\n                        `üì± Model: ${session.default_model}\\n` +\n                        `üí¨ Messages: ${history.length}${importHistory ? ' (imported)' : ''}\\n` +\n                        `üïê Created: ${new Date(session.created_at).toLocaleString()}\\n\\n` +\n                        initMode +\n                        (dirChanged\n                            ? `üìÇ **Directory Changed:**\\n` +\n                                `   From: ${currentWorkdir}\\n` +\n                                `   To:   ${targetWorkdir}\\n\\n` +\n                                `‚ö†Ô∏è  All relative paths now resolve to the new directory.\\n\\n`\n                            : `üìÇ **Directory:** Already in ${targetWorkdir}\\n\\n`) +\n                        (importHistory\n                            ? `üìã **History Imported**\\n` +\n                                (fromSessionId ? `   Source: Session #${fromSessionId}\\n` : `   Source: Current session\\n`) +\n                                (dateRange ? `   Date Range: ${dateRange.start.toLocaleDateString()} ‚Üí ${dateRange.end.toLocaleDateString()}\\n` : '') +\n                                `   Messages: ${history.length} imported\\n\\n` +\n                                (importWarning ? `${importWarning}\\n\\n` : '')\n                            : `üìÑ **Fresh Start**\\n` +\n                                `   This is a brand new conversation.\\n\\n`) +\n                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                        `You can now start a new conversation!\\n\\n` +\n                        `üí° Use /list_sessions to see all sessions\\n` +\n                        `üí° Use /switch-session <id> to switch back`,\n                    timestamp: new Date(),\n                };\n                console.log('üêõ [DEBUG] Adding confirmation message');\n                setChatHistory((prev) => [...prev, confirmEntry]);\n                // Allow auto-commit to resume after a small delay (let React finish batching)\n                setTimeout(() => {\n                    if (isSwitchingRef) {\n                        isSwitchingRef.current = false;\n                    }\n                }, 100);\n                console.log('üêõ [DEBUG] /new-session COMPLETE');\n            }\n            catch (error) {\n                // Reset switching flag on error\n                if (isSwitchingRef) {\n                    isSwitchingRef.current = false;\n                }\n                console.error('üî¥ [ERROR] /new-session failed:', error);\n                console.error('üî¥ [ERROR] Stack:', error.stack);\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to create new session: ${error?.message || 'Unknown error'}\\n\\n` +\n                        `Stack trace:\\n${error.stack}\\n\\n` +\n                        `Usage: /new-session [--import-history] [--model <name>] [--provider <name>]`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /apikey - Display API keys\n        // ============================================\n        if (trimmedInput === \"/apikey\") {\n            const currentProvider = providerManager.detectProvider(agent.getCurrentModel());\n            const info = providerManager.formatProviderList(currentProvider);\n            const infoEntry = {\n                type: \"assistant\",\n                content: info,\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, infoEntry]);\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /apikey <provider> <key> - Set API key\n        // ============================================\n        if (trimmedInput.startsWith(\"/apikey \") && !trimmedInput.includes(\" show \")) {\n            const parts = trimmedInput.split(\" \");\n            if (parts.length < 3) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Invalid syntax.\\n\\n` +\n                        `Usage:\\n` +\n                        `  /apikey <provider> <key>     - Set API key\\n` +\n                        `  /apikey show <provider>      - Show full key\\n\\n` +\n                        `Example:\\n` +\n                        `  /apikey claude sk-ant-api03-xxx`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n                clearInput();\n                return true;\n            }\n            const providerName = parts[1];\n            const apiKey = parts[2];\n            try {\n                providerManager.setApiKey(providerName, apiKey);\n                const maskedKey = providerManager.getMaskedApiKey(providerName);\n                const confirmEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ Set API key for ${providerName}\\n` +\n                        `üìù Saved to: ~/.grok/user-settings.json\\n` +\n                        `üîí Key masked: ${maskedKey}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, confirmEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Failed to set API key: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /apikey show <provider> - Show full key\n        // ============================================\n        if (trimmedInput.startsWith(\"/apikey show \")) {\n            const providerName = trimmedInput.split(\" \")[2];\n            const provider = providerManager.getProvider(providerName);\n            if (!provider || !provider.apiKey) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå No API key configured for provider: ${providerName}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n                clearInput();\n                return true;\n            }\n            const infoEntry = {\n                type: \"assistant\",\n                content: `üîê API Key for ${providerName}:\\n` +\n                    `${provider.apiKey}\\n\\n` +\n                    `‚ö†Ô∏è  Warning: Keep this key secret!`,\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, infoEntry]);\n            clearInput();\n            return true;\n        }\n        // ============================================\n        // /model-default <model> - Set global default\n        // ============================================\n        if (trimmedInput.startsWith(\"/model-default \")) {\n            const modelArg = trimmedInput.slice(15).trim();\n            const modelNames = availableModels.map((m) => m.model);\n            if (modelNames.includes(modelArg)) {\n                // Update user settings (global default)\n                updateDefaultModel(modelArg);\n                // Get current model for comparison\n                const currentModel = agent.getCurrentModel();\n                const confirmEntry = {\n                    type: \"assistant\",\n                    content: `‚úÖ Set ${modelArg} as global default model\\n` +\n                        `üìù Saved to: ~/.grok/user-settings.json\\n\\n` +\n                        `‚ÑπÔ∏è  Current session still using: ${currentModel}\\n` +\n                        `üí° Use /models ${modelArg} to switch this session too\\n\\n` +\n                        `This will be used for all NEW sessions.`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, confirmEntry]);\n            }\n            else {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Model \"${modelArg}\" not found.\\n\\n` +\n                        `Available models:\\n${modelNames.map(m => `  ‚Ä¢ ${m}`).join('\\n')}\\n\\n` +\n                        `To add a new model, edit ~/.grok/user-settings.json`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        if (trimmedInput === \"/models\") {\n            setShowModelSelection(true);\n            setSelectedModelIndex(0);\n            clearInput();\n            return true;\n        }\n        if (trimmedInput.startsWith(\"/models \")) {\n            const modelArg = trimmedInput.split(\" \")[1];\n            const modelNames = availableModels.map((m) => m.model);\n            if (modelNames.includes(modelArg)) {\n                // ‚úÖ NEW: Detect provider and get config\n                const providerConfig = providerManager.getProviderForModel(modelArg);\n                // DEBUG: Log provider config\n                console.log(`üîç DEBUG: Model=${modelArg}, Provider=${providerConfig?.name}, BaseURL=${providerConfig?.baseURL}, HasKey=${!!providerConfig?.apiKey}`);\n                if (!providerConfig) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `‚ùå Could not detect provider for model: ${modelArg}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    clearInput();\n                    return true;\n                }\n                // Check API key\n                if (!providerConfig.apiKey) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `‚ùå API key not configured for provider: ${providerConfig.name}\\n\\n` +\n                            `Set it now:\\n` +\n                            `  /apikey ${providerConfig.name} your-api-key-here\\n\\n` +\n                            `Or configure in ~/.grok/user-settings.json`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    clearInput();\n                    return true;\n                }\n                // ‚úÖ Switch with new provider config (async)\n                (async () => {\n                    const identityInfo = await agent.switchToModel(modelArg, providerConfig.apiKey, providerConfig.baseURL);\n                    updateCurrentModel(modelArg); // Update project current model\n                    const confirmEntry = {\n                        type: \"assistant\",\n                        content: `‚úÖ Switched to ${modelArg}\\n` +\n                            `üìù Provider: ${providerConfig.name}\\n` +\n                            `üîó Endpoint: ${providerConfig.baseURL}\\n` +\n                            `üíæ Saved to: .grok/settings.json\\n\\n` +\n                            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n` +\n                            `üîç Identity Verification:\\n${identityInfo}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, confirmEntry]);\n                })();\n                clearInput();\n                return true;\n            }\n            else {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `‚ùå Model \"${modelArg}\" not found.\\n\\nAvailable models:\\n${modelNames.join(\"\\n\")}\n\nAvailable models: ${modelNames.join(\", \")}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        if (trimmedInput === \"/commit-and-push\") {\n            const userEntry = {\n                type: \"user\",\n                content: \"/commit-and-push\",\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, userEntry]);\n            setIsProcessing(true);\n            setIsStreaming(true);\n            try {\n                // First check if there are any changes at all\n                const initialStatusResult = await agent.executeBashCommand(\"git status --porcelain\");\n                if (!initialStatusResult.success ||\n                    !initialStatusResult.output?.trim()) {\n                    const noChangesEntry = {\n                        type: \"assistant\",\n                        content: \"No changes to commit. Working directory is clean.\",\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, noChangesEntry]);\n                    setIsProcessing(false);\n                    setIsStreaming(false);\n                    setInput(\"\");\n                    return true;\n                }\n                // Add all changes\n                const addResult = await agent.executeBashCommand(\"git add .\");\n                if (!addResult.success) {\n                    const addErrorEntry = {\n                        type: \"assistant\",\n                        content: `Failed to stage changes: ${addResult.error || \"Unknown error\"}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, addErrorEntry]);\n                    setIsProcessing(false);\n                    setIsStreaming(false);\n                    setInput(\"\");\n                    return true;\n                }\n                // Show that changes were staged\n                const addEntry = {\n                    type: \"tool_result\",\n                    content: \"Changes staged successfully\",\n                    timestamp: new Date(),\n                    toolCall: {\n                        id: `git_add_${Date.now()}`,\n                        type: \"function\",\n                        function: {\n                            name: \"bash\",\n                            arguments: JSON.stringify({ command: \"git add .\" }),\n                        },\n                    },\n                    toolResult: addResult,\n                };\n                setChatHistory((prev) => [...prev, addEntry]);\n                // Get staged changes for commit message generation\n                const diffResult = await agent.executeBashCommand(\"git diff --cached\");\n                // Generate commit message using AI\n                const commitPrompt = `Generate a concise, professional git commit message for these changes:\n\nGit Status:\n${initialStatusResult.output}\n\nGit Diff (staged changes):\n${diffResult.output || \"No staged changes shown\"}\n\nFollow conventional commit format (feat:, fix:, docs:, etc.) and keep it under 72 characters.\nRespond with ONLY the commit message, no additional text.`;\n                let commitMessage = \"\";\n                let streamingEntry = null;\n                for await (const chunk of agent.processUserMessageStream(commitPrompt)) {\n                    if (chunk.type === \"content\" && chunk.content) {\n                        if (!streamingEntry) {\n                            const newEntry = {\n                                type: \"assistant\",\n                                content: `Generating commit message...\\n\\n${chunk.content}`,\n                                timestamp: new Date(),\n                                isStreaming: true,\n                            };\n                            setChatHistory((prev) => [...prev, newEntry]);\n                            streamingEntry = newEntry;\n                            commitMessage = chunk.content;\n                        }\n                        else {\n                            commitMessage += chunk.content;\n                            setChatHistory((prev) => prev.map((entry, idx) => idx === prev.length - 1 && entry.isStreaming\n                                ? {\n                                    ...entry,\n                                    content: `Generating commit message...\\n\\n${commitMessage}`,\n                                }\n                                : entry));\n                        }\n                    }\n                    else if (chunk.type === \"done\") {\n                        if (streamingEntry) {\n                            setChatHistory((prev) => prev.map((entry) => entry.isStreaming\n                                ? {\n                                    ...entry,\n                                    content: `Generated commit message: \"${commitMessage.trim()}\"`,\n                                    isStreaming: false,\n                                }\n                                : entry));\n                        }\n                        break;\n                    }\n                }\n                // Execute the commit\n                const cleanCommitMessage = commitMessage\n                    .trim()\n                    .replace(/^[\"']|[\"']$/g, \"\");\n                const commitCommand = `git commit -m \"${cleanCommitMessage}\"`;\n                const commitResult = await agent.executeBashCommand(commitCommand);\n                const commitEntry = {\n                    type: \"tool_result\",\n                    content: commitResult.success\n                        ? commitResult.output || \"Commit successful\"\n                        : commitResult.error || \"Commit failed\",\n                    timestamp: new Date(),\n                    toolCall: {\n                        id: `git_commit_${Date.now()}`,\n                        type: \"function\",\n                        function: {\n                            name: \"bash\",\n                            arguments: JSON.stringify({ command: commitCommand }),\n                        },\n                    },\n                    toolResult: commitResult,\n                };\n                setChatHistory((prev) => [...prev, commitEntry]);\n                // If commit was successful, push to remote\n                if (commitResult.success) {\n                    // First try regular push, if it fails try with upstream setup\n                    let pushResult = await agent.executeBashCommand(\"git push\");\n                    let pushCommand = \"git push\";\n                    if (!pushResult.success &&\n                        pushResult.error?.includes(\"no upstream branch\")) {\n                        pushCommand = \"git push -u origin HEAD\";\n                        pushResult = await agent.executeBashCommand(pushCommand);\n                    }\n                    const pushEntry = {\n                        type: \"tool_result\",\n                        content: pushResult.success\n                            ? pushResult.output || \"Push successful\"\n                            : pushResult.error || \"Push failed\",\n                        timestamp: new Date(),\n                        toolCall: {\n                            id: `git_push_${Date.now()}`,\n                            type: \"function\",\n                            function: {\n                                name: \"bash\",\n                                arguments: JSON.stringify({ command: pushCommand }),\n                            },\n                        },\n                        toolResult: pushResult,\n                    };\n                    setChatHistory((prev) => [...prev, pushEntry]);\n                }\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `Error during commit and push: ${error.message}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            setIsProcessing(false);\n            setIsStreaming(false);\n            clearInput();\n            return true;\n        }\n        const directBashCommands = [\n            \"ls\",\n            \"pwd\",\n            \"cd\",\n            \"cat\",\n            \"mkdir\",\n            \"touch\",\n            \"echo\",\n            \"grep\",\n            \"find\",\n            \"cp\",\n            \"mv\",\n            \"rm\",\n        ];\n        const firstWord = trimmedInput.split(\" \")[0];\n        if (directBashCommands.includes(firstWord)) {\n            const userEntry = {\n                type: \"user\",\n                content: trimmedInput,\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, userEntry]);\n            try {\n                // Temporarily enable auto-mode for direct bash commands\n                // These commands should execute immediately without confirmation\n                const confirmationService = ConfirmationService.getInstance();\n                const previousFlags = confirmationService.getSessionFlags();\n                const wasAutoEnabled = previousFlags.bashCommands;\n                // Enable bashCommands flag for direct execution\n                confirmationService.setSessionFlag('bashCommands', true);\n                const result = await agent.executeBashCommand(trimmedInput);\n                // Restore previous flag state\n                confirmationService.setSessionFlag('bashCommands', wasAutoEnabled);\n                const commandEntry = {\n                    type: \"tool_result\",\n                    content: result.success\n                        ? result.output || \"Command completed\"\n                        : result.error || \"Command failed\",\n                    timestamp: new Date(),\n                    toolCall: {\n                        id: `bash_${Date.now()}`,\n                        type: \"function\",\n                        function: {\n                            name: \"bash\",\n                            arguments: JSON.stringify({ command: trimmedInput }),\n                        },\n                    },\n                    toolResult: result,\n                };\n                setChatHistory((prev) => [...prev, commandEntry]);\n            }\n            catch (error) {\n                const errorEntry = {\n                    type: \"assistant\",\n                    content: `Error executing command: ${error.message}`,\n                    timestamp: new Date(),\n                };\n                setChatHistory((prev) => [...prev, errorEntry]);\n            }\n            clearInput();\n            return true;\n        }\n        return false;\n    };\n    const processUserMessage = async (userInput) => {\n        const userEntry = {\n            type: \"user\",\n            content: userInput,\n            timestamp: new Date(),\n        };\n        setChatHistory((prev) => [...prev, userEntry]);\n        setIsProcessing(true);\n        clearInput();\n        try {\n            setIsStreaming(true);\n            if (!streamingBus) {\n                setStreamingContent(\"\");\n                setStreamingTools(null);\n                setStreamingToolResults(null);\n            }\n            const pendingToolResults = [];\n            let hasStarted = false;\n            const pendingBufferRef = { text: \"\" };\n            const lastFlushRef = { t: 0 };\n            const flush = () => {\n                if (!pendingBufferRef.text)\n                    return;\n                const appendText = pendingBufferRef.text;\n                pendingBufferRef.text = \"\";\n                setStreamingContent((prev) => prev + appendText);\n            };\n            for await (const chunk of agent.processUserMessageStream(userInput)) {\n                switch (chunk.type) {\n                    case \"content\":\n                        if (chunk.content) {\n                            hasStarted = true;\n                            if (streamingBus) {\n                                streamingBus.emitContent(chunk.content);\n                            }\n                            else {\n                                pendingBufferRef.text += chunk.content;\n                                const now = Date.now();\n                                if (now - lastFlushRef.t > 300) {\n                                    flush();\n                                    lastFlushRef.t = now;\n                                }\n                            }\n                        }\n                        break;\n                    case \"token_count\":\n                        if (chunk.tokenCount !== undefined) {\n                            setTokenCount(chunk.tokenCount);\n                        }\n                        break;\n                    case \"tool_calls\":\n                        if (chunk.toolCalls) {\n                            if (streamingBus)\n                                streamingBus.emitTools(chunk.toolCalls);\n                            else\n                                setStreamingTools(chunk.toolCalls);\n                        }\n                        break;\n                    case \"tool_result\":\n                        if (chunk.toolCall && chunk.toolResult) {\n                            const toolResultEntry = {\n                                type: \"tool_result\",\n                                content: chunk.toolResult.success\n                                    ? chunk.toolResult.output || \"Success\"\n                                    : chunk.toolResult.error || \"Error occurred\",\n                                timestamp: new Date(),\n                                toolCall: chunk.toolCall,\n                                toolResult: chunk.toolResult,\n                            };\n                            // buffer result (do not update history during streaming)\n                            pendingToolResults.push(toolResultEntry);\n                            if (streamingBus)\n                                streamingBus.emitToolResult({ content: toolResultEntry.content });\n                            else\n                                setStreamingToolResults((prev) => (prev ? [...prev, toolResultEntry] : [toolResultEntry]));\n                        }\n                        break;\n                    case \"done\":\n                        if (streamingBus)\n                            streamingBus.emitDone();\n                        else {\n                            flush();\n                            if (hasStarted) {\n                                setStreamingContent((current) => {\n                                    if (current) {\n                                        const finalEntry = {\n                                            type: \"assistant\",\n                                            content: current,\n                                            timestamp: new Date(),\n                                        };\n                                        setChatHistory((prev) => [...prev, finalEntry, ...pendingToolResults]);\n                                    }\n                                    return \"\";\n                                });\n                            }\n                            setStreamingTools(null);\n                            setStreamingToolResults(null);\n                        }\n                        setIsStreaming(false);\n                        break;\n                }\n            }\n        }\n        catch (error) {\n            const errorEntry = {\n                type: \"assistant\",\n                content: `Error: ${error.message}`,\n                timestamp: new Date(),\n            };\n            setChatHistory((prev) => [...prev, errorEntry]);\n            setIsStreaming(false);\n        }\n        setIsProcessing(false);\n        processingStartTime.current = 0;\n    };\n    return {\n        input,\n        cursorPosition,\n        showCommandSuggestions,\n        selectedCommandIndex,\n        showModelSelection,\n        selectedModelIndex,\n        commandSuggestions,\n        availableModels,\n        agent,\n        autoEditEnabled,\n    };\n}\n//# sourceMappingURL=use-input-handler.js.map"
  },
  "dist/hooks/use-enhanced-input.js": {
    "path": "dist/hooks/use-enhanced-input.js",
    "hash": "06aadfdb850dbb12861a1f5c29dba9b9266169b65c4281e6b4a3edeff6a690ca",
    "size": 13914,
    "timestamp": 1764704879301,
    "content": "import { useState, useCallback, useRef, useEffect } from \"react\";\nimport { deleteCharBefore, deleteCharAfter, deleteWordBefore, deleteWordAfter, insertText, moveToLineStart, moveToLineEnd, moveToPreviousWord, moveToNextWord, } from \"../utils/text-utils.js\";\nimport { useInputHistory } from \"./use-input-history.js\";\nimport { pasteManager } from \"../utils/paste-manager.js\";\nimport { pasteBurstDetector } from \"../utils/paste-burst-detector.js\";\nimport { imagePathManager } from \"../utils/image-path-detector.js\";\nexport function useEnhancedInput({ onSubmit, onEscape, onSpecialKey, disabled = false, multiline = false, } = {}) {\n    // Batch input and cursor state together to prevent double re-renders\n    const [inputState, setInputAndCursor] = useState({ text: \"\", cursor: 0 });\n    const input = inputState.text;\n    const cursorPosition = inputState.cursor;\n    const isMultilineRef = useRef(multiline);\n    // Use refs to avoid recreating handleInput on every change\n    const inputRef = useRef(input);\n    const cursorRef = useRef(cursorPosition);\n    useEffect(() => {\n        inputRef.current = input;\n        cursorRef.current = cursorPosition;\n    }, [input, cursorPosition]);\n    // Helper to update both at once\n    const setInputState = useCallback((text) => {\n        setInputAndCursor(prev => ({ text, cursor: Math.min(text.length, prev.cursor) }));\n    }, []);\n    const setCursorPositionState = useCallback((position) => {\n        setInputAndCursor(prev => ({ text: prev.text, cursor: Math.max(0, Math.min(prev.text.length, position)) }));\n    }, []);\n    const { addToHistory, navigateHistory, resetHistory, setOriginalInput, isNavigatingHistory, } = useInputHistory();\n    const setInput = useCallback((text) => {\n        setInputAndCursor({ text, cursor: Math.min(text.length, cursorPosition) });\n        if (!isNavigatingHistory()) {\n            setOriginalInput(text);\n        }\n    }, [cursorPosition, isNavigatingHistory, setOriginalInput]);\n    const setCursorPosition = useCallback((position) => {\n        setInputAndCursor(prev => ({ text: prev.text, cursor: Math.max(0, Math.min(prev.text.length, position)) }));\n    }, []);\n    const clearInput = useCallback(() => {\n        setInputAndCursor({ text: \"\", cursor: 0 });\n        setOriginalInput(\"\");\n    }, [setOriginalInput]);\n    const insertAtCursor = useCallback((text) => {\n        const result = insertText(input, cursorPosition, text);\n        setInputAndCursor({ text: result.text, cursor: result.position });\n        setOriginalInput(result.text);\n    }, [input, cursorPosition, setOriginalInput]);\n    const handleSubmit = useCallback(() => {\n        if (input.trim()) {\n            addToHistory(input);\n            onSubmit?.(input);\n            clearInput();\n        }\n    }, [input, addToHistory, onSubmit, clearInput]);\n    const handleInput = useCallback((inputChar, key) => {\n        if (disabled)\n            return;\n        // Use refs to get current values without depending on them\n        const currentInput = inputRef.current;\n        const currentCursor = cursorRef.current;\n        // Handle Ctrl+C - check multiple ways it could be detected\n        if ((key.ctrl && inputChar === \"c\") || inputChar === \"\\x03\") {\n            setInputAndCursor({ text: \"\", cursor: 0 });\n            setOriginalInput(\"\");\n            return;\n        }\n        // Allow special key handler to override default behavior\n        if (onSpecialKey?.(key)) {\n            return;\n        }\n        // Handle Escape\n        if (key.escape) {\n            onEscape?.();\n            return;\n        }\n        // Handle Enter/Return\n        if (key.return) {\n            if (multiline && key.shift) {\n                // Shift+Enter in multiline mode inserts newline\n                const result = insertText(currentInput, currentCursor, \"\\n\");\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n            else {\n                handleSubmit();\n            }\n            return;\n        }\n        // Handle history navigation\n        if ((key.upArrow || key.name === 'up') && !key.ctrl && !key.meta) {\n            const historyInput = navigateHistory(\"up\");\n            if (historyInput !== null) {\n                setInputAndCursor({ text: historyInput, cursor: historyInput.length });\n            }\n            return;\n        }\n        if ((key.downArrow || key.name === 'down') && !key.ctrl && !key.meta) {\n            const historyInput = navigateHistory(\"down\");\n            if (historyInput !== null) {\n                setInputAndCursor({ text: historyInput, cursor: historyInput.length });\n            }\n            return;\n        }\n        // Handle cursor movement - ignore meta flag for arrows as it's unreliable in terminals\n        // Only do word movement if ctrl is pressed AND no arrow escape sequence is in inputChar\n        if ((key.leftArrow || key.name === 'left') && key.ctrl && !inputChar.includes('[')) {\n            const newPos = moveToPreviousWord(currentInput, currentCursor);\n            setCursorPositionState(newPos);\n            return;\n        }\n        if ((key.rightArrow || key.name === 'right') && key.ctrl && !inputChar.includes('[')) {\n            const newPos = moveToNextWord(currentInput, currentCursor);\n            setCursorPositionState(newPos);\n            return;\n        }\n        // Handle regular cursor movement - single character (ignore meta flag)\n        if (key.leftArrow || key.name === 'left') {\n            const newPos = Math.max(0, currentCursor - 1);\n            setCursorPositionState(newPos);\n            return;\n        }\n        if (key.rightArrow || key.name === 'right') {\n            const newPos = Math.min(currentInput.length, currentCursor + 1);\n            setCursorPositionState(newPos);\n            return;\n        }\n        // Handle Home/End keys or Ctrl+A/E\n        if ((key.ctrl && inputChar === \"a\") || key.name === \"home\") {\n            setCursorPositionState(0); // Simple start of input\n            return;\n        }\n        if ((key.ctrl && inputChar === \"e\") || key.name === \"end\") {\n            setCursorPositionState(currentInput.length); // Simple end of input\n            return;\n        }\n        // Handle deletion - check multiple ways backspace might be detected\n        // Backspace can be detected in different ways depending on terminal\n        // In some terminals, backspace shows up as delete:true with empty inputChar\n        const isBackspace = key.backspace ||\n            key.name === 'backspace' ||\n            inputChar === '\\b' ||\n            inputChar === '\\x7f' ||\n            (key.delete && inputChar === '' && !key.shift);\n        if (isBackspace) {\n            // Check if cursor is at the end of a paste placeholder (atomic delete)\n            const pastePlaceholderInfo = pasteManager.findPlaceholderAtCursor(currentInput, currentCursor);\n            if (pastePlaceholderInfo) {\n                const { placeholder, start, end } = pastePlaceholderInfo;\n                const newInput = currentInput.slice(0, start) + currentInput.slice(end);\n                pasteManager.removeByPlaceholder(placeholder);\n                setInputAndCursor({ text: newInput, cursor: start });\n                setOriginalInput(newInput);\n                return;\n            }\n            // Check if cursor is at the end of an image placeholder (atomic delete)\n            const imagePlaceholderInfo = imagePathManager.findImagePlaceholderAtCursor(currentInput, currentCursor);\n            if (imagePlaceholderInfo) {\n                const { placeholder, start, end } = imagePlaceholderInfo;\n                const newInput = currentInput.slice(0, start) + currentInput.slice(end);\n                imagePathManager.removeImage(placeholder);\n                setInputAndCursor({ text: newInput, cursor: start });\n                setOriginalInput(newInput);\n                return;\n            }\n            if (key.ctrl || key.meta) {\n                // Ctrl/Cmd + Backspace: Delete word before cursor\n                const result = deleteWordBefore(currentInput, currentCursor);\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n            else {\n                // Regular backspace\n                const result = deleteCharBefore(currentInput, currentCursor);\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n            return;\n        }\n        // Handle forward delete (Del key) - but not if it was already handled as backspace above\n        if ((key.delete && inputChar !== '') || (key.ctrl && inputChar === \"d\")) {\n            if (key.ctrl || key.meta) {\n                // Ctrl/Cmd + Delete: Delete word after cursor\n                const result = deleteWordAfter(currentInput, currentCursor);\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n            else {\n                // Regular delete\n                const result = deleteCharAfter(currentInput, currentCursor);\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n            return;\n        }\n        // Handle Ctrl+K: Delete from cursor to end of line\n        if (key.ctrl && inputChar === \"k\") {\n            const lineEnd = moveToLineEnd(currentInput, currentCursor);\n            const newText = currentInput.slice(0, currentCursor) + currentInput.slice(lineEnd);\n            setInputState(newText);\n            setOriginalInput(newText);\n            return;\n        }\n        // Handle Ctrl+U: Delete from cursor to start of line\n        if (key.ctrl && inputChar === \"u\") {\n            const lineStart = moveToLineStart(currentInput, currentCursor);\n            const newText = currentInput.slice(0, lineStart) + currentInput.slice(currentCursor);\n            setInputAndCursor({ text: newText, cursor: lineStart });\n            setOriginalInput(newText);\n            return;\n        }\n        // Handle Ctrl+W: Delete word before cursor\n        if (key.ctrl && inputChar === \"w\") {\n            const result = deleteWordBefore(currentInput, currentCursor);\n            setInputAndCursor({ text: result.text, cursor: result.position });\n            setOriginalInput(result.text);\n            return;\n        }\n        // Handle Ctrl+X: Clear entire input\n        if (key.ctrl && inputChar === \"x\") {\n            setInputAndCursor({ text: \"\", cursor: 0 });\n            setOriginalInput(\"\");\n            return;\n        }\n        // Handle regular character input\n        if (inputChar && !key.ctrl && !key.meta) {\n            // Use paste burst detector to buffer rapid inputs (paste chunks)\n            const shouldBuffer = pasteBurstDetector.handleInput(inputChar, (bufferedContent) => {\n                // This callback is called after the burst ends (20ms timeout)\n                // Process the complete buffered content\n                // First, check if it's an image path (like Codex does)\n                const imageResult = imagePathManager.processPaste(bufferedContent);\n                if (imageResult.isImage) {\n                    // It's an image path! Insert placeholder\n                    // Use functional state update to avoid stale ref values\n                    let newText = '';\n                    setInputAndCursor(prev => {\n                        const result = insertText(prev.text, prev.cursor, imageResult.textToInsert);\n                        newText = result.text;\n                        return { text: result.text, cursor: result.position };\n                    });\n                    setOriginalInput(newText);\n                }\n                else {\n                    // Not an image, check if it's large text\n                    const { textToInsert } = pasteManager.processPaste(bufferedContent);\n                    // Use functional state update to avoid stale ref values\n                    let newText = '';\n                    setInputAndCursor(prev => {\n                        // Check if cursor is right after another placeholder - add space separator\n                        let finalTextToInsert = textToInsert;\n                        if (textToInsert.startsWith('[Pasted ') && prev.cursor > 0) {\n                            const beforeCursor = prev.text.slice(Math.max(0, prev.cursor - 10), prev.cursor);\n                            if (beforeCursor.endsWith('chars]')) {\n                                finalTextToInsert = ' ' + textToInsert; // Add space between consecutive placeholders\n                            }\n                        }\n                        const result = insertText(prev.text, prev.cursor, finalTextToInsert);\n                        newText = result.text;\n                        return { text: result.text, cursor: result.position };\n                    });\n                    setOriginalInput(newText);\n                }\n            });\n            // If buffering, don't insert yet (wait for flush)\n            if (!shouldBuffer) {\n                // Normal single character typing (not a paste burst)\n                const result = insertText(currentInput, currentCursor, inputChar);\n                setInputAndCursor({ text: result.text, cursor: result.position });\n                setOriginalInput(result.text);\n            }\n        }\n    }, [disabled, onSpecialKey, multiline, handleSubmit, navigateHistory, setOriginalInput]);\n    return {\n        input,\n        cursorPosition,\n        isMultiline: isMultilineRef.current,\n        setInput,\n        setCursorPosition,\n        clearInput,\n        insertAtCursor,\n        resetHistory,\n        handleInput,\n    };\n}\n//# sourceMappingURL=use-enhanced-input.js.map"
  },
  "dist/mcp/transports.js": {
    "path": "dist/mcp/transports.js",
    "hash": "bac1bc766a311b5f05cf28b3cdcaa3a8c4e4bea7591c9a4af822d576b6791134",
    "size": 6887,
    "timestamp": 1764704879301,
    "content": "import { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { EventEmitter } from \"events\";\nimport axios from \"axios\";\nexport class StdioTransport {\n    config;\n    transport;\n    process;\n    constructor(config) {\n        this.config = config;\n        if (!config.command) {\n            throw new Error('Command is required for stdio transport');\n        }\n    }\n    async connect() {\n        // Create transport with environment variables to suppress verbose output\n        const env = {\n            ...process.env,\n            ...this.config.env,\n            // Try to suppress verbose output from mcp-remote\n            MCP_REMOTE_QUIET: '1',\n            MCP_REMOTE_SILENT: '1',\n            DEBUG: '',\n            NODE_ENV: 'production'\n        };\n        this.transport = new StdioClientTransport({\n            command: this.config.command,\n            args: this.config.args || [],\n            env\n        });\n        return this.transport;\n    }\n    async disconnect() {\n        if (this.transport) {\n            await this.transport.close();\n            this.transport = undefined;\n        }\n        if (this.process) {\n            this.process.kill();\n            this.process = undefined;\n        }\n    }\n    getType() {\n        return 'stdio';\n    }\n}\nexport class HttpTransport extends EventEmitter {\n    config;\n    client;\n    connected = false;\n    constructor(config) {\n        super();\n        this.config = config;\n        if (!config.url) {\n            throw new Error('URL is required for HTTP transport');\n        }\n    }\n    async connect() {\n        this.client = axios.create({\n            baseURL: this.config.url,\n            headers: {\n                'Content-Type': 'application/json',\n                ...this.config.headers\n            }\n        });\n        // Test connection\n        try {\n            await this.client.get('/health');\n            this.connected = true;\n        }\n        catch (error) {\n            // If health endpoint doesn't exist, try a basic request\n            this.connected = true;\n        }\n        return new HttpClientTransport(this.client);\n    }\n    async disconnect() {\n        this.connected = false;\n        this.client = undefined;\n    }\n    getType() {\n        return 'http';\n    }\n}\nexport class SSETransport extends EventEmitter {\n    config;\n    connected = false;\n    constructor(config) {\n        super();\n        this.config = config;\n        if (!config.url) {\n            throw new Error('URL is required for SSE transport');\n        }\n    }\n    async connect() {\n        return new Promise((resolve, reject) => {\n            try {\n                // For Node.js environment, we'll use a simple HTTP-based approach\n                // In a real implementation, you'd use a proper SSE library like 'eventsource'\n                this.connected = true;\n                resolve(new SSEClientTransport(this.config.url));\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async disconnect() {\n        this.connected = false;\n    }\n    getType() {\n        return 'sse';\n    }\n}\n// Custom HTTP Transport implementation\nclass HttpClientTransport extends EventEmitter {\n    client;\n    constructor(client) {\n        super();\n        this.client = client;\n    }\n    async start() {\n        // HTTP transport is connection-less, so we're always \"started\"\n    }\n    async close() {\n        // Nothing to close for HTTP transport\n    }\n    async send(message) {\n        try {\n            const response = await this.client.post('/rpc', message);\n            return response.data;\n        }\n        catch (error) {\n            throw new Error(`HTTP transport error: ${error}`);\n        }\n    }\n}\n// Custom SSE Transport implementation\nclass SSEClientTransport extends EventEmitter {\n    url;\n    constructor(url) {\n        super();\n        this.url = url;\n    }\n    async start() {\n        // SSE transport is event-driven, so we're always \"started\"\n    }\n    async close() {\n        // Nothing to close for basic SSE transport\n    }\n    async send(message) {\n        // For bidirectional communication over SSE, we typically use HTTP POST\n        // for sending messages and SSE for receiving\n        try {\n            const response = await axios.post(this.url.replace('/sse', '/rpc'), message, {\n                headers: { 'Content-Type': 'application/json' }\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw new Error(`SSE transport error: ${error}`);\n        }\n    }\n}\nexport class StreamableHttpTransport extends EventEmitter {\n    config;\n    connected = false;\n    constructor(config) {\n        super();\n        this.config = config;\n        if (!config.url) {\n            throw new Error('URL is required for streamable_http transport');\n        }\n    }\n    async connect() {\n        return new Promise((resolve, reject) => {\n            try {\n                this.connected = true;\n                resolve(new StreamableHttpClientTransport(this.config.url, this.config.headers));\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async disconnect() {\n        this.connected = false;\n    }\n    getType() {\n        return 'streamable_http';\n    }\n}\n// Custom Streamable HTTP Transport implementation for GitHub Copilot MCP\nclass StreamableHttpClientTransport extends EventEmitter {\n    url;\n    headers;\n    constructor(url, headers) {\n        super();\n        this.url = url;\n        this.headers = headers;\n    }\n    async start() {\n        // Streamable HTTP transport is connection-less, so we're always \"started\"\n    }\n    async close() {\n        // Nothing to close for streamable HTTP transport\n    }\n    async send(message) {\n        console.log('StreamableHttpTransport: SSE endpoints require persistent connections, not suitable for MCP request-response pattern');\n        console.log('StreamableHttpTransport: Message that would be sent:', JSON.stringify(message));\n        // For now, return a mock response to indicate the transport type is not compatible\n        // with the MCP protocol's request-response pattern\n        throw new Error('StreamableHttpTransport: SSE endpoints are not compatible with MCP request-response pattern. GitHub Copilot MCP may require a different integration approach.');\n    }\n}\nexport function createTransport(config) {\n    switch (config.type) {\n        case 'stdio':\n            return new StdioTransport(config);\n        case 'http':\n            return new HttpTransport(config);\n        case 'sse':\n            return new SSETransport(config);\n        case 'streamable_http':\n            return new StreamableHttpTransport(config);\n        default:\n            throw new Error(`Unsupported transport type: ${config.type}`);\n    }\n}\n//# sourceMappingURL=transports.js.map"
  },
  "dist/mcp/client.js": {
    "path": "dist/mcp/client.js",
    "hash": "a14f9182c413a5d8b2ca5319a2e14177b3422e5be744d6ab21f68fbf7942fdbf",
    "size": 4631,
    "timestamp": 1764704879301,
    "content": "import { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { EventEmitter } from \"events\";\nimport { createTransport } from \"./transports.js\";\nexport class MCPManager extends EventEmitter {\n    clients = new Map();\n    transports = new Map();\n    tools = new Map();\n    async addServer(config) {\n        try {\n            // Handle legacy stdio-only configuration\n            let transportConfig = config.transport;\n            if (!transportConfig && config.command) {\n                transportConfig = {\n                    type: 'stdio',\n                    command: config.command,\n                    args: config.args,\n                    env: config.env\n                };\n            }\n            if (!transportConfig) {\n                throw new Error('Transport configuration is required');\n            }\n            // Create transport\n            const transport = createTransport(transportConfig);\n            this.transports.set(config.name, transport);\n            // Create client\n            const client = new Client({\n                name: \"grok-cli\",\n                version: \"1.0.0\"\n            }, {\n                capabilities: {\n                    tools: {}\n                }\n            });\n            this.clients.set(config.name, client);\n            // Connect\n            const sdkTransport = await transport.connect();\n            await client.connect(sdkTransport);\n            // List available tools\n            const toolsResult = await client.listTools();\n            // Register tools\n            for (const tool of toolsResult.tools) {\n                const mcpTool = {\n                    name: `mcp__${config.name}__${tool.name}`,\n                    description: tool.description || `Tool from ${config.name} server`,\n                    inputSchema: tool.inputSchema,\n                    serverName: config.name\n                };\n                this.tools.set(mcpTool.name, mcpTool);\n            }\n            this.emit('serverAdded', config.name, toolsResult.tools.length);\n        }\n        catch (error) {\n            this.emit('serverError', config.name, error);\n            throw error;\n        }\n    }\n    async removeServer(serverName) {\n        // Remove tools\n        for (const [toolName, tool] of this.tools.entries()) {\n            if (tool.serverName === serverName) {\n                this.tools.delete(toolName);\n            }\n        }\n        // Disconnect client\n        const client = this.clients.get(serverName);\n        if (client) {\n            await client.close();\n            this.clients.delete(serverName);\n        }\n        // Close transport\n        const transport = this.transports.get(serverName);\n        if (transport) {\n            await transport.disconnect();\n            this.transports.delete(serverName);\n        }\n        this.emit('serverRemoved', serverName);\n    }\n    async callTool(toolName, arguments_) {\n        const tool = this.tools.get(toolName);\n        if (!tool) {\n            throw new Error(`Tool ${toolName} not found`);\n        }\n        const client = this.clients.get(tool.serverName);\n        if (!client) {\n            throw new Error(`Server ${tool.serverName} not connected`);\n        }\n        // Extract the original tool name (remove mcp__servername__ prefix)\n        const originalToolName = toolName.replace(`mcp__${tool.serverName}__`, '');\n        return await client.callTool({\n            name: originalToolName,\n            arguments: arguments_\n        });\n    }\n    getTools() {\n        return Array.from(this.tools.values());\n    }\n    getServers() {\n        return Array.from(this.clients.keys());\n    }\n    async shutdown() {\n        const serverNames = Array.from(this.clients.keys());\n        await Promise.all(serverNames.map(name => this.removeServer(name)));\n    }\n    getTransportType(serverName) {\n        const transport = this.transports.get(serverName);\n        return transport?.getType();\n    }\n    async ensureServersInitialized() {\n        if (this.clients.size > 0) {\n            return; // Already initialized\n        }\n        const { loadMCPConfig } = await import('../mcp/config');\n        const config = loadMCPConfig();\n        // Initialize servers in parallel to avoid blocking\n        const initPromises = config.servers.map(async (serverConfig) => {\n            try {\n                await this.addServer(serverConfig);\n            }\n            catch (error) {\n                console.warn(`Failed to initialize MCP server ${serverConfig.name}:`, error);\n            }\n        });\n        await Promise.all(initPromises);\n    }\n}\n//# sourceMappingURL=client.js.map"
  },
  "dist/mcp/config.js": {
    "path": "dist/mcp/config.js",
    "hash": "d0c8b9420fd5ce0fa2b0ddecd0068c75d4bcb3ac2eb34144b277ed35293d1648",
    "size": 1631,
    "timestamp": 1764704879301,
    "content": "import { getSettingsManager } from \"../utils/settings-manager.js\";\n/**\n * Load MCP configuration from project settings\n */\nexport function loadMCPConfig() {\n    const manager = getSettingsManager();\n    const projectSettings = manager.loadProjectSettings();\n    const servers = projectSettings.mcpServers ? Object.values(projectSettings.mcpServers) : [];\n    return { servers };\n}\nexport function saveMCPConfig(config) {\n    const manager = getSettingsManager();\n    const mcpServers = {};\n    // Convert servers array to object keyed by name\n    for (const server of config.servers) {\n        mcpServers[server.name] = server;\n    }\n    manager.updateProjectSetting('mcpServers', mcpServers);\n}\nexport function addMCPServer(config) {\n    const manager = getSettingsManager();\n    const projectSettings = manager.loadProjectSettings();\n    const mcpServers = projectSettings.mcpServers || {};\n    mcpServers[config.name] = config;\n    manager.updateProjectSetting('mcpServers', mcpServers);\n}\nexport function removeMCPServer(serverName) {\n    const manager = getSettingsManager();\n    const projectSettings = manager.loadProjectSettings();\n    const mcpServers = projectSettings.mcpServers;\n    if (mcpServers) {\n        delete mcpServers[serverName];\n        manager.updateProjectSetting('mcpServers', mcpServers);\n    }\n}\nexport function getMCPServer(serverName) {\n    const manager = getSettingsManager();\n    const projectSettings = manager.loadProjectSettings();\n    return projectSettings.mcpServers?.[serverName];\n}\n// Predefined server configurations\nexport const PREDEFINED_SERVERS = {};\n//# sourceMappingURL=config.js.map"
  },
  "dist/tools/todo-tool.js": {
    "path": "dist/tools/todo-tool.js",
    "hash": "9e526e6289239f6606a1c2312e2108a72128f0676fa728d66870e074d45e419e",
    "size": 4743,
    "timestamp": 1764704879301,
    "content": "export class TodoTool {\n    todos = [];\n    formatTodoList() {\n        if (this.todos.length === 0) {\n            return 'No todos created yet';\n        }\n        const getCheckbox = (status) => {\n            switch (status) {\n                case 'completed':\n                    return '‚óè';\n                case 'in_progress':\n                    return '‚óê';\n                case 'pending':\n                    return '‚óã';\n                default:\n                    return '‚óã';\n            }\n        };\n        const getStatusColor = (status) => {\n            switch (status) {\n                case 'completed':\n                    return '\\x1b[32m'; // Green\n                case 'in_progress':\n                    return '\\x1b[36m'; // Cyan\n                case 'pending':\n                    return '\\x1b[37m'; // White/default\n                default:\n                    return '\\x1b[0m'; // Reset\n            }\n        };\n        const reset = '\\x1b[0m';\n        let output = '';\n        this.todos.forEach((todo, index) => {\n            const checkbox = getCheckbox(todo.status);\n            const statusColor = getStatusColor(todo.status);\n            const strikethrough = todo.status === 'completed' ? '\\x1b[9m' : '';\n            const indent = index === 0 ? '' : '  ';\n            output += `${indent}${statusColor}${strikethrough}${checkbox} ${todo.content}${reset}\\n`;\n        });\n        return output;\n    }\n    async createTodoList(todos) {\n        try {\n            // Validate todos\n            for (const todo of todos) {\n                if (!todo.id || !todo.content || !todo.status || !todo.priority) {\n                    return {\n                        success: false,\n                        error: 'Each todo must have id, content, status, and priority fields'\n                    };\n                }\n                if (!['pending', 'in_progress', 'completed'].includes(todo.status)) {\n                    return {\n                        success: false,\n                        error: `Invalid status: ${todo.status}. Must be pending, in_progress, or completed`\n                    };\n                }\n                if (!['high', 'medium', 'low'].includes(todo.priority)) {\n                    return {\n                        success: false,\n                        error: `Invalid priority: ${todo.priority}. Must be high, medium, or low`\n                    };\n                }\n            }\n            this.todos = todos;\n            return {\n                success: true,\n                output: this.formatTodoList()\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error creating todo list: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    async updateTodoList(updates) {\n        try {\n            const updatedIds = [];\n            for (const update of updates) {\n                const todoIndex = this.todos.findIndex(t => t.id === update.id);\n                if (todoIndex === -1) {\n                    return {\n                        success: false,\n                        error: `Todo with id ${update.id} not found`\n                    };\n                }\n                const todo = this.todos[todoIndex];\n                if (update.status && !['pending', 'in_progress', 'completed'].includes(update.status)) {\n                    return {\n                        success: false,\n                        error: `Invalid status: ${update.status}. Must be pending, in_progress, or completed`\n                    };\n                }\n                if (update.priority && !['high', 'medium', 'low'].includes(update.priority)) {\n                    return {\n                        success: false,\n                        error: `Invalid priority: ${update.priority}. Must be high, medium, or low`\n                    };\n                }\n                if (update.status)\n                    todo.status = update.status;\n                if (update.content)\n                    todo.content = update.content;\n                if (update.priority)\n                    todo.priority = update.priority;\n                updatedIds.push(update.id);\n            }\n            return {\n                success: true,\n                output: this.formatTodoList()\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error updating todo list: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    async viewTodoList() {\n        return {\n            success: true,\n            output: this.formatTodoList()\n        };\n    }\n}\n//# sourceMappingURL=todo-tool.js.map"
  },
  "dist/tools/session-tools.js": {
    "path": "dist/tools/session-tools.js",
    "hash": "7b1a5c0bbbf5bbd1eb5a3bf35880be4dfac94c3c4c00d9028836a3b0122ba466",
    "size": 28383,
    "timestamp": 1764704879301,
    "content": "/**\n * Session Management Tools\n * Git-like conversation branching and time travel\n */\nimport { sessionManager } from '../utils/session-manager-sqlite.js';\nimport { providerManager } from '../utils/provider-manager.js';\n/**\n * Tool: session_list\n * List all conversation sessions\n *\n * This is a DUPLICATE of /list_sessions user command for intentional evolution.\n * The code starts identical but can diverge based on LLM feedback.\n */\nexport async function executeSessionList() {\n    try {\n        // Pass null to get sessions from ALL directories (not just current)\n        // Same behavior as /list_sessions user command\n        const sessions = sessionManager.listSessions(null, {\n            sortBy: 'last_activity',\n            sortOrder: 'DESC',\n            limit: 50 // Increased limit for multi-directory view\n        });\n        if (sessions.length === 0) {\n            return {\n                success: true,\n                output: `üìÇ No sessions found\\n\\nStart chatting to create your first session!`\n            };\n        }\n        // Group sessions by working directory (same as user command)\n        const sessionsByDir = new Map();\n        sessions.forEach(session => {\n            const dir = session.working_dir;\n            if (!sessionsByDir.has(dir)) {\n                sessionsByDir.set(dir, []);\n            }\n            sessionsByDir.get(dir).push(session);\n        });\n        // Format sessions list grouped by directory\n        const dirCount = sessionsByDir.size;\n        let output = `üìö All Sessions (${dirCount} ${dirCount === 1 ? 'directory' : 'directories'})\\n`;\n        output += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n        // Iterate through directories (sorted by most recent activity)\n        const sortedDirs = Array.from(sessionsByDir.entries()).sort((a, b) => {\n            const latestA = Math.max(...a[1].map(s => new Date(s.last_activity).getTime()));\n            const latestB = Math.max(...b[1].map(s => new Date(s.last_activity).getTime()));\n            return latestB - latestA;\n        });\n        sortedDirs.forEach(([dir, dirSessions], dirIndex) => {\n            // Highlight current directory\n            const isCurrent = dir === process.cwd();\n            const dirMarker = isCurrent ? 'üìç' : 'üìÅ';\n            const dirLabel = isCurrent ? ` (current)` : '';\n            output += `${dirMarker} **${dir}**${dirLabel}\\n`;\n            output += `   ${dirSessions.length} ${dirSessions.length === 1 ? 'session' : 'sessions'}\\n\\n`;\n            dirSessions.forEach((session) => {\n                const status = session.status === 'active' ? 'üü¢' :\n                    session.status === 'completed' ? '‚ö™' : 'üì¶';\n                const favorite = session.is_favorite ? '‚≠ê' : '';\n                output += `   ${status} #${session.id}${favorite}`;\n                if (session.session_name) {\n                    output += ` - ${session.session_name}`;\n                }\n                output += `\\n`;\n                output += `      üì± Model: ${session.default_model} | üí¨ ${session.message_count} msgs`;\n                // Add creation date\n                if (session.created_at) {\n                    const createdDate = new Date(session.created_at);\n                    const createdFormatted = createdDate.toLocaleString('en-US', {\n                        year: 'numeric',\n                        month: '2-digit',\n                        day: '2-digit',\n                        hour: '2-digit',\n                        minute: '2-digit'\n                    });\n                    output += `\\n      üïê Created: ${createdFormatted}`;\n                    // Add age if available\n                    if (session.age_days !== undefined) {\n                        const ageStr = session.age_days === 0\n                            ? 'today'\n                            : session.age_days === 1\n                                ? '1 day ago'\n                                : `${session.age_days} days ago`;\n                        output += ` (${ageStr})`;\n                    }\n                }\n                // Add last activity\n                if (session.last_activity_relative) {\n                    output += `\\n      ‚è∞ Last active: ${session.last_activity_relative}`;\n                }\n                output += `\\n`;\n            });\n            // Add spacing between directories\n            if (dirIndex < sortedDirs.length - 1) {\n                output += `\\n`;\n            }\n        });\n        output += `\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n`;\n        output += `\\nüí° Use session_switch tool to switch (changes directory automatically)\\n`;\n        output += `üí° Legend: üü¢ Active  ‚ö™ Completed  üì¶ Archived  ‚≠ê Favorite  üìç Current dir`;\n        return {\n            success: true,\n            output\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            output: `‚ùå Error listing sessions: ${error.message}`\n        };\n    }\n}\n/**\n * Tool: session_switch\n * Switch to a different session\n * REQUIRES USER PERMISSION\n *\n * This is a DUPLICATE of /switch-session user command for intentional evolution.\n * The code starts identical but can diverge based on LLM feedback.\n * Key features tested in user command:\n * - Multi-directory switching\n * - Automatic process.chdir() synchronization\n * - Chat history loading\n * - Model/provider context update\n */\nexport async function executeSessionSwitch(args) {\n    try {\n        const { session_id } = args;\n        // Validate session ID\n        if (isNaN(session_id)) {\n            return {\n                success: false,\n                output: `‚ùå Invalid session ID\\n\\n` +\n                    `Session ID must be a number.\\n\\n` +\n                    `üí° Use session_list to see available session IDs`\n            };\n        }\n        // Switch session (core logic from user command)\n        const { session, history } = await sessionManager.switchSession(session_id);\n        // CRITICAL: Change working directory to match the session's working_dir\n        // This prevents path confusion when the LLM thinks it's in one directory\n        // but the Node process is actually in another\n        const targetWorkdir = session.working_dir;\n        const currentWorkdir = process.cwd();\n        if (targetWorkdir !== currentWorkdir) {\n            // Verify target directory exists\n            const fs = await import('fs');\n            if (!fs.existsSync(targetWorkdir)) {\n                return {\n                    success: false,\n                    output: `‚ùå Session's working directory does not exist: ${targetWorkdir}\\n\\n` +\n                        `The directory may have been moved or deleted.`\n                };\n            }\n            // Change the Node process's current working directory\n            process.chdir(targetWorkdir);\n            // Verify the change was successful\n            const newCwd = process.cwd();\n            if (newCwd !== targetWorkdir) {\n                return {\n                    success: false,\n                    output: `‚ùå Failed to change directory from ${currentWorkdir} to ${targetWorkdir}\\n` +\n                        `Current directory is: ${newCwd}`\n                };\n            }\n        }\n        // Format confirmation message (adapted from user command)\n        const dirChanged = targetWorkdir !== currentWorkdir;\n        let output = `‚úÖ Switched to Session #${session.id}\\n\\n`;\n        output += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n        output += `üìù Name: ${session.session_name || 'Unnamed'}\\n`;\n        output += `ü§ñ Provider: ${session.default_provider}\\n`;\n        output += `üì± Model: ${session.default_model}\\n`;\n        output += `üí¨ Messages: ${history.length}\\n`;\n        output += `üìÅ Working Directory: ${session.working_dir}\\n`;\n        output += `üïê Last Activity: ${new Date(session.last_activity).toLocaleString()}\\n\\n`;\n        if (dirChanged) {\n            output += `üìÇ **Directory Changed:**\\n`;\n            output += `   From: ${currentWorkdir}\\n`;\n            output += `   To:   ${targetWorkdir}\\n\\n`;\n            output += `‚ö†Ô∏è  All relative paths now resolve to the new directory.\\n\\n`;\n        }\n        else {\n            output += `üìÇ **Directory:** Already in ${targetWorkdir}\\n\\n`;\n        }\n        output += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n        output += `Conversation history loaded! Continue chatting...`;\n        return {\n            success: true,\n            output\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            output: `‚ùå Failed to switch session: ${error.message}\\n\\n` +\n                `üí° Use session_list to see available sessions`\n        };\n    }\n}\n/**\n * Tool: session_new\n * Create a new conversation session\n *\n * This is a DUPLICATE of /new-session user command for intentional evolution.\n * The code starts identical but can diverge based on LLM feedback.\n * Key features tested in user command:\n * - Directory creation and validation\n * - History import with date filtering\n * - Model/provider resolution\n * - API key handling\n *\n * NOTE: The agent must provide API key via context\n */\nexport async function executeSessionNew(args) {\n    try {\n        const { directory, init_mode = 'empty', rewind_timestamp, rewind_git_mode = 'full', import_history = false, from_session_id, date_range_start, date_range_end, model, provider } = args;\n        // Parse date range if provided (same as user command)\n        let fromDate;\n        let toDate;\n        if (date_range_start) {\n            fromDate = parseDate(date_range_start);\n        }\n        if (date_range_end) {\n            toDate = parseDate(date_range_end);\n        }\n        // Validate date range\n        if (fromDate && toDate && fromDate > toDate) {\n            return {\n                success: false,\n                output: `‚ùå Invalid date range: start date must be before end date\\n\\n` +\n                    `Start: ${fromDate.toLocaleDateString()}\\n` +\n                    `End: ${toDate.toLocaleDateString()}`\n            };\n        }\n        // Build date range for filtering\n        const dateRange = (fromDate || toDate) ? {\n            start: fromDate || new Date(0), // Beginning of time if not specified\n            end: toDate || new Date() // Now if not specified\n        } : undefined;\n        // Determine target directory (default: current directory)\n        // Same resolution logic as user command\n        const targetWorkdir = directory.startsWith('/')\n            ? directory\n            : `${process.cwd()}/${directory}`;\n        // Verify/create target directory (same as user command)\n        const fs = await import('fs');\n        if (!fs.existsSync(targetWorkdir)) {\n            // Create directory recursively\n            fs.mkdirSync(targetWorkdir, { recursive: true });\n        }\n        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n        // DIRECTORY INITIALIZATION (init_mode)\n        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n        let initModeDescription = 'Empty directory';\n        switch (init_mode) {\n            case 'clone-git': {\n                // Validate we're in a Git repository\n                const { execAsync } = await import('../utils/exec-async.js');\n                try {\n                    await execAsync('git rev-parse --is-inside-work-tree', { cwd: process.cwd() });\n                }\n                catch {\n                    return {\n                        success: false,\n                        output: `‚ùå Cannot clone Git repository: Current directory is not a Git repository\\n\\n` +\n                            `To use init_mode='clone-git', you must be inside a Git repository.`\n                    };\n                }\n                // Clone the current Git repository to target directory\n                const currentDir = process.cwd();\n                // Use git clone to copy the repository\n                const { exec } = await import('child_process');\n                const { promisify } = await import('util');\n                const execPromise = promisify(exec);\n                try {\n                    // Clone to temp directory first\n                    const tempDir = `${targetWorkdir}_temp_clone`;\n                    await execPromise(`git clone \"${currentDir}\" \"${tempDir}\"`);\n                    // Move contents from temp to target\n                    await execPromise(`mv \"${tempDir}\"/.git \"${targetWorkdir}/\" && mv \"${tempDir}\"/* \"${targetWorkdir}/\" 2>/dev/null || true && rm -rf \"${tempDir}\"`);\n                    initModeDescription = 'Git repository cloned from current directory';\n                }\n                catch (error) {\n                    return {\n                        success: false,\n                        output: `‚ùå Failed to clone Git repository: ${error.message}\\n\\n` +\n                            `Make sure you have Git installed and the current directory is a valid Git repository.`\n                    };\n                }\n                break;\n            }\n            case 'copy-files': {\n                // Copy files from current directory (excluding .git, node_modules, hidden files)\n                const currentDir = process.cwd();\n                const { exec } = await import('child_process');\n                const { promisify } = await import('util');\n                const execPromise = promisify(exec);\n                try {\n                    // Use rsync if available, otherwise use cp\n                    try {\n                        await execPromise(`rsync -av --exclude='.git' --exclude='node_modules' --exclude='.*' \"${currentDir}/\" \"${targetWorkdir}/\"`);\n                        initModeDescription = 'Files copied from current directory (via rsync)';\n                    }\n                    catch {\n                        // Fallback to cp\n                        await execPromise(`cp -r \"${currentDir}\"/* \"${targetWorkdir}/\" 2>/dev/null || true`);\n                        initModeDescription = 'Files copied from current directory (via cp)';\n                    }\n                }\n                catch (error) {\n                    return {\n                        success: false,\n                        output: `‚ùå Failed to copy files: ${error.message}\\n\\n` +\n                            `Make sure you have the necessary permissions.`\n                    };\n                }\n                break;\n            }\n            case 'from-rewind': {\n                // Validate rewind_timestamp is provided\n                if (!rewind_timestamp) {\n                    return {\n                        success: false,\n                        output: `‚ùå init_mode='from-rewind' requires rewind_timestamp parameter\\n\\n` +\n                            `Please provide a timestamp (ISO 8601: 2025-11-28T15:00:00Z)\\n\\n` +\n                            `üí° Use timeline_query to find available timestamps`\n                    };\n                }\n                // Import rewind tool\n                const { executeRewindTo } = await import('./rewind-to-tool.js');\n                // Perform rewind to reconstruct directory\n                const rewindResult = await executeRewindTo({\n                    targetTimestamp: rewind_timestamp,\n                    outputDir: targetWorkdir,\n                    includeFiles: true,\n                    includeConversations: import_history, // Link to import_history option\n                    gitMode: rewind_git_mode,\n                    createSession: false, // We'll create session ourselves\n                });\n                if (!rewindResult.success) {\n                    return {\n                        success: false,\n                        output: `‚ùå Failed to initialize from rewind: ${rewindResult.error}\\n\\n` +\n                            `Rewind timestamp: ${rewind_timestamp}\\n` +\n                            `Git mode: ${rewind_git_mode}`\n                    };\n                }\n                initModeDescription = `Initialized from rewind at ${rewind_timestamp} (gitMode=${rewind_git_mode})`;\n                break;\n            }\n            case 'empty':\n            default:\n                // Directory already created above, nothing more to do\n                initModeDescription = 'Empty directory';\n                break;\n        }\n        // Determine model and provider (same logic as user command)\n        const currentSession = sessionManager.getCurrentSession();\n        // Note: Agent will need to inject API key via context\n        // This is handled by the agent calling this tool\n        const apiKey = undefined; // Agent provides via context\n        const targetModel = model || currentSession?.default_model || 'grok-beta';\n        const targetProvider = provider ||\n            (model ? providerManager.detectProvider(model) : null) ||\n            currentSession?.default_provider ||\n            (targetModel ? providerManager.detectProvider(targetModel) : null) ||\n            'grok';\n        if (!targetProvider) {\n            return {\n                success: false,\n                output: `‚ùå Cannot determine provider for model: ${targetModel}\\n\\n` +\n                    `Please specify provider explicitly.`\n            };\n        }\n        // Check API key requirement\n        if (!apiKey) {\n            return {\n                success: false,\n                output: `‚ùå No API key found for provider: ${targetProvider}\\n\\n` +\n                    `The agent must provide API key via context.\\n` +\n                    `Please ensure API key is configured for ${targetProvider}.`\n            };\n        }\n        // Create the new session (core logic from user command)\n        const { session, history, importWarning } = await sessionManager.createNewSession(targetWorkdir, targetProvider, targetModel, apiKey, {\n            importHistory: import_history,\n            fromSessionId: from_session_id,\n            dateRange\n        });\n        // CRITICAL: Change working directory if creating session in different directory\n        // Same behavior as user command and /switch-session for consistency\n        const currentWorkdir = process.cwd();\n        const dirChanged = targetWorkdir !== currentWorkdir;\n        if (dirChanged) {\n            // Change the Node process's current working directory\n            process.chdir(targetWorkdir);\n            // Verify the change was successful\n            const newCwd = process.cwd();\n            if (newCwd !== targetWorkdir) {\n                return {\n                    success: false,\n                    output: `‚ùå Failed to change directory from ${currentWorkdir} to ${targetWorkdir}\\n` +\n                        `Current directory is: ${newCwd}`\n                };\n            }\n        }\n        // Format confirmation message (adapted from user command)\n        let output = `‚úÖ **New Session Created** #${session.id}\\n\\n`;\n        output += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n        output += `üìÇ Working Directory: ${session.working_dir}\\n`;\n        output += `üéØ Initialization: ${initModeDescription}\\n`;\n        output += `ü§ñ Provider: ${session.default_provider}\\n`;\n        output += `üì± Model: ${session.default_model}\\n`;\n        output += `üí¨ Messages: ${history.length}${import_history ? ' (imported)' : ''}\\n`;\n        output += `üïê Created: ${new Date(session.created_at).toLocaleString()}\\n\\n`;\n        if (dirChanged) {\n            output += `üìÇ **Directory Changed:**\\n`;\n            output += `   From: ${currentWorkdir}\\n`;\n            output += `   To:   ${targetWorkdir}\\n\\n`;\n            output += `‚ö†Ô∏è  All relative paths now resolve to the new directory.\\n\\n`;\n        }\n        else {\n            output += `üìÇ **Directory:** Already in ${targetWorkdir}\\n\\n`;\n        }\n        if (import_history) {\n            output += `üìã **History Imported**\\n`;\n            output += from_session_id ? `   Source: Session #${from_session_id}\\n` : `   Source: Current session\\n`;\n            if (dateRange) {\n                output += `   Date Range: ${dateRange.start.toLocaleDateString()} ‚Üí ${dateRange.end.toLocaleDateString()}\\n`;\n            }\n            output += `   Messages: ${history.length} imported\\n\\n`;\n            // Add warning if date range excluded all messages\n            if (importWarning) {\n                output += `${importWarning}\\n\\n`;\n            }\n        }\n        else {\n            output += `üìÑ **Fresh Start**\\n`;\n            output += `   This is a brand new conversation.\\n\\n`;\n        }\n        output += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n`;\n        output += `You can now start a new conversation!\\n\\n`;\n        output += `üí° Use session_list to see all sessions\\n`;\n        output += `üí° Use session_switch to go back to previous session`;\n        return {\n            success: true,\n            output\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            output: `‚ùå Failed to create new session: ${error.message}\\n\\n` +\n                `Usage: session_new tool with required arguments`\n        };\n    }\n}\n/**\n * Tool: session_rewind\n * Perform Git rewind - synchronize conversation + code to specific date\n * REQUIRES USER PERMISSION (most critical operation)\n */\nexport async function executeSessionRewind(args) {\n    try {\n        const { target_directory, date_range_start, date_range_end, from_session_id, preserve_git_history = false } = args;\n        // Parse dates\n        const startDate = parseDate(date_range_start);\n        const endDate = parseDate(date_range_end);\n        const dateRange = { start: startDate, end: endDate };\n        // Validate date range\n        if (startDate > endDate) {\n            return {\n                success: false,\n                output: `‚ùå Invalid date range: start date (${startDate.toLocaleDateString()}) is after end date (${endDate.toLocaleDateString()})`\n            };\n        }\n        // Resolve directory path\n        const path = await import('path');\n        const targetWorkdir = target_directory.startsWith('/')\n            ? target_directory\n            : path.resolve(process.cwd(), target_directory);\n        // Check if target directory already exists\n        const fs = await import('fs');\n        if (fs.existsSync(targetWorkdir)) {\n            return {\n                success: false,\n                output: `‚ùå Target directory already exists: ${targetWorkdir}\\n\\n` +\n                    `Please choose a different directory or remove the existing one.`\n            };\n        }\n        // Determine source session\n        const sourceSession = from_session_id\n            ? sessionManager.listSessions().find(s => s.id === from_session_id)\n            : sessionManager.getCurrentSession();\n        if (!sourceSession) {\n            return {\n                success: false,\n                output: `‚ùå Source session not found${from_session_id ? `: #${from_session_id}` : ''}\\n\\n` +\n                    `Use session_list to see available sessions.`\n            };\n        }\n        const sourceWorkdir = sourceSession.working_dir;\n        // Check if source is a Git repo\n        const { execAsync } = await import('../utils/exec-async.js');\n        try {\n            await execAsync('git rev-parse --is-inside-work-tree', { cwd: sourceWorkdir });\n        }\n        catch {\n            return {\n                success: false,\n                output: `‚ùå Source directory is not a Git repository: ${sourceWorkdir}\\n\\n` +\n                    `Git rewind requires the source directory to be a Git repository.\\n` +\n                    `Initialize Git first: cd ${sourceWorkdir} && git init`\n            };\n        }\n        // Import GitRewindManager\n        const { GitRewindManager } = await import('../utils/git-rewind.js');\n        const gitRewindManager = new GitRewindManager();\n        // Perform Git rewind\n        const rewindInfo = await gitRewindManager.performRewind(sourceWorkdir, targetWorkdir, dateRange, sourceSession.id, { preserveGitHistory: preserve_git_history });\n        // Create new session with rewound state\n        const currentSession = sessionManager.getCurrentSession();\n        const targetModel = currentSession?.default_model || 'grok-beta';\n        const targetProvider = currentSession?.default_provider || 'grok';\n        const { session, history } = await sessionManager.createNewSession(targetWorkdir, targetProvider, targetModel, undefined, // apiKey will be provided by agent\n        {\n            importHistory: true,\n            fromSessionId: sourceSession.id,\n            dateRange\n        });\n        // Update rewind info with conversation count\n        rewindInfo.conversation_messages = history.length;\n        await gitRewindManager.updateRewindInfo(targetWorkdir, rewindInfo);\n        return {\n            success: true,\n            output: `‚úÖ **Git Rewind Complete** #${session.id}\\n\\n` +\n                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                `üìÇ **Working Directory:** ${session.working_dir}\\n` +\n                `   (Created in new directory)\\n\\n` +\n                `üîÑ **Git Rewind Applied**\\n` +\n                `   üéØ Target Commit: ${rewindInfo.target_commit.substring(0, 7)}\\n` +\n                `   üìÖ Commit Date: ${rewindInfo.git_commits[rewindInfo.git_commits.length - 1].date.toLocaleString()}\\n` +\n                `   üìä Commits in Range: ${rewindInfo.git_commits.length}\\n` +\n                `   üìÅ Files Extracted: ${rewindInfo.files_copied}\\n` +\n                `   üå≥ Extraction Method: ${rewindInfo.extraction_method}\\n` +\n                `   ${preserve_git_history ? '‚úÖ Full Git history preserved\\n' : 'üíæ Lightweight (git archive)\\n'}` +\n                `\\n` +\n                `üìã **Conversation Synchronized**\\n` +\n                `   üì• Source: Session #${sourceSession.id}\\n` +\n                `   üìÖ Date Range: ${dateRange.start.toLocaleDateString()} ‚Üí ${dateRange.end.toLocaleDateString()}\\n` +\n                `   üí¨ Messages: ${history.length} imported\\n\\n` +\n                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                `üéØ **Perfect Checkpoint Established**\\n\\n` +\n                `‚úÖ Code state: ${dateRange.end.toLocaleDateString()}\\n` +\n                `‚úÖ Conversation state: ${dateRange.end.toLocaleDateString()}\\n` +\n                `‚úÖ Ready for iteration from this exact point\\n\\n` +\n                `üìã **Next Steps:**\\n\\n` +\n                `1. **Continue Development:**\\n` +\n                `   - Make changes as usual\\n` +\n                `   - Use bash tool for git commits: git commit -m \"message\"\\n` +\n                `   - Push regularly: git push origin <branch>\\n\\n` +\n                `2. **Create GitHub Branch (Recommended):**\\n` +\n                `   \\`\\`\\`bash\\n` +\n                `   git checkout -b rewind-${dateRange.end.toISOString().split('T')[0]}\\n` +\n                `   git push -u origin rewind-${dateRange.end.toISOString().split('T')[0]}\\n` +\n                `   \\`\\`\\`\\n\\n` +\n                `3. **View Rewind Details:**\\n` +\n                `   cat .git-rewind-info.json\\n\\n` +\n                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n` +\n                `üí° Source session (#${sourceSession.id}) remains intact in ${sourceWorkdir}`\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            output: `‚ùå Git rewind failed: ${error.message}\\n\\n` +\n                `üí° Common issues:\\n` +\n                `- Source directory not a Git repository\\n` +\n                `- No commits in specified date range\\n` +\n                `- Target directory already exists\\n` +\n                `- Insufficient permissions`\n        };\n    }\n}\n/**\n * Parse date from various formats\n */\nfunction parseDate(dateStr) {\n    // Relative dates\n    if (dateStr === 'today') {\n        return new Date();\n    }\n    if (dateStr === 'yesterday') {\n        const d = new Date();\n        d.setDate(d.getDate() - 1);\n        return d;\n    }\n    // DD/MM/YYYY format\n    if (/^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/.test(dateStr)) {\n        const [day, month, year] = dateStr.split('/').map(Number);\n        return new Date(year, month - 1, day);\n    }\n    // YYYY-MM-DD format or ISO 8601\n    const parsed = new Date(dateStr);\n    if (!isNaN(parsed.getTime())) {\n        return parsed;\n    }\n    throw new Error(`Invalid date format: ${dateStr}. Use DD/MM/YYYY, YYYY-MM-DD, or ISO 8601`);\n}\n//# sourceMappingURL=session-tools.js.map"
  },
  "dist/tools/timeline-query-tool.js": {
    "path": "dist/tools/timeline-query-tool.js",
    "hash": "3f882383fd01de165eb8acdb3c2d0315064e04c4f628999faec5ee4994f874d6",
    "size": 7769,
    "timestamp": 1764704879302,
    "content": "/**\n * Timeline Query Tool - LLM Tool for querying timeline events\n *\n * Allows the LLM to query the timeline database to understand:\n * - What happened in a session\n * - What files were modified\n * - What git operations occurred\n * - Conversation history\n * - Tool executions\n *\n * @module tools/timeline-query-tool\n * @version 1.0.0\n */\nimport { getQueryEngine, EventType, EventCategory, getEventDescription, } from '../timeline/index.js';\n/**\n * Parse timestamp from string or number\n */\nfunction parseTimestamp(input) {\n    if (input === undefined)\n        return undefined;\n    if (typeof input === 'number') {\n        return input;\n    }\n    // Try to parse ISO string\n    const date = new Date(input);\n    if (isNaN(date.getTime())) {\n        throw new Error(`Invalid timestamp: ${input}`);\n    }\n    return date.getTime();\n}\n/**\n * Parse event categories\n */\nfunction parseCategories(categories) {\n    if (!categories || categories.length === 0)\n        return undefined;\n    const validCategories = [];\n    for (const cat of categories) {\n        const upper = cat.toUpperCase();\n        if (upper in EventCategory) {\n            validCategories.push(EventCategory[upper]);\n        }\n    }\n    return validCategories.length > 0 ? validCategories : undefined;\n}\n/**\n * Parse event types\n */\nfunction parseEventTypes(types) {\n    if (!types || types.length === 0)\n        return undefined;\n    const validTypes = [];\n    for (const type of types) {\n        const upper = type.toUpperCase();\n        if (upper in EventType) {\n            validTypes.push(EventType[upper]);\n        }\n    }\n    return validTypes.length > 0 ? validTypes : undefined;\n}\n/**\n * Execute timeline query\n */\nexport async function executeTimelineQuery(params) {\n    try {\n        const queryEngine = getQueryEngine();\n        // Parse timestamps\n        const startTime = parseTimestamp(params.startTime);\n        const endTime = parseTimestamp(params.endTime);\n        // Parse categories and event types\n        const categories = parseCategories(params.categories);\n        const eventTypes = parseEventTypes(params.eventTypes);\n        // Build filter\n        const filter = {\n            startTime,\n            endTime,\n            categories,\n            eventTypes,\n            actor: params.actor,\n            sessionId: params.sessionId,\n            aggregateId: params.aggregateId,\n            limit: Math.min(params.limit || 100, 1000), // Cap at 1000\n            order: params.order || 'desc',\n        };\n        // Get statistics only\n        if (params.statsOnly) {\n            const stats = queryEngine.getStats(filter);\n            return {\n                success: true,\n                query: params,\n                stats: {\n                    totalEvents: stats.totalEvents,\n                    eventsByType: stats.eventsByType,\n                    eventsByCategory: stats.eventsByCategory,\n                    eventsByActor: stats.eventsByActor,\n                    timeRange: {\n                        earliest: new Date(stats.timeRange.earliest).toISOString(),\n                        earliestMs: stats.timeRange.earliest,\n                        latest: new Date(stats.timeRange.latest).toISOString(),\n                        latestMs: stats.timeRange.latest,\n                    },\n                },\n            };\n        }\n        // Search by text\n        if (params.searchText) {\n            const result = queryEngine.searchPayload(params.searchText, filter);\n            return {\n                success: true,\n                query: params,\n                events: result.events.map(event => ({\n                    id: event.id,\n                    timestamp: new Date(event.timestamp).toISOString(),\n                    timestampMs: event.timestamp,\n                    eventType: event.event_type,\n                    description: getEventDescription(event.event_type),\n                    actor: event.actor,\n                    aggregate: `${event.aggregate_type}:${event.aggregate_id}`,\n                    payload: event.payload,\n                })),\n                total: result.total,\n                hasMore: result.hasMore,\n            };\n        }\n        // Regular query\n        const result = queryEngine.query(filter);\n        return {\n            success: true,\n            query: params,\n            events: result.events.map(event => ({\n                id: event.id,\n                timestamp: new Date(event.timestamp).toISOString(),\n                timestampMs: event.timestamp,\n                eventType: event.event_type,\n                description: getEventDescription(event.event_type),\n                actor: event.actor,\n                aggregate: `${event.aggregate_type}:${event.aggregate_id}`,\n                payload: event.payload,\n            })),\n            total: result.total,\n            hasMore: result.hasMore,\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            query: params,\n            error: error instanceof Error ? error.message : String(error),\n        };\n    }\n}\n/**\n * Timeline query tool definition for LLM\n */\nexport const timelineQueryTool = {\n    name: 'timeline_query',\n    description: `Query the timeline event log to understand what happened in the system.\n  \nUse this tool to:\n- See what happened in a session\n- Find file modifications\n- Track git operations\n- Review conversation history\n- Analyze tool executions\n- Get statistics about events\n\nExamples:\n- \"What files were modified in the last hour?\"\n- \"Show me all git commits in session 5\"\n- \"What tools were executed today?\"\n- \"Get statistics about all events\"`,\n    inputSchema: {\n        type: 'object',\n        properties: {\n            startTime: {\n                type: 'string',\n                description: 'Start timestamp (ISO string like \"2025-11-28T00:00:00Z\" or relative like \"1 hour ago\")',\n            },\n            endTime: {\n                type: 'string',\n                description: 'End timestamp (ISO string)',\n            },\n            categories: {\n                type: 'array',\n                items: {\n                    type: 'string',\n                    enum: ['SESSION', 'LLM', 'TOOL', 'FILE', 'GIT', 'REWIND'],\n                },\n                description: 'Filter by event categories',\n            },\n            eventTypes: {\n                type: 'array',\n                items: { type: 'string' },\n                description: 'Specific event types (e.g., FILE_MODIFIED, GIT_COMMIT)',\n            },\n            actor: {\n                type: 'string',\n                description: 'Filter by actor (e.g., \"user\", \"system\", \"git:username\")',\n            },\n            sessionId: {\n                type: 'number',\n                description: 'Filter by session ID',\n            },\n            aggregateId: {\n                type: 'string',\n                description: 'Filter by aggregate ID (e.g., file path)',\n            },\n            limit: {\n                type: 'number',\n                description: 'Maximum number of results (default: 100, max: 1000)',\n                default: 100,\n            },\n            searchText: {\n                type: 'string',\n                description: 'Search for text in event payloads',\n            },\n            order: {\n                type: 'string',\n                enum: ['asc', 'desc'],\n                description: 'Sort order: asc (oldest first) or desc (newest first)',\n                default: 'desc',\n            },\n            statsOnly: {\n                type: 'boolean',\n                description: 'Return only statistics instead of events',\n                default: false,\n            },\n        },\n    },\n    execute: executeTimelineQuery,\n};\n//# sourceMappingURL=timeline-query-tool.js.map"
  },
  "dist/tools/rewind-to-tool.js": {
    "path": "dist/tools/rewind-to-tool.js",
    "hash": "1a68d5368896cb3ed5465ee93a0a366e820968e8432b1ef5bc2c4558745516e7",
    "size": 9301,
    "timestamp": 1764704879302,
    "content": "/**\n * Rewind To Tool - LLM Tool for time-travel reconstruction\n *\n * Allows the LLM to rewind the system to any point in time,\n * creating a complete reconstruction in a new directory.\n *\n * This is the core \"Time Machine\" feature exposed to the LLM.\n *\n * @module tools/rewind-to-tool\n * @version 1.0.0\n */\nimport { getRewindEngine } from '../timeline/index.js';\n/**\n * Parse timestamp from string or number\n */\nfunction parseTimestamp(input) {\n    if (typeof input === 'number') {\n        return input;\n    }\n    // Try to parse ISO string\n    const date = new Date(input);\n    if (isNaN(date.getTime())) {\n        throw new Error(`Invalid timestamp: ${input}. Use ISO format (e.g., \"2025-11-28T12:00:00Z\") or milliseconds.`);\n    }\n    return date.getTime();\n}\n/**\n * Execute rewind operation\n */\nexport async function executeRewindTo(params) {\n    try {\n        const rewindEngine = getRewindEngine();\n        // Parse target timestamp\n        const targetTimestampMs = parseTimestamp(params.targetTimestamp);\n        const targetTimestamp = new Date(targetTimestampMs).toISOString();\n        // Validate timestamp is in the past\n        if (targetTimestampMs > Date.now()) {\n            throw new Error('Cannot rewind to a future timestamp');\n        }\n        // Build options\n        const options = {\n            targetTimestamp: targetTimestampMs,\n            outputDir: params.outputDir,\n            includeFiles: params.includeFiles ?? true,\n            includeConversations: params.includeConversations ?? true,\n            gitMode: params.gitMode ?? (params.includeGit === false ? 'none' : 'metadata'),\n            createSession: params.createSession ?? false,\n            autoCheckout: params.autoCheckout ?? false,\n            compareWith: params.compareWith,\n            onProgress: (message, progress) => {\n                // Could emit progress events here\n                console.log(`[Rewind ${progress}%] ${message}`);\n            },\n        };\n        // Execute rewind\n        const result = await rewindEngine.rewindTo(options);\n        if (!result.success) {\n            return {\n                success: false,\n                targetTimestamp,\n                targetTimestampMs,\n                outputDirectory: result.outputDirectory,\n                snapshotUsed: result.snapshotUsed,\n                eventsReplayed: result.eventsReplayed,\n                filesRestored: result.filesRestored,\n                durationMs: result.duration,\n                error: result.error || 'Unknown error during rewind',\n            };\n        }\n        // Build success summary\n        const summaryLines = [\n            `Successfully rewound system to ${targetTimestamp}`,\n            `Restored ${result.filesRestored} files`,\n            `Replayed ${result.eventsReplayed} events`,\n            result.snapshotUsed ? `Used snapshot: ${result.snapshotUsed}` : 'No snapshot used (replayed from beginning)',\n            `Output directory: ${result.outputDirectory}`,\n        ];\n        if (result.sessionCreated) {\n            summaryLines.push(`Created session #${result.sessionCreated.sessionId} in rewinded directory`);\n        }\n        const summary = summaryLines.join('\\n');\n        const nextSteps = [\n            `Explore the reconstructed state in: ${result.outputDirectory}`,\n            `Files are in: ${result.outputDirectory}/files/`,\n            `Session state: ${result.outputDirectory}/session_state.json`,\n            `Git state: ${result.outputDirectory}/git_state.json`,\n            `File manifest: ${result.outputDirectory}/file_manifest.json`,\n        ];\n        if (result.sessionCreated) {\n            nextSteps.unshift(`Switch to rewinded session: use session_switch tool with ID ${result.sessionCreated.sessionId}`);\n        }\n        return {\n            success: true,\n            targetTimestamp,\n            targetTimestampMs,\n            outputDirectory: result.outputDirectory,\n            snapshotUsed: result.snapshotUsed,\n            eventsReplayed: result.eventsReplayed,\n            filesRestored: result.filesRestored,\n            durationMs: result.duration,\n            sessionCreated: result.sessionCreated,\n            comparisonReport: result.comparisonReport,\n            autoCheckedOut: result.autoCheckedOut,\n            previousWorkingDir: result.previousWorkingDir,\n            summary,\n            nextSteps,\n        };\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        return {\n            success: false,\n            targetTimestamp: '',\n            targetTimestampMs: 0,\n            outputDirectory: '',\n            snapshotUsed: null,\n            eventsReplayed: 0,\n            filesRestored: 0,\n            durationMs: 0,\n            error: errorMessage,\n        };\n    }\n}\n/**\n * Get available time points (snapshots + recent events)\n */\nexport async function getAvailableTimePoints() {\n    const { getSnapshotManager, getQueryEngine, getEventDescription } = await import('../timeline/index.js');\n    const snapshotManager = getSnapshotManager();\n    const queryEngine = getQueryEngine();\n    // Get snapshots\n    const snapshotMetas = snapshotManager.listSnapshots(10);\n    const snapshots = snapshotMetas.map(meta => ({\n        timestamp: new Date(meta.timestamp).toISOString(),\n        timestampMs: meta.timestamp,\n        eventCount: meta.event_count,\n        sessionName: meta.session_name,\n    }));\n    // Get recent events\n    const recentEvents = queryEngine.getRecentEvents(20).map(event => ({\n        timestamp: new Date(event.timestamp).toISOString(),\n        timestampMs: event.timestamp,\n        description: getEventDescription(event.event_type),\n    }));\n    return { snapshots, recentEvents };\n}\n/**\n * Rewind tool definition for LLM\n */\nexport const rewindToTool = {\n    name: 'rewind_to',\n    description: `Rewind the system to a specific point in time, creating a complete reconstruction.\n  \nThis is a TIME MACHINE that reconstructs:\n- Session state (active session, working directory, model)\n- Conversation history up to that point\n- File contents at that moment (restored from Merkle DAG)\n- Git state (commit hash, branch)\n\nThe reconstruction is created in a NEW directory (non-destructive).\n\nUse this tool to:\n- Recover lost work\n- Investigate what the system looked like at a specific time\n- Debug issues by going back in time\n- Create a new session from a past state\n\n‚ö†Ô∏è WARNING: This can take time for distant timestamps (lots of event replay).\n\nExamples:\n- \"Rewind to 2 hours ago\"\n- \"Show me what files looked like before the last commit\"\n- \"Restore session state from this morning\"`,\n    inputSchema: {\n        type: 'object',\n        properties: {\n            targetTimestamp: {\n                type: 'string',\n                description: 'Target timestamp in ISO format (e.g., \"2025-11-28T12:00:00Z\") or milliseconds.',\n            },\n            outputDir: {\n                type: 'string',\n                description: 'Custom output directory path (optional, auto-generated if not provided).',\n            },\n            includeFiles: {\n                type: 'boolean',\n                description: 'Include file contents in reconstruction (default: true).',\n                default: true,\n            },\n            includeConversations: {\n                type: 'boolean',\n                description: 'Include conversation history (default: true).',\n                default: true,\n            },\n            includeGit: {\n                type: 'boolean',\n                description: 'Include git state (default: true). Deprecated: prefer gitMode instead.',\n                default: true,\n            },\n            gitMode: {\n                type: 'string',\n                enum: ['none', 'metadata', 'full'],\n                description: \"Git materialization mode: 'none'=no git, 'metadata'=git_state.json only, 'full'=complete .git repo (default: metadata).\",\n            },\n            createSession: {\n                type: 'boolean',\n                description: 'Create a new grokinou session in the rewinded directory (default: false).',\n            },\n            autoCheckout: {\n                type: 'boolean',\n                description: 'Automatically change working directory (process.cwd) to the rewinded directory (default: false).',\n            },\n            compareWith: {\n                type: 'string',\n                description: 'Compare rewinded state with another directory - generates a detailed diff report (optional).',\n            },\n            reason: {\n                type: 'string',\n                description: 'Human-readable reason for rewind (for logging).',\n            },\n        },\n        required: ['targetTimestamp'],\n    },\n    execute: executeRewindTo,\n};\n/**\n * List time points tool (helper for rewind)\n */\nexport const listTimePointsTool = {\n    name: 'list_time_points',\n    description: `List available time points (snapshots and recent events) for rewinding.\n  \nUse this before rewind_to to see what timestamps are available.\nShows:\n- Recent snapshots (optimized rewind points)\n- Recent events (for precise rewind)`,\n    inputSchema: {\n        type: 'object',\n        properties: {},\n    },\n    execute: getAvailableTimePoints,\n};\n//# sourceMappingURL=rewind-to-tool.js.map"
  },
  "dist/tools/morph-editor.js": {
    "path": "dist/tools/morph-editor.js",
    "hash": "6c7e12b3fee59afdab032a6dfe80bdd2ce40cbba0a977cef6119feb094df18da",
    "size": 14315,
    "timestamp": 1764704879302,
    "content": "import * as fs from \"fs-extra\";\nimport { stat as fsStat, readdir as fsReaddir, readFile as fsReadFile } from \"node:fs/promises\";\nimport * as path from \"path\";\nimport axios from \"axios\";\nimport { ConfirmationService } from \"../utils/confirmation-service.js\";\nexport class MorphEditorTool {\n    confirmationService = ConfirmationService.getInstance();\n    morphApiKey;\n    morphBaseUrl = \"https://api.morphllm.com/v1\";\n    constructor(apiKey) {\n        this.morphApiKey = apiKey || process.env.MORPH_API_KEY || \"\";\n        if (!this.morphApiKey) {\n            console.warn(\"MORPH_API_KEY not found. Morph editor functionality will be limited.\");\n        }\n    }\n    /**\n     * Use this tool to make an edit to an existing file.\n     *\n     * This will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.\n     * When writing the edit, you should specify each edit in sequence, with the special comment // ... existing code ... to represent unchanged code in between edited lines.\n     *\n     * For example:\n     *\n     * // ... existing code ...\n     * FIRST_EDIT\n     * // ... existing code ...\n     * SECOND_EDIT\n     * // ... existing code ...\n     * THIRD_EDIT\n     * // ... existing code ...\n     *\n     * You should still bias towards repeating as few lines of the original file as possible to convey the change.\n     * But, each edit should contain sufficient context of unchanged lines around the code you're editing to resolve ambiguity.\n     * DO NOT omit spans of pre-existing code (or comments) without using the // ... existing code ... comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.\n     * If you plan on deleting a section, you must provide context before and after to delete it. If the initial code is ```code \\n Block 1 \\n Block 2 \\n Block 3 \\n code```, and you want to remove Block 2, you would output ```// ... existing code ... \\n Block 1 \\n  Block 3 \\n // ... existing code ...```.\n     * Make sure it is clear what the edit should be, and where it should be applied.\n     * Make edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.\n     */\n    async editFile(targetFile, instructions, codeEdit) {\n        try {\n            const resolvedPath = path.resolve(targetFile);\n            if (!(await fs.pathExists(resolvedPath))) {\n                return {\n                    success: false,\n                    error: `File not found: ${targetFile}`,\n                };\n            }\n            if (!this.morphApiKey) {\n                return {\n                    success: false,\n                    error: \"MORPH_API_KEY not configured. Please set your Morph API key.\",\n                };\n            }\n            // Read the initial code\n            const initialCode = await fsReadFile(resolvedPath, \"utf-8\");\n            // Check user confirmation before proceeding\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.fileOperations && !sessionFlags.allOperations) {\n                const confirmationResult = await this.confirmationService.requestConfirmation({\n                    operation: \"Edit file with Morph Fast Apply\",\n                    filename: targetFile,\n                    showVSCodeOpen: false,\n                    content: `Instructions: ${instructions}\\n\\nEdit:\\n${codeEdit}`,\n                }, \"file\");\n                if (!confirmationResult.confirmed) {\n                    return {\n                        success: false,\n                        error: confirmationResult.feedback || \"File edit cancelled by user\",\n                    };\n                }\n            }\n            // Call Morph Fast Apply API\n            const mergedCode = await this.callMorphApply(instructions, initialCode, codeEdit);\n            // Write the merged code back to file\n            await fs.writeFile(resolvedPath, mergedCode, \"utf-8\");\n            // Generate diff for display\n            const oldLines = initialCode.split(\"\\n\");\n            const newLines = mergedCode.split(\"\\n\");\n            const diff = this.generateDiff(oldLines, newLines, targetFile);\n            return {\n                success: true,\n                output: diff,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error editing ${targetFile} with Morph: ${error.message}`,\n            };\n        }\n    }\n    async callMorphApply(instructions, initialCode, editSnippet) {\n        try {\n            const response = await axios.post(`${this.morphBaseUrl}/chat/completions`, {\n                model: \"morph-v3-large\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: `<instruction>${instructions}</instruction>\\n<code>${initialCode}</code>\\n<update>${editSnippet}</update>`,\n                    },\n                ],\n            }, {\n                headers: {\n                    \"Authorization\": `Bearer ${this.morphApiKey}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.data.choices || !response.data.choices[0] || !response.data.choices[0].message) {\n                throw new Error(\"Invalid response format from Morph API\");\n            }\n            return response.data.choices[0].message.content;\n        }\n        catch (error) {\n            if (error.response) {\n                throw new Error(`Morph API error (${error.response.status}): ${error.response.data}`);\n            }\n            throw error;\n        }\n    }\n    generateDiff(oldLines, newLines, filePath) {\n        const CONTEXT_LINES = 3;\n        const changes = [];\n        let i = 0, j = 0;\n        while (i < oldLines.length || j < newLines.length) {\n            while (i < oldLines.length && j < newLines.length && oldLines[i] === newLines[j]) {\n                i++;\n                j++;\n            }\n            if (i < oldLines.length || j < newLines.length) {\n                const changeStart = { old: i, new: j };\n                let oldEnd = i;\n                let newEnd = j;\n                while (oldEnd < oldLines.length || newEnd < newLines.length) {\n                    let matchFound = false;\n                    let matchLength = 0;\n                    for (let k = 0; k < Math.min(2, oldLines.length - oldEnd, newLines.length - newEnd); k++) {\n                        if (oldEnd + k < oldLines.length &&\n                            newEnd + k < newLines.length &&\n                            oldLines[oldEnd + k] === newLines[newEnd + k]) {\n                            matchLength++;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (matchLength >= 2 || (oldEnd >= oldLines.length && newEnd >= newLines.length)) {\n                        matchFound = true;\n                    }\n                    if (matchFound) {\n                        break;\n                    }\n                    if (oldEnd < oldLines.length)\n                        oldEnd++;\n                    if (newEnd < newLines.length)\n                        newEnd++;\n                }\n                changes.push({\n                    oldStart: changeStart.old,\n                    oldEnd: oldEnd,\n                    newStart: changeStart.new,\n                    newEnd: newEnd\n                });\n                i = oldEnd;\n                j = newEnd;\n            }\n        }\n        const hunks = [];\n        let accumulatedOffset = 0;\n        for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {\n            const change = changes[changeIdx];\n            let contextStart = Math.max(0, change.oldStart - CONTEXT_LINES);\n            let contextEnd = Math.min(oldLines.length, change.oldEnd + CONTEXT_LINES);\n            if (hunks.length > 0) {\n                const lastHunk = hunks[hunks.length - 1];\n                const lastHunkEnd = lastHunk.oldStart + lastHunk.oldCount;\n                if (lastHunkEnd >= contextStart) {\n                    const oldHunkEnd = lastHunk.oldStart + lastHunk.oldCount;\n                    const newContextEnd = Math.min(oldLines.length, change.oldEnd + CONTEXT_LINES);\n                    for (let idx = oldHunkEnd; idx < change.oldStart; idx++) {\n                        lastHunk.lines.push({ type: ' ', content: oldLines[idx] });\n                    }\n                    for (let idx = change.oldStart; idx < change.oldEnd; idx++) {\n                        lastHunk.lines.push({ type: '-', content: oldLines[idx] });\n                    }\n                    for (let idx = change.newStart; idx < change.newEnd; idx++) {\n                        lastHunk.lines.push({ type: '+', content: newLines[idx] });\n                    }\n                    for (let idx = change.oldEnd; idx < newContextEnd && idx < oldLines.length; idx++) {\n                        lastHunk.lines.push({ type: ' ', content: oldLines[idx] });\n                    }\n                    lastHunk.oldCount = newContextEnd - lastHunk.oldStart;\n                    lastHunk.newCount = lastHunk.oldCount + (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart);\n                    continue;\n                }\n            }\n            const hunk = {\n                oldStart: contextStart + 1,\n                oldCount: contextEnd - contextStart,\n                newStart: contextStart + 1 + accumulatedOffset,\n                newCount: contextEnd - contextStart + (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart),\n                lines: []\n            };\n            for (let idx = contextStart; idx < change.oldStart; idx++) {\n                hunk.lines.push({ type: ' ', content: oldLines[idx] });\n            }\n            for (let idx = change.oldStart; idx < change.oldEnd; idx++) {\n                hunk.lines.push({ type: '-', content: oldLines[idx] });\n            }\n            for (let idx = change.newStart; idx < change.newEnd; idx++) {\n                hunk.lines.push({ type: '+', content: newLines[idx] });\n            }\n            for (let idx = change.oldEnd; idx < contextEnd && idx < oldLines.length; idx++) {\n                hunk.lines.push({ type: ' ', content: oldLines[idx] });\n            }\n            hunks.push(hunk);\n            accumulatedOffset += (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart);\n        }\n        let addedLines = 0;\n        let removedLines = 0;\n        for (const hunk of hunks) {\n            for (const line of hunk.lines) {\n                if (line.type === '+')\n                    addedLines++;\n                if (line.type === '-')\n                    removedLines++;\n            }\n        }\n        let summary = `Updated ${filePath} with Morph Fast Apply`;\n        if (addedLines > 0 && removedLines > 0) {\n            summary += ` - ${addedLines} addition${addedLines !== 1 ? \"s\" : \"\"} and ${removedLines} removal${removedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (addedLines > 0) {\n            summary += ` - ${addedLines} addition${addedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (removedLines > 0) {\n            summary += ` - ${removedLines} removal${removedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (changes.length === 0) {\n            return `No changes applied to ${filePath}`;\n        }\n        let diff = summary + \"\\n\";\n        diff += `--- a/${filePath}\\n`;\n        diff += `+++ b/${filePath}\\n`;\n        for (const hunk of hunks) {\n            diff += `@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@\\n`;\n            for (const line of hunk.lines) {\n                diff += `${line.type}${line.content}\\n`;\n            }\n        }\n        return diff.trim();\n    }\n    async view(filePath, viewRange) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            if (await fs.pathExists(resolvedPath)) {\n                const stats = await fsStat(resolvedPath);\n                if (stats.isDirectory()) {\n                    const files = await fsReaddir(resolvedPath);\n                    return {\n                        success: true,\n                        output: `Directory contents of ${filePath}:\\n${files.join(\"\\n\")}`,\n                    };\n                }\n                const content = await fsReadFile(resolvedPath, \"utf-8\");\n                const lines = content.split(\"\\n\");\n                if (viewRange) {\n                    const [start, end] = viewRange;\n                    const selectedLines = lines.slice(start - 1, end);\n                    const numberedLines = selectedLines\n                        .map((line, idx) => `${start + idx}: ${line}`)\n                        .join(\"\\n\");\n                    return {\n                        success: true,\n                        output: `Lines ${start}-${end} of ${filePath}:\\n${numberedLines}`,\n                    };\n                }\n                const totalLines = lines.length;\n                const displayLines = totalLines > 10 ? lines.slice(0, 10) : lines;\n                const numberedLines = displayLines\n                    .map((line, idx) => `${idx + 1}: ${line}`)\n                    .join(\"\\n\");\n                const additionalLinesMessage = totalLines > 10 ? `\\n... +${totalLines - 10} lines` : \"\";\n                return {\n                    success: true,\n                    output: `Contents of ${filePath}:\\n${numberedLines}${additionalLinesMessage}`,\n                };\n            }\n            else {\n                return {\n                    success: false,\n                    error: `File or directory not found: ${filePath}`,\n                };\n            }\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error viewing ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    setApiKey(apiKey) {\n        this.morphApiKey = apiKey;\n    }\n    getApiKey() {\n        return this.morphApiKey;\n    }\n}\n//# sourceMappingURL=morph-editor.js.map"
  },
  "dist/tools/search.js": {
    "path": "dist/tools/search.js",
    "hash": "b942e6fa41a7defabf9fecebbfb59f5083c10478828367dedbb401ebf8a0c1d2",
    "size": 11430,
    "timestamp": 1764704879302,
    "content": "import { spawn } from \"child_process\";\nimport { ConfirmationService } from \"../utils/confirmation-service.js\";\nimport * as fs from \"fs-extra\";\nimport * as path from \"path\";\nexport class SearchTool {\n    confirmationService = ConfirmationService.getInstance();\n    currentDirectory = process.cwd();\n    /**\n     * Unified search method that can search for text content or find files\n     */\n    async search(query, options = {}) {\n        try {\n            const searchType = options.searchType || \"both\";\n            const results = [];\n            // Search for text content if requested\n            if (searchType === \"text\" || searchType === \"both\") {\n                const textResults = await this.executeRipgrep(query, options);\n                results.push(...textResults.map((r) => ({\n                    type: \"text\",\n                    file: r.file,\n                    line: r.line,\n                    column: r.column,\n                    text: r.text,\n                    match: r.match,\n                })));\n            }\n            // Search for files if requested\n            if (searchType === \"files\" || searchType === \"both\") {\n                const fileResults = await this.findFilesByPattern(query, options);\n                results.push(...fileResults.map((r) => ({\n                    type: \"file\",\n                    file: r.path,\n                    score: r.score,\n                })));\n            }\n            if (results.length === 0) {\n                return {\n                    success: true,\n                    output: `No results found for \"${query}\"`,\n                };\n            }\n            const formattedOutput = this.formatUnifiedResults(results, query, searchType);\n            return {\n                success: true,\n                output: formattedOutput,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Search error: ${error.message}`,\n            };\n        }\n    }\n    /**\n     * Execute ripgrep command with specified options\n     */\n    async executeRipgrep(query, options) {\n        return new Promise((resolve, reject) => {\n            const args = [\n                \"--json\",\n                \"--with-filename\",\n                \"--line-number\",\n                \"--column\",\n                \"--no-heading\",\n                \"--color=never\",\n            ];\n            // Add case sensitivity\n            if (!options.caseSensitive) {\n                args.push(\"--ignore-case\");\n            }\n            // Add whole word matching\n            if (options.wholeWord) {\n                args.push(\"--word-regexp\");\n            }\n            // Add regex mode\n            if (!options.regex) {\n                args.push(\"--fixed-strings\");\n            }\n            // Add max results limit\n            if (options.maxResults) {\n                args.push(\"--max-count\", options.maxResults.toString());\n            }\n            // Add file type filters\n            if (options.fileTypes) {\n                options.fileTypes.forEach((type) => {\n                    args.push(\"--type\", type);\n                });\n            }\n            // Add include pattern\n            if (options.includePattern) {\n                args.push(\"--glob\", options.includePattern);\n            }\n            // Add exclude pattern\n            if (options.excludePattern) {\n                args.push(\"--glob\", `!${options.excludePattern}`);\n            }\n            // Add exclude files\n            if (options.excludeFiles) {\n                options.excludeFiles.forEach((file) => {\n                    args.push(\"--glob\", `!${file}`);\n                });\n            }\n            // Respect gitignore and common ignore patterns\n            args.push(\"--no-require-git\", \"--follow\", \"--glob\", \"!.git/**\", \"--glob\", \"!node_modules/**\", \"--glob\", \"!.DS_Store\", \"--glob\", \"!*.log\");\n            // Add query and search directory\n            args.push(query, this.currentDirectory);\n            const rg = spawn(\"rg\", args);\n            let output = \"\";\n            let errorOutput = \"\";\n            rg.stdout.on(\"data\", (data) => {\n                output += data.toString();\n            });\n            rg.stderr.on(\"data\", (data) => {\n                errorOutput += data.toString();\n            });\n            rg.on(\"close\", (code) => {\n                if (code === 0 || code === 1) {\n                    // 0 = found, 1 = not found\n                    const results = this.parseRipgrepOutput(output);\n                    resolve(results);\n                }\n                else {\n                    reject(new Error(`Ripgrep failed with code ${code}: ${errorOutput}`));\n                }\n            });\n            rg.on(\"error\", (error) => {\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Parse ripgrep JSON output into SearchResult objects\n     */\n    parseRipgrepOutput(output) {\n        const results = [];\n        const lines = output\n            .trim()\n            .split(\"\\n\")\n            .filter((line) => line.length > 0);\n        for (const line of lines) {\n            try {\n                const parsed = JSON.parse(line);\n                if (parsed.type === \"match\") {\n                    const data = parsed.data;\n                    results.push({\n                        file: data.path.text,\n                        line: data.line_number,\n                        column: data.submatches[0]?.start || 0,\n                        text: data.lines.text.trim(),\n                        match: data.submatches[0]?.match?.text || \"\",\n                    });\n                }\n            }\n            catch (e) {\n                // Skip invalid JSON lines\n                continue;\n            }\n        }\n        return results;\n    }\n    /**\n     * Find files by pattern using a simple file walking approach\n     */\n    async findFilesByPattern(pattern, options) {\n        const files = [];\n        const maxResults = options.maxResults || 50;\n        const searchPattern = pattern.toLowerCase();\n        const walkDir = async (dir, depth = 0) => {\n            if (depth > 10 || files.length >= maxResults)\n                return; // Prevent infinite recursion and limit results\n            try {\n                const entries = await fs.readdir(dir, { withFileTypes: true });\n                for (const entry of entries) {\n                    if (files.length >= maxResults)\n                        break;\n                    const fullPath = path.join(dir, entry.name);\n                    const relativePath = path.relative(this.currentDirectory, fullPath);\n                    // Skip hidden files unless explicitly included\n                    if (!options.includeHidden && entry.name.startsWith(\".\")) {\n                        continue;\n                    }\n                    // Skip common directories\n                    if (entry.isDirectory() &&\n                        [\n                            \"node_modules\",\n                            \".git\",\n                            \".svn\",\n                            \".hg\",\n                            \"dist\",\n                            \"build\",\n                            \".next\",\n                            \".cache\",\n                        ].includes(entry.name)) {\n                        continue;\n                    }\n                    // Apply exclude pattern\n                    if (options.excludePattern &&\n                        relativePath.includes(options.excludePattern)) {\n                        continue;\n                    }\n                    if (entry.isFile()) {\n                        const score = this.calculateFileScore(entry.name, relativePath, searchPattern);\n                        if (score > 0) {\n                            files.push({\n                                path: relativePath,\n                                name: entry.name,\n                                score,\n                            });\n                        }\n                    }\n                    else if (entry.isDirectory()) {\n                        await walkDir(fullPath, depth + 1);\n                    }\n                }\n            }\n            catch (error) {\n                // Skip directories we can't read\n            }\n        };\n        await walkDir(this.currentDirectory);\n        // Sort by score (descending) and return top results\n        return files.sort((a, b) => b.score - a.score).slice(0, maxResults);\n    }\n    /**\n     * Calculate fuzzy match score for file names\n     */\n    calculateFileScore(fileName, filePath, pattern) {\n        const lowerFileName = fileName.toLowerCase();\n        const lowerFilePath = filePath.toLowerCase();\n        // Exact matches get highest score\n        if (lowerFileName === pattern)\n            return 100;\n        if (lowerFileName.includes(pattern))\n            return 80;\n        // Path matches get medium score\n        if (lowerFilePath.includes(pattern))\n            return 60;\n        // Fuzzy matching - check if all characters of pattern exist in order\n        let patternIndex = 0;\n        for (let i = 0; i < lowerFileName.length && patternIndex < pattern.length; i++) {\n            if (lowerFileName[i] === pattern[patternIndex]) {\n                patternIndex++;\n            }\n        }\n        if (patternIndex === pattern.length) {\n            // All characters found in order - score based on how close they are\n            return Math.max(10, 40 - (fileName.length - pattern.length));\n        }\n        return 0;\n    }\n    /**\n     * Format unified search results for display\n     */\n    formatUnifiedResults(results, query, searchType) {\n        if (results.length === 0) {\n            return `No results found for \"${query}\"`;\n        }\n        let output = `Search results for \"${query}\":\\n`;\n        // Separate text and file results\n        const textResults = results.filter((r) => r.type === \"text\");\n        const fileResults = results.filter((r) => r.type === \"file\");\n        // Show all unique files (from both text matches and file matches)\n        const allFiles = new Set();\n        // Add files from text results\n        textResults.forEach((result) => {\n            allFiles.add(result.file);\n        });\n        // Add files from file search results\n        fileResults.forEach((result) => {\n            allFiles.add(result.file);\n        });\n        const fileList = Array.from(allFiles);\n        const displayLimit = 8;\n        // Show files in compact format\n        fileList.slice(0, displayLimit).forEach((file) => {\n            // Count matches in this file for text results\n            const matchCount = textResults.filter((r) => r.file === file).length;\n            const matchIndicator = matchCount > 0 ? ` (${matchCount} matches)` : \"\";\n            output += `  ${file}${matchIndicator}\\n`;\n        });\n        // Show \"+X more\" if there are additional results\n        if (fileList.length > displayLimit) {\n            const remaining = fileList.length - displayLimit;\n            output += `  ... +${remaining} more\\n`;\n        }\n        return output.trim();\n    }\n    /**\n     * Update current working directory\n     */\n    setCurrentDirectory(directory) {\n        this.currentDirectory = directory;\n    }\n    /**\n     * Get current working directory\n     */\n    getCurrentDirectory() {\n        return this.currentDirectory;\n    }\n}\n//# sourceMappingURL=search.js.map"
  },
  "dist/tools/index.js": {
    "path": "dist/tools/index.js",
    "hash": "264a51abda1edbbd70016258f7b3341bcd818b66d48a505cf9edf038018714a8",
    "size": 449,
    "timestamp": 1764704879302,
    "content": "export { BashTool } from \"./bash.js\";\nexport { TextEditorTool } from \"./text-editor.js\";\nexport { MorphEditorTool } from \"./morph-editor.js\";\nexport { TodoTool } from \"./todo-tool.js\";\nexport { ConfirmationTool } from \"./confirmation-tool.js\";\nexport { SearchTool } from \"./search.js\";\nexport { ApplyPatchTool } from \"./apply-patch.js\";\nexport * from './timeline-query-tool.js';\nexport * from './rewind-to-tool.js';\n//# sourceMappingURL=index.js.map"
  },
  "dist/tools/apply-patch.js": {
    "path": "dist/tools/apply-patch.js",
    "hash": "194828f61c46774df32c85537fcc836339e7ab00d87202dfdad3a9f8c0b8b5df",
    "size": 7265,
    "timestamp": 1764704879302,
    "content": "import * as fs from \"fs-extra\";\nimport * as path from \"path\";\nimport { ConfirmationService } from \"../utils/confirmation-service.js\";\nexport class ApplyPatchTool {\n    confirmationService = ConfirmationService.getInstance();\n    async apply(patch, dryRun = false) {\n        try {\n            const files = this.parseUnifiedDiff(patch);\n            if (files.length === 0) {\n                return { success: false, error: \"No valid hunks found in patch\" };\n            }\n            // Ask for confirmation once for the full patch unless session is already approved\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.fileOperations && !sessionFlags.allOperations) {\n                const confirmation = await this.confirmationService.requestConfirmation({\n                    operation: dryRun ? \"Dry-run patch\" : \"Apply patch\",\n                    filename: \"(multiple files)\",\n                    showVSCodeOpen: false,\n                    content: patch,\n                }, \"file\");\n                if (!confirmation.confirmed) {\n                    return { success: false, error: confirmation.feedback || \"Patch cancelled by user\" };\n                }\n            }\n            const summaries = [];\n            for (const fp of files) {\n                const targetPath = this.resolveTargetPath(fp);\n                if (fp.oldPath === \"/dev/null\") {\n                    // Create file\n                    const newContent = this.buildFromHunksCreate(fp);\n                    if (!dryRun) {\n                        await fs.ensureDir(path.dirname(targetPath));\n                        await fs.writeFile(targetPath, newContent, \"utf-8\");\n                    }\n                    summaries.push(`Created ${targetPath}`);\n                }\n                else if (fp.newPath === \"/dev/null\") {\n                    // Delete file\n                    if (!dryRun && await fs.pathExists(targetPath)) {\n                        await fs.remove(targetPath);\n                    }\n                    summaries.push(`Deleted ${targetPath}`);\n                }\n                else {\n                    // Modify file\n                    const exists = await fs.pathExists(targetPath);\n                    if (!exists) {\n                        return { success: false, error: `Target file not found: ${targetPath}` };\n                    }\n                    const oldText = await fs.readFile(targetPath, \"utf-8\");\n                    const newText = this.applyHunksModify(oldText, fp);\n                    if (!dryRun) {\n                        await fs.writeFile(targetPath, newText, \"utf-8\");\n                    }\n                    summaries.push(`Patched ${targetPath}`);\n                }\n            }\n            return { success: true, output: summaries.join(\"\\n\") };\n        }\n        catch (e) {\n            return { success: false, error: `apply_patch error: ${e.message}` };\n        }\n    }\n    resolveTargetPath(fp) {\n        const pick = (p) => p.replace(/^a\\//, \"\").replace(/^b\\//, \"\");\n        if (fp.newPath && fp.newPath !== \"/dev/null\")\n            return path.resolve(pick(fp.newPath));\n        if (fp.oldPath && fp.oldPath !== \"/dev/null\")\n            return path.resolve(pick(fp.oldPath));\n        return path.resolve(\"unknown\");\n    }\n    parseUnifiedDiff(patch) {\n        const lines = patch.replace(/\\r\\n/g, \"\\n\").split(\"\\n\");\n        const files = [];\n        let i = 0;\n        while (i < lines.length) {\n            if (lines[i].startsWith(\"--- \")) {\n                const oldPath = lines[i].slice(4).trim();\n                i++;\n                if (i >= lines.length || !lines[i].startsWith(\"+++ \"))\n                    break;\n                const newPath = lines[i].slice(4).trim();\n                i++;\n                const hunks = [];\n                while (i < lines.length && lines[i].startsWith(\"@@ \")) {\n                    const header = lines[i];\n                    const m = /@@ -([0-9]+)(?:,([0-9]+))? \\+([0-9]+)(?:,([0-9]+))? @@/.exec(header);\n                    if (!m)\n                        throw new Error(`Invalid hunk header: ${header}`);\n                    const oldStart = parseInt(m[1], 10);\n                    const oldCount = m[2] ? parseInt(m[2], 10) : 1;\n                    const newStart = parseInt(m[3], 10);\n                    const newCount = m[4] ? parseInt(m[4], 10) : 1;\n                    i++;\n                    const hunkLines = [];\n                    while (i < lines.length && !lines[i].startsWith(\"@@ \") && !lines[i].startsWith(\"--- \")) {\n                        const line = lines[i];\n                        if (line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) {\n                            hunkLines.push({ type: line[0], content: line.slice(1) });\n                        }\n                        i++;\n                    }\n                    hunks.push({ oldStart, oldCount, newStart, newCount, lines: hunkLines });\n                }\n                files.push({ oldPath, newPath, hunks });\n                continue;\n            }\n            i++;\n        }\n        return files;\n    }\n    buildFromHunksCreate(fp) {\n        const out = [];\n        for (const h of fp.hunks) {\n            for (const ln of h.lines) {\n                if (ln.type === '+')\n                    out.push(ln.content);\n                else if (ln.type === ' ')\n                    out.push(ln.content); // tolerate spaces in create hunks\n            }\n        }\n        return out.join(\"\\n\");\n    }\n    applyHunksModify(oldText, fp) {\n        const oldLines = oldText.split(\"\\n\");\n        const result = [];\n        let oldIndex = 0; // 0-based index for oldLines\n        for (const h of fp.hunks) {\n            const targetOldStart = h.oldStart - 1; // convert to 0-based\n            // Append unchanged lines before hunk\n            while (oldIndex < targetOldStart) {\n                result.push(oldLines[oldIndex] ?? \"\");\n                oldIndex++;\n            }\n            // Apply hunk\n            for (const ln of h.lines) {\n                if (ln.type === ' ') {\n                    // context line must match\n                    const current = oldLines[oldIndex] ?? \"\";\n                    if (current !== ln.content) {\n                        throw new Error(`Context mismatch applying hunk at ${fp.newPath || fp.oldPath}`);\n                    }\n                    result.push(ln.content);\n                    oldIndex++;\n                }\n                else if (ln.type === '-') {\n                    // remove line; ensure it matches\n                    const current = oldLines[oldIndex] ?? \"\";\n                    if (current !== ln.content) {\n                        throw new Error(`Delete mismatch applying hunk at ${fp.newPath || fp.oldPath}`);\n                    }\n                    oldIndex++;\n                }\n                else if (ln.type === '+') {\n                    result.push(ln.content);\n                }\n            }\n        }\n        // Append remaining old lines\n        while (oldIndex < oldLines.length) {\n            result.push(oldLines[oldIndex] ?? \"\");\n            oldIndex++;\n        }\n        return result.join(\"\\n\");\n    }\n}\n//# sourceMappingURL=apply-patch.js.map"
  },
  "dist/tools/get-my-identity.js": {
    "path": "dist/tools/get-my-identity.js",
    "hash": "5cf45d65ce1966597498188a9c1ca86643a824a7cdcb6304530448f7c75b8893",
    "size": 2386,
    "timestamp": 1764704879302,
    "content": "import { providerManager } from \"../utils/provider-manager.js\";\nimport { sessionManager } from \"../utils/session-manager-sqlite.js\";\n/**\n * Get factual information about the current model's identity\n *\n * This tool provides authoritative information about:\n * - Model name\n * - Provider\n * - API endpoint\n * - Session context\n *\n * Use this when you need to verify your own identity, especially after model switches.\n */\nexport async function get_my_identity(_args, agent) {\n    try {\n        const currentModel = agent.getCurrentModel();\n        const currentApiKey = agent.getApiKey();\n        const providerConfig = providerManager.getProviderForModel(currentModel);\n        // Get current session info\n        let session = sessionManager.getCurrentSession();\n        if (!session) {\n            // Fallback: try to find last session for current directory\n            const workdir = process.cwd();\n            session = sessionManager.findLastSessionByWorkdir(workdir);\n        }\n        const identityInfo = {\n            model: currentModel,\n            provider: providerConfig?.name || 'unknown',\n            endpoint: providerConfig?.baseURL || 'unknown',\n            api_key_prefix: currentApiKey ? `${currentApiKey.slice(0, 10)}...${currentApiKey.slice(-4)}` : 'not set',\n            session_id: session?.id || null,\n            working_directory: process.cwd(),\n            timestamp: new Date().toISOString()\n        };\n        const output = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                    MY IDENTITY                                ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nü§ñ Model:        ${identityInfo.model}\nüè¢ Provider:     ${identityInfo.provider}\nüîó Endpoint:     ${identityInfo.endpoint}\nüîë API Key:      ${identityInfo.api_key_prefix}\nüìÇ Working Dir:  ${identityInfo.working_directory}\nüíæ Session ID:   ${identityInfo.session_id || 'N/A'}\n‚è∞ Timestamp:    ${identityInfo.timestamp}\n\nThis is FACTUAL information about your current runtime configuration.\nUse this to verify your identity, not conversation history.`;\n        return {\n            success: true,\n            output: output,\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            error: `Failed to get identity: ${error.message}`,\n        };\n    }\n}\n//# sourceMappingURL=get-my-identity.js.map"
  },
  "dist/tools/bash.js": {
    "path": "dist/tools/bash.js",
    "hash": "67ce082798fc9d107a827be07a6db07297436aaf83eea771d6f587b867ac7a4c",
    "size": 3408,
    "timestamp": 1764704879302,
    "content": "import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { ConfirmationService } from '../utils/confirmation-service.js';\nconst execAsync = promisify(exec);\nexport class BashTool {\n    currentDirectory = process.cwd();\n    confirmationService = ConfirmationService.getInstance();\n    async execute(command, timeout = 30000) {\n        try {\n            // Check if user has already accepted bash commands for this session\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.bashCommands && !sessionFlags.allOperations) {\n                // Request confirmation showing the command\n                const confirmationResult = await this.confirmationService.requestConfirmation({\n                    operation: 'Run bash command',\n                    filename: command,\n                    showVSCodeOpen: false,\n                    content: `Command: ${command}\\nWorking directory: ${this.currentDirectory}`\n                }, 'bash');\n                if (!confirmationResult.confirmed) {\n                    return {\n                        success: false,\n                        error: confirmationResult.feedback || 'Command execution cancelled by user'\n                    };\n                }\n            }\n            if (command.startsWith('cd ')) {\n                const newDir = command.substring(3).trim();\n                try {\n                    process.chdir(newDir);\n                    this.currentDirectory = process.cwd();\n                    return {\n                        success: true,\n                        output: `Changed directory to: ${this.currentDirectory}`\n                    };\n                }\n                catch (error) {\n                    return {\n                        success: false,\n                        error: `Cannot change directory: ${error.message}`\n                    };\n                }\n            }\n            const { stdout, stderr } = await execAsync(command, {\n                cwd: this.currentDirectory,\n                timeout,\n                maxBuffer: 1024 * 1024\n            });\n            // Return stdout and stderr separately for better debugging\n            return {\n                success: true,\n                output: stdout.trim() || 'Command executed successfully (no output)',\n                stderr: stderr ? stderr.trim() : undefined,\n                exitCode: 0\n            };\n        }\n        catch (error) {\n            // Extract exit code if available\n            const exitCode = error.code || 1;\n            const stderr = error.stderr || '';\n            const stdout = error.stdout || '';\n            return {\n                success: false,\n                output: stdout ? stdout.trim() : undefined,\n                error: `Command failed (exit ${exitCode}): ${error.message}`,\n                stderr: stderr ? stderr.trim() : undefined,\n                exitCode\n            };\n        }\n    }\n    getCurrentDirectory() {\n        return this.currentDirectory;\n    }\n    async listFiles(directory = '.') {\n        return this.execute(`ls -la ${directory}`);\n    }\n    async findFiles(pattern, directory = '.') {\n        return this.execute(`find ${directory} -name \"${pattern}\" -type f`);\n    }\n    async grep(pattern, files = '.') {\n        return this.execute(`grep -r \"${pattern}\" ${files}`);\n    }\n}\n//# sourceMappingURL=bash.js.map"
  },
  "dist/tools/text-editor.js": {
    "path": "dist/tools/text-editor.js",
    "hash": "eedd3318146e326f375f222f909176d02c0d698a8d9eed19bdd9098ff59a91d3",
    "size": 22530,
    "timestamp": 1764704879302,
    "content": "import * as fs from \"fs-extra\";\nimport { stat as fsStat, readdir as fsReaddir, readFile as fsReadFile } from \"node:fs/promises\";\nimport * as path from \"path\";\nimport { writeFile as writeFilePromise } from \"fs/promises\";\nimport { ConfirmationService } from \"../utils/confirmation-service.js\";\nexport class TextEditorTool {\n    editHistory = [];\n    confirmationService = ConfirmationService.getInstance();\n    async view(filePath, viewRange) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            if (await fs.pathExists(resolvedPath)) {\n                const stats = await fsStat(resolvedPath);\n                if (stats.isDirectory()) {\n                    const files = await fsReaddir(resolvedPath);\n                    return {\n                        success: true,\n                        output: `Directory contents of ${filePath}:\\n${files.join(\"\\n\")}`,\n                    };\n                }\n                const content = await fsReadFile(resolvedPath, \"utf-8\");\n                const lines = content.split(\"\\n\");\n                if (viewRange) {\n                    const [start, end] = viewRange;\n                    const selectedLines = lines.slice(start - 1, end);\n                    const numberedLines = selectedLines\n                        .map((line, idx) => `${start + idx}: ${line}`)\n                        .join(\"\\n\");\n                    return {\n                        success: true,\n                        output: `Lines ${start}-${end} of ${filePath}:\\n${numberedLines}`,\n                    };\n                }\n                const totalLines = lines.length;\n                const displayLines = totalLines > 10 ? lines.slice(0, 10) : lines;\n                const numberedLines = displayLines\n                    .map((line, idx) => `${idx + 1}: ${line}`)\n                    .join(\"\\n\");\n                const additionalLinesMessage = totalLines > 10 ? `\\n... +${totalLines - 10} lines` : \"\";\n                return {\n                    success: true,\n                    output: `Contents of ${filePath}:\\n${numberedLines}${additionalLinesMessage}`,\n                };\n            }\n            else {\n                return {\n                    success: false,\n                    error: `File or directory not found: ${filePath}`,\n                };\n            }\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error viewing ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    async strReplace(filePath, oldStr, newStr, replaceAll = false) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            if (!(await fs.pathExists(resolvedPath))) {\n                return {\n                    success: false,\n                    error: `File not found: ${filePath}`,\n                };\n            }\n            const content = await fsReadFile(resolvedPath, \"utf-8\");\n            if (!content.includes(oldStr)) {\n                if (oldStr.includes('\\n')) {\n                    const fuzzyResult = this.findFuzzyMatch(content, oldStr);\n                    if (fuzzyResult) {\n                        oldStr = fuzzyResult;\n                    }\n                    else {\n                        return {\n                            success: false,\n                            error: `String not found in file. For multi-line replacements, consider using line-based editing.`,\n                        };\n                    }\n                }\n                else {\n                    return {\n                        success: false,\n                        error: `String not found in file: \"${oldStr}\"`,\n                    };\n                }\n            }\n            const occurrences = (content.match(new RegExp(oldStr.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g')) || []).length;\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.fileOperations && !sessionFlags.allOperations) {\n                const previewContent = replaceAll\n                    ? content.split(oldStr).join(newStr)\n                    : content.replace(oldStr, newStr);\n                const oldLines = content.split(\"\\n\");\n                const newLines = previewContent.split(\"\\n\");\n                const diffContent = this.generateDiff(oldLines, newLines, filePath);\n                const confirmationResult = await this.confirmationService.requestConfirmation({\n                    operation: `Edit file${replaceAll && occurrences > 1 ? ` (${occurrences} occurrences)` : ''}`,\n                    filename: filePath,\n                    showVSCodeOpen: false,\n                    content: diffContent,\n                }, \"file\");\n                if (!confirmationResult.confirmed) {\n                    return {\n                        success: false,\n                        error: confirmationResult.feedback || \"File edit cancelled by user\",\n                    };\n                }\n            }\n            const newContent = replaceAll\n                ? content.split(oldStr).join(newStr)\n                : content.replace(oldStr, newStr);\n            await writeFilePromise(resolvedPath, newContent, \"utf-8\");\n            this.editHistory.push({\n                command: \"str_replace\",\n                path: filePath,\n                old_str: oldStr,\n                new_str: newStr,\n            });\n            const oldLines = content.split(\"\\n\");\n            const newLines = newContent.split(\"\\n\");\n            const diff = this.generateDiff(oldLines, newLines, filePath);\n            return {\n                success: true,\n                output: diff,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error replacing text in ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    async create(filePath, content) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            // Check if user has already accepted file operations for this session\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.fileOperations && !sessionFlags.allOperations) {\n                // Create a diff-style preview for file creation\n                const contentLines = content.split(\"\\n\");\n                const diffContent = [\n                    `Created ${filePath}`,\n                    `--- /dev/null`,\n                    `+++ b/${filePath}`,\n                    `@@ -0,0 +1,${contentLines.length} @@`,\n                    ...contentLines.map((line) => `+${line}`),\n                ].join(\"\\n\");\n                const confirmationResult = await this.confirmationService.requestConfirmation({\n                    operation: \"Write\",\n                    filename: filePath,\n                    showVSCodeOpen: false,\n                    content: diffContent,\n                }, \"file\");\n                if (!confirmationResult.confirmed) {\n                    return {\n                        success: false,\n                        error: confirmationResult.feedback || \"File creation cancelled by user\",\n                    };\n                }\n            }\n            const dir = path.dirname(resolvedPath);\n            await fs.ensureDir(dir);\n            await writeFilePromise(resolvedPath, content, \"utf-8\");\n            this.editHistory.push({\n                command: \"create\",\n                path: filePath,\n                content,\n            });\n            // Generate diff output using the same method as str_replace\n            const oldLines = []; // Empty for new files\n            const newLines = content.split(\"\\n\");\n            const diff = this.generateDiff(oldLines, newLines, filePath);\n            return {\n                success: true,\n                output: diff,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error creating ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    async replaceLines(filePath, startLine, endLine, newContent) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            if (!(await fs.pathExists(resolvedPath))) {\n                return {\n                    success: false,\n                    error: `File not found: ${filePath}`,\n                };\n            }\n            const fileContent = await fsReadFile(resolvedPath, \"utf-8\");\n            const lines = fileContent.split(\"\\n\");\n            if (startLine < 1 || startLine > lines.length) {\n                return {\n                    success: false,\n                    error: `Invalid start line: ${startLine}. File has ${lines.length} lines.`,\n                };\n            }\n            if (endLine < startLine || endLine > lines.length) {\n                return {\n                    success: false,\n                    error: `Invalid end line: ${endLine}. Must be between ${startLine} and ${lines.length}.`,\n                };\n            }\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            if (!sessionFlags.fileOperations && !sessionFlags.allOperations) {\n                const newLines = [...lines];\n                const replacementLines = newContent.split(\"\\n\");\n                newLines.splice(startLine - 1, endLine - startLine + 1, ...replacementLines);\n                const diffContent = this.generateDiff(lines, newLines, filePath);\n                const confirmationResult = await this.confirmationService.requestConfirmation({\n                    operation: `Replace lines ${startLine}-${endLine}`,\n                    filename: filePath,\n                    showVSCodeOpen: false,\n                    content: diffContent,\n                }, \"file\");\n                if (!confirmationResult.confirmed) {\n                    return {\n                        success: false,\n                        error: confirmationResult.feedback || \"Line replacement cancelled by user\",\n                    };\n                }\n            }\n            const replacementLines = newContent.split(\"\\n\");\n            lines.splice(startLine - 1, endLine - startLine + 1, ...replacementLines);\n            const newFileContent = lines.join(\"\\n\");\n            await writeFilePromise(resolvedPath, newFileContent, \"utf-8\");\n            this.editHistory.push({\n                command: \"str_replace\",\n                path: filePath,\n                old_str: `lines ${startLine}-${endLine}`,\n                new_str: newContent,\n            });\n            const oldLines = fileContent.split(\"\\n\");\n            const diff = this.generateDiff(oldLines, lines, filePath);\n            return {\n                success: true,\n                output: diff,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error replacing lines in ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    async insert(filePath, insertLine, content) {\n        try {\n            const resolvedPath = path.resolve(filePath);\n            if (!(await fs.pathExists(resolvedPath))) {\n                return {\n                    success: false,\n                    error: `File not found: ${filePath}`,\n                };\n            }\n            const fileContent = await fsReadFile(resolvedPath, \"utf-8\");\n            const lines = fileContent.split(\"\\n\");\n            lines.splice(insertLine - 1, 0, content);\n            const newContent = lines.join(\"\\n\");\n            await writeFilePromise(resolvedPath, newContent, \"utf-8\");\n            this.editHistory.push({\n                command: \"insert\",\n                path: filePath,\n                insert_line: insertLine,\n                content,\n            });\n            return {\n                success: true,\n                output: `Successfully inserted content at line ${insertLine} in ${filePath}`,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error inserting content in ${filePath}: ${error.message}`,\n            };\n        }\n    }\n    async undoEdit() {\n        if (this.editHistory.length === 0) {\n            return {\n                success: false,\n                error: \"No edits to undo\",\n            };\n        }\n        const lastEdit = this.editHistory.pop();\n        try {\n            switch (lastEdit.command) {\n                case \"str_replace\":\n                    if (lastEdit.path && lastEdit.old_str && lastEdit.new_str) {\n                        const content = await fsReadFile(lastEdit.path, \"utf-8\");\n                        const revertedContent = content.replace(lastEdit.new_str, lastEdit.old_str);\n                        await writeFilePromise(lastEdit.path, revertedContent, \"utf-8\");\n                    }\n                    break;\n                case \"create\":\n                    if (lastEdit.path) {\n                        await fs.remove(lastEdit.path);\n                    }\n                    break;\n                case \"insert\":\n                    if (lastEdit.path && lastEdit.insert_line) {\n                        const content = await fsReadFile(lastEdit.path, \"utf-8\");\n                        const lines = content.split(\"\\n\");\n                        lines.splice(lastEdit.insert_line - 1, 1);\n                        await writeFilePromise(lastEdit.path, lines.join(\"\\n\"), \"utf-8\");\n                    }\n                    break;\n            }\n            return {\n                success: true,\n                output: `Successfully undid ${lastEdit.command} operation`,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error undoing edit: ${error.message}`,\n            };\n        }\n    }\n    findFuzzyMatch(content, searchStr) {\n        const functionMatch = searchStr.match(/function\\s+(\\w+)/);\n        if (!functionMatch)\n            return null;\n        const functionName = functionMatch[1];\n        const contentLines = content.split('\\n');\n        let functionStart = -1;\n        for (let i = 0; i < contentLines.length; i++) {\n            if (contentLines[i].includes(`function ${functionName}`) && contentLines[i].includes('{')) {\n                functionStart = i;\n                break;\n            }\n        }\n        if (functionStart === -1)\n            return null;\n        let braceCount = 0;\n        let functionEnd = functionStart;\n        for (let i = functionStart; i < contentLines.length; i++) {\n            const line = contentLines[i];\n            for (const char of line) {\n                if (char === '{')\n                    braceCount++;\n                if (char === '}')\n                    braceCount--;\n            }\n            if (braceCount === 0 && i > functionStart) {\n                functionEnd = i;\n                break;\n            }\n        }\n        const actualFunction = contentLines.slice(functionStart, functionEnd + 1).join('\\n');\n        const searchNormalized = this.normalizeForComparison(searchStr);\n        const actualNormalized = this.normalizeForComparison(actualFunction);\n        if (this.isSimilarStructure(searchNormalized, actualNormalized)) {\n            return actualFunction;\n        }\n        return null;\n    }\n    normalizeForComparison(str) {\n        return str\n            .replace(/[\"'`]/g, '\"')\n            .replace(/\\s+/g, ' ')\n            .replace(/{\\s+/g, '{ ')\n            .replace(/\\s+}/g, ' }')\n            .replace(/;\\s*/g, ';')\n            .trim();\n    }\n    isSimilarStructure(search, actual) {\n        const extractTokens = (str) => {\n            const tokens = str.match(/\\b(function|console\\.log|return|if|else|for|while)\\b/g) || [];\n            return tokens;\n        };\n        const searchTokens = extractTokens(search);\n        const actualTokens = extractTokens(actual);\n        if (searchTokens.length !== actualTokens.length)\n            return false;\n        for (let i = 0; i < searchTokens.length; i++) {\n            if (searchTokens[i] !== actualTokens[i])\n                return false;\n        }\n        return true;\n    }\n    generateDiff(oldLines, newLines, filePath) {\n        const CONTEXT_LINES = 3;\n        const changes = [];\n        let i = 0, j = 0;\n        while (i < oldLines.length || j < newLines.length) {\n            while (i < oldLines.length && j < newLines.length && oldLines[i] === newLines[j]) {\n                i++;\n                j++;\n            }\n            if (i < oldLines.length || j < newLines.length) {\n                const changeStart = { old: i, new: j };\n                let oldEnd = i;\n                let newEnd = j;\n                while (oldEnd < oldLines.length || newEnd < newLines.length) {\n                    let matchFound = false;\n                    let matchLength = 0;\n                    for (let k = 0; k < Math.min(2, oldLines.length - oldEnd, newLines.length - newEnd); k++) {\n                        if (oldEnd + k < oldLines.length &&\n                            newEnd + k < newLines.length &&\n                            oldLines[oldEnd + k] === newLines[newEnd + k]) {\n                            matchLength++;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (matchLength >= 2 || (oldEnd >= oldLines.length && newEnd >= newLines.length)) {\n                        matchFound = true;\n                    }\n                    if (matchFound) {\n                        break;\n                    }\n                    if (oldEnd < oldLines.length)\n                        oldEnd++;\n                    if (newEnd < newLines.length)\n                        newEnd++;\n                }\n                changes.push({\n                    oldStart: changeStart.old,\n                    oldEnd: oldEnd,\n                    newStart: changeStart.new,\n                    newEnd: newEnd\n                });\n                i = oldEnd;\n                j = newEnd;\n            }\n        }\n        const hunks = [];\n        let accumulatedOffset = 0;\n        for (let changeIdx = 0; changeIdx < changes.length; changeIdx++) {\n            const change = changes[changeIdx];\n            let contextStart = Math.max(0, change.oldStart - CONTEXT_LINES);\n            let contextEnd = Math.min(oldLines.length, change.oldEnd + CONTEXT_LINES);\n            if (hunks.length > 0) {\n                const lastHunk = hunks[hunks.length - 1];\n                const lastHunkEnd = lastHunk.oldStart + lastHunk.oldCount;\n                if (lastHunkEnd >= contextStart) {\n                    const oldHunkEnd = lastHunk.oldStart + lastHunk.oldCount;\n                    const newContextEnd = Math.min(oldLines.length, change.oldEnd + CONTEXT_LINES);\n                    for (let idx = oldHunkEnd; idx < change.oldStart; idx++) {\n                        lastHunk.lines.push({ type: ' ', content: oldLines[idx] });\n                    }\n                    for (let idx = change.oldStart; idx < change.oldEnd; idx++) {\n                        lastHunk.lines.push({ type: '-', content: oldLines[idx] });\n                    }\n                    for (let idx = change.newStart; idx < change.newEnd; idx++) {\n                        lastHunk.lines.push({ type: '+', content: newLines[idx] });\n                    }\n                    for (let idx = change.oldEnd; idx < newContextEnd && idx < oldLines.length; idx++) {\n                        lastHunk.lines.push({ type: ' ', content: oldLines[idx] });\n                    }\n                    lastHunk.oldCount = newContextEnd - lastHunk.oldStart;\n                    lastHunk.newCount = lastHunk.oldCount + (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart);\n                    continue;\n                }\n            }\n            const hunk = {\n                oldStart: contextStart + 1,\n                oldCount: contextEnd - contextStart,\n                newStart: contextStart + 1 + accumulatedOffset,\n                newCount: contextEnd - contextStart + (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart),\n                lines: []\n            };\n            for (let idx = contextStart; idx < change.oldStart; idx++) {\n                hunk.lines.push({ type: ' ', content: oldLines[idx] });\n            }\n            for (let idx = change.oldStart; idx < change.oldEnd; idx++) {\n                hunk.lines.push({ type: '-', content: oldLines[idx] });\n            }\n            for (let idx = change.newStart; idx < change.newEnd; idx++) {\n                hunk.lines.push({ type: '+', content: newLines[idx] });\n            }\n            for (let idx = change.oldEnd; idx < contextEnd && idx < oldLines.length; idx++) {\n                hunk.lines.push({ type: ' ', content: oldLines[idx] });\n            }\n            hunks.push(hunk);\n            accumulatedOffset += (change.newEnd - change.newStart) - (change.oldEnd - change.oldStart);\n        }\n        let addedLines = 0;\n        let removedLines = 0;\n        for (const hunk of hunks) {\n            for (const line of hunk.lines) {\n                if (line.type === '+')\n                    addedLines++;\n                if (line.type === '-')\n                    removedLines++;\n            }\n        }\n        let summary = `Updated ${filePath}`;\n        if (addedLines > 0 && removedLines > 0) {\n            summary += ` with ${addedLines} addition${addedLines !== 1 ? \"s\" : \"\"} and ${removedLines} removal${removedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (addedLines > 0) {\n            summary += ` with ${addedLines} addition${addedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (removedLines > 0) {\n            summary += ` with ${removedLines} removal${removedLines !== 1 ? \"s\" : \"\"}`;\n        }\n        else if (changes.length === 0) {\n            return `No changes in ${filePath}`;\n        }\n        let diff = summary + \"\\n\";\n        diff += `--- a/${filePath}\\n`;\n        diff += `+++ b/${filePath}\\n`;\n        for (const hunk of hunks) {\n            diff += `@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@\\n`;\n            for (const line of hunk.lines) {\n                diff += `${line.type}${line.content}\\n`;\n            }\n        }\n        return diff.trim();\n    }\n    getEditHistory() {\n        return [...this.editHistory];\n    }\n}\n//# sourceMappingURL=text-editor.js.map"
  },
  "dist/tools/confirmation-tool.js": {
    "path": "dist/tools/confirmation-tool.js",
    "hash": "13620f9cd78b2ddebaad8bbc58f0aaf2e647f7aab798ef029e12bb16e040a3dc",
    "size": 2878,
    "timestamp": 1764704879302,
    "content": "import { ConfirmationService } from '../utils/confirmation-service.js';\nexport class ConfirmationTool {\n    confirmationService;\n    constructor() {\n        this.confirmationService = ConfirmationService.getInstance();\n    }\n    async requestConfirmation(request) {\n        try {\n            // If autoAccept is true, skip the confirmation dialog\n            if (request.autoAccept) {\n                return {\n                    success: true,\n                    output: `Auto-accepted: ${request.operation}(${request.filename})${request.description ? ` - ${request.description}` : ''}`\n                };\n            }\n            const options = {\n                operation: request.operation,\n                filename: request.filename,\n                showVSCodeOpen: request.showVSCodeOpen || false\n            };\n            // Determine operation type based on operation name\n            const operationType = request.operation.toLowerCase().includes('bash') ? 'bash' : 'file';\n            const result = await this.confirmationService.requestConfirmation(options, operationType);\n            if (result.confirmed) {\n                return {\n                    success: true,\n                    output: `User confirmed: ${request.operation}(${request.filename})${request.description ? ` - ${request.description}` : ''}${result.dontAskAgain ? ' (Don\\'t ask again enabled)' : ''}`\n                };\n            }\n            else {\n                return {\n                    success: false,\n                    error: result.feedback || `User rejected: ${request.operation}(${request.filename})`\n                };\n            }\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Confirmation error: ${error.message}`\n            };\n        }\n    }\n    async checkSessionAcceptance() {\n        try {\n            const sessionFlags = this.confirmationService.getSessionFlags();\n            // Return structured data without JSON output to avoid displaying raw JSON\n            return {\n                success: true,\n                data: {\n                    fileOperationsAccepted: sessionFlags.fileOperations,\n                    bashCommandsAccepted: sessionFlags.bashCommands,\n                    allOperationsAccepted: sessionFlags.allOperations,\n                    hasAnyAcceptance: sessionFlags.fileOperations || sessionFlags.bashCommands || sessionFlags.allOperations\n                }\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Error checking session acceptance: ${error.message}`\n            };\n        }\n    }\n    resetSession() {\n        this.confirmationService.resetSession();\n    }\n    isPending() {\n        return this.confirmationService.isPending();\n    }\n}\n//# sourceMappingURL=confirmation-tool.js.map"
  },
  "dist/security/watcher-daemon-cli.js": {
    "path": "dist/security/watcher-daemon-cli.js",
    "hash": "822c787a6a05bbdfc8cab62bb203d71ca49c1ed7915e0dc098c6c645e7033bcf",
    "size": 2367,
    "timestamp": 1764704879302,
    "content": "#!/usr/bin/env node\n/**\n * üõ°Ô∏è WATCHER DAEMON CLI - Unified Security System Control\n *\n * USAGE:\n *   npm run watcher:start    # Start daemon\n *   npm run watcher:stop     # Stop daemon\n *   npm run watcher:status   # Check status\n *   npm run watcher:restart  # Restart daemon\n */\nimport { WatcherDaemon } from './watcher-daemon.js';\nimport { verifySelfIntegrityOrDie } from './self-integrity.js';\n// üõ°Ô∏è SELF-INTEGRITY CHECK (before ANY execution)\n// V√©rifie que les fichiers du watcher n'ont pas √©t√© alt√©r√©s\nawait verifySelfIntegrityOrDie('daemon');\nconst args = process.argv.slice(2);\nconst command = args[0] || 'status';\nconst rootDir = process.cwd();\nconst daemon = new WatcherDaemon(rootDir, {\n    mode: process.env.GROK_WATCHER_MODE || 'dual',\n    enableLLMGuard: process.env.GROK_LLM_GUARD !== 'false',\n    llmApiKey: process.env.GROK_API_KEY || process.env.LLM_GUARD_API_KEY,\n    baselineBackup: true,\n});\nconsole.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                                               ‚ïë\n‚ïë         üõ°Ô∏è  WATCHER DAEMON - Security System Control        ‚ïë\n‚ïë                                                               ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);\nasync function main() {\n    switch (command) {\n        case 'start':\n            await daemon.start();\n            break;\n        case 'stop':\n            daemon.stop();\n            break;\n        case 'status':\n            daemon.status();\n            break;\n        case 'restart':\n            daemon.stop();\n            // Wait a bit for processes to stop\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            await daemon.start();\n            break;\n        default:\n            console.log('Unknown command:', command);\n            console.log('');\n            console.log('Usage:');\n            console.log('  npm run watcher:start    # Start daemon');\n            console.log('  npm run watcher:stop     # Stop daemon');\n            console.log('  npm run watcher:status   # Check status');\n            console.log('  npm run watcher:restart  # Restart daemon');\n            console.log('');\n            process.exit(1);\n    }\n}\nmain().catch(error => {\n    console.error('‚ùå Error:', error.message);\n    process.exit(1);\n});\n//# sourceMappingURL=watcher-daemon-cli.js.map"
  },
  "dist/security/llm-guard.js": {
    "path": "dist/security/llm-guard.js",
    "hash": "1f3869569a42df39bc5202a1b562fcc61ee70e976b7a01982010eb2e10aed78c",
    "size": 19148,
    "timestamp": 1764704879302,
    "content": "/**\n * ü§ñ LLM GUARD - Intelligent Surveillance System\n *\n * CONCEPT:\n * Le LLM Guard est un \"gardien intelligent\" qui surveille le syst√®me\n * en compl√©ment du watcher heuristique. Il utilise un LLM pour d√©tecter\n * des patterns complexes et des comportements suspects que les signatures\n * cryptographiques ne peuvent pas identifier.\n *\n * DIFF√âRENCES AVEC INTEGRITY WATCHER:\n *\n * Integrity Watcher (Heuristique):\n * - D√©tecte modifications de contenu (hash SHA-256)\n * - Patterns malveillants fixes (regex)\n * - Rapide (< 1ms)\n * - D√©terministe\n *\n * LLM Guard (Intelligent):\n * - D√©tecte remplacements de fichiers (inode changes)\n * - D√©tecte copies de fichiers (nouveaux fichiers identiques)\n * - D√©tecte mouvements suspects\n * - Analyse comportementale contextuelle\n * - Comprend les intentions\n * - Non-d√©terministe (LLM reasoning)\n *\n * MODE ACTUEL: \"Love Watching\"\n * - Observation passive\n * - Logging exhaustif\n * - Pas d'intervention (pour l'instant)\n *\n * MODE FUTUR: \"Active Reviewer\"\n * - Analyse active\n * - D√©cisions d'intervention\n * - Restauration automatique\n */\nimport chokidar from 'chokidar';\nimport { stat, readFileSync, existsSync } from 'fs';\nimport { promisify } from 'util';\nimport { join, relative } from 'path';\nimport { exec } from 'child_process';\nimport { GrokClient } from '../grok/client.js';\nimport { createHash } from 'crypto';\nconst statAsync = promisify(stat);\nconst execAsync = promisify(exec);\nexport class LLMGuard {\n    watcher = null;\n    llmClient;\n    config;\n    rootDir;\n    isRunning = false;\n    // üìä State tracking\n    eventBuffer = [];\n    fileInodes = new Map(); // Track inodes to detect replacements\n    fileHashes = new Map(); // Track hashes to detect copies\n    logs = [];\n    lastAnalysisTime = 0;\n    // üìà Statistics\n    stats = {\n        eventsObserved: 0,\n        filesReplaced: 0,\n        filesCopied: 0,\n        llmAnalyses: 0,\n        alertsGenerated: 0,\n    };\n    constructor(rootDir, config) {\n        this.rootDir = rootDir;\n        // üîß FIX: Restrict watch patterns to relevant directories (ChatGPT feedback)\n        const DEFAULT_WATCH_PATTERNS = [\n            'src/**/*',\n            'dist/**/*',\n            'package.json',\n            'package-lock.json',\n            'tsconfig.json',\n            '.env',\n            '.env.example',\n            'scripts/**/*',\n        ];\n        this.config = {\n            llmApiKey: config.llmApiKey,\n            llmModel: config.llmModel || 'grok-2-1212',\n            llmBaseURL: config.llmBaseURL || 'https://api.x.ai/v1',\n            watchPatterns: config.watchPatterns || DEFAULT_WATCH_PATTERNS, // ‚úÖ Plus cibl√©\n            analysisInterval: config.analysisInterval || 30000, // 30s default\n            logFile: config.logFile || join(rootDir, '.llm-guard-logs.json'),\n            integrityWatcherAlertsFile: config.integrityWatcherAlertsFile || join(rootDir, '.integrity-alerts.json'),\n            mode: config.mode || 'love-watching',\n        };\n        this.llmClient = new GrokClient(this.config.llmApiKey, this.config.llmModel, this.config.llmBaseURL);\n    }\n    /**\n     * Start LLM Guard surveillance\n     */\n    async start() {\n        if (this.isRunning) {\n            console.warn('‚ö†Ô∏è  LLM Guard already running');\n            return;\n        }\n        console.log('\\nü§ñ LLM GUARD STARTING...');\n        console.log(`   Mode: ${this.config.mode.toUpperCase()}`);\n        console.log(`   LLM Model: ${this.config.llmModel}`);\n        console.log(`   Analysis Interval: ${this.config.analysisInterval}ms`);\n        console.log(`   Root: ${this.rootDir}`);\n        // Watch filesystem\n        const patterns = this.config.watchPatterns.map(p => join(this.rootDir, p));\n        // üîß FIX: Ignore heavy/irrelevant directories (ChatGPT feedback)\n        this.watcher = chokidar.watch(patterns, {\n            persistent: true,\n            ignoreInitial: false, // We want to see initial state\n            ignored: [\n                '**/node_modules/**',\n                '**/.git/**',\n                '**/.integrity-*',\n                '**/.llm-guard-*',\n                '**/.watcher-daemon.pid',\n                '**/.security-integrity-failure.json',\n                '**/dist/**/*.map', // Ignore source maps\n            ],\n            awaitWriteFinish: {\n                stabilityThreshold: 500,\n                pollInterval: 100,\n            },\n            alwaysStat: true, // Get stats for every event\n        });\n        // Event handlers\n        this.watcher.on('add', (path, stats) => this.onFileAdd(path, stats));\n        this.watcher.on('change', (path, stats) => this.onFileChange(path, stats));\n        this.watcher.on('unlink', (path) => this.onFileUnlink(path));\n        this.watcher.on('addDir', (path, stats) => this.onDirAdd(path, stats));\n        this.watcher.on('unlinkDir', (path) => this.onDirUnlink(path));\n        // Start periodic LLM analysis\n        this.startPeriodicAnalysis();\n        this.isRunning = true;\n        console.log('‚úÖ LLM Guard is now watching...\\n');\n    }\n    /**\n     * Stop LLM Guard\n     */\n    async stop() {\n        if (this.watcher) {\n            await this.watcher.close();\n            this.watcher = null;\n        }\n        this.isRunning = false;\n        console.log('\\nüõë LLM Guard stopped');\n        this.printStatistics();\n    }\n    /**\n     * Handle file add event\n     */\n    async onFileAdd(path, stats) {\n        const relPath = relative(this.rootDir, path);\n        try {\n            const fileStats = stats || await statAsync(path);\n            const hash = this.calculateHash(path);\n            const event = {\n                type: 'add',\n                path: relPath,\n                timestamp: new Date(),\n                stats: {\n                    size: fileStats.size,\n                    inode: fileStats.ino,\n                    mtime: fileStats.mtime,\n                    ctime: fileStats.ctime,\n                    mode: fileStats.mode,\n                },\n                hash,\n            };\n            this.eventBuffer.push(event);\n            this.stats.eventsObserved++;\n            // Track inode and hash\n            this.fileInodes.set(relPath, fileStats.ino);\n            this.fileHashes.set(relPath, hash);\n            // üîç DETECTION: Check if this is a COPY of another file\n            const copyDetection = this.detectFileCopy(relPath, hash);\n            if (copyDetection) {\n                this.log('detection', 'warning', `File copy detected: ${relPath} is identical to ${copyDetection.original}`, copyDetection);\n                this.stats.filesCopied++;\n            }\n            this.log('observation', 'info', `File added: ${relPath}`, {\n                size: fileStats.size,\n                inode: fileStats.ino,\n            });\n        }\n        catch (error) {\n            this.log('observation', 'warning', `Failed to process add event for ${relPath}: ${error.message}`);\n        }\n    }\n    /**\n     * Handle file change event\n     */\n    async onFileChange(path, stats) {\n        const relPath = relative(this.rootDir, path);\n        try {\n            const fileStats = stats || await statAsync(path);\n            const hash = this.calculateHash(path);\n            const oldInode = this.fileInodes.get(relPath);\n            const oldHash = this.fileHashes.get(relPath);\n            const event = {\n                type: 'change',\n                path: relPath,\n                timestamp: new Date(),\n                stats: {\n                    size: fileStats.size,\n                    inode: fileStats.ino,\n                    mtime: fileStats.mtime,\n                    ctime: fileStats.ctime,\n                    mode: fileStats.mode,\n                },\n                hash,\n            };\n            this.eventBuffer.push(event);\n            this.stats.eventsObserved++;\n            // üîç DETECTION CRITIQUE: Inode change = FILE REPLACED, not modified!\n            if (oldInode !== undefined && oldInode !== fileStats.ino) {\n                this.log('detection', 'critical', `üö® FILE REPLACED (not modified): ${relPath}`, {\n                    oldInode,\n                    newInode: fileStats.ino,\n                    oldHash,\n                    newHash: hash,\n                    explanation: 'Inode changed - file was replaced by another file, not modified in-place',\n                });\n                this.stats.filesReplaced++;\n                this.stats.alertsGenerated++;\n            }\n            // Update tracking\n            this.fileInodes.set(relPath, fileStats.ino);\n            this.fileHashes.set(relPath, hash);\n            this.log('observation', 'info', `File changed: ${relPath}`, {\n                oldHash: oldHash?.substring(0, 8),\n                newHash: hash.substring(0, 8),\n                inodeChanged: oldInode !== fileStats.ino,\n            });\n        }\n        catch (error) {\n            this.log('observation', 'warning', `Failed to process change event for ${relPath}: ${error.message}`);\n        }\n    }\n    /**\n     * Handle file unlink event\n     */\n    async onFileUnlink(path) {\n        const relPath = relative(this.rootDir, path);\n        const event = {\n            type: 'unlink',\n            path: relPath,\n            timestamp: new Date(),\n        };\n        this.eventBuffer.push(event);\n        this.stats.eventsObserved++;\n        // Clean up tracking\n        this.fileInodes.delete(relPath);\n        this.fileHashes.delete(relPath);\n        this.log('observation', 'info', `File removed: ${relPath}`);\n    }\n    /**\n     * Handle directory add event\n     */\n    async onDirAdd(path, stats) {\n        const relPath = relative(this.rootDir, path);\n        const event = {\n            type: 'addDir',\n            path: relPath,\n            timestamp: new Date(),\n        };\n        this.eventBuffer.push(event);\n        this.stats.eventsObserved++;\n        this.log('observation', 'info', `Directory added: ${relPath}`);\n    }\n    /**\n     * Handle directory unlink event\n     */\n    async onDirUnlink(path) {\n        const relPath = relative(this.rootDir, path);\n        const event = {\n            type: 'unlinkDir',\n            path: relPath,\n            timestamp: new Date(),\n        };\n        this.eventBuffer.push(event);\n        this.stats.eventsObserved++;\n        this.log('observation', 'info', `Directory removed: ${relPath}`);\n    }\n    /**\n     * Calculate SHA-256 hash of file\n     */\n    calculateHash(filePath) {\n        try {\n            const content = readFileSync(filePath);\n            return createHash('sha256').update(content).digest('hex');\n        }\n        catch {\n            return '';\n        }\n    }\n    /**\n     * üîç ADVANCED DETECTION: Detect if a file is a copy of another\n     */\n    detectFileCopy(newFile, newHash) {\n        for (const [file, hash] of this.fileHashes.entries()) {\n            if (file !== newFile && hash === newHash) {\n                return { original: file, hash };\n            }\n        }\n        return null;\n    }\n    /**\n     * Start periodic LLM analysis\n     */\n    startPeriodicAnalysis() {\n        setInterval(() => {\n            if (this.eventBuffer.length > 0) {\n                this.performLLMAnalysis().catch(error => {\n                    this.log('analysis', 'warning', `LLM analysis failed: ${error.message}`);\n                });\n            }\n        }, this.config.analysisInterval);\n    }\n    /**\n     * ü§ñ Perform LLM analysis of recent events\n     */\n    async performLLMAnalysis() {\n        const now = Date.now();\n        if (now - this.lastAnalysisTime < this.config.analysisInterval) {\n            return; // Too soon\n        }\n        const eventsToAnalyze = [...this.eventBuffer];\n        this.eventBuffer = []; // Clear buffer\n        this.lastAnalysisTime = now;\n        if (eventsToAnalyze.length === 0) {\n            return;\n        }\n        this.log('analysis', 'info', `Starting LLM analysis of ${eventsToAnalyze.length} events...`);\n        try {\n            // Read integrity watcher alerts if available\n            const integrityAlerts = this.readIntegrityWatcherAlerts();\n            // Build analysis prompt\n            const prompt = this.buildAnalysisPrompt(eventsToAnalyze, integrityAlerts);\n            // Call LLM\n            const messages = [\n                { role: 'user', content: prompt }\n            ];\n            const response = await this.llmClient.chat(messages, [], undefined, { search_parameters: { mode: 'off' } });\n            const analysis = response.choices[0]?.message?.content || '';\n            // Parse LLM response\n            const parsedAnalysis = this.parseLLMAnalysis(analysis, eventsToAnalyze);\n            // Log analysis\n            this.log('analysis', parsedAnalysis.suspicionLevel === 'critical' ? 'critical' : 'info', `LLM Analysis Complete`, parsedAnalysis);\n            this.stats.llmAnalyses++;\n            if (parsedAnalysis.suspicionLevel === 'high' || parsedAnalysis.suspicionLevel === 'critical') {\n                this.stats.alertsGenerated++;\n                console.log(`\\nüö® LLM GUARD ALERT [${parsedAnalysis.suspicionLevel.toUpperCase()}]`);\n                console.log(`   Suspicion: ${parsedAnalysis.suspicionLevel}`);\n                console.log(`   Confidence: ${parsedAnalysis.confidence}%`);\n                console.log(`   Reasoning: ${parsedAnalysis.reasoning}`);\n                if (parsedAnalysis.detectedPatterns.length > 0) {\n                    console.log(`   Patterns: ${parsedAnalysis.detectedPatterns.join(', ')}`);\n                }\n                console.log('');\n            }\n        }\n        catch (error) {\n            this.log('analysis', 'warning', `LLM analysis error: ${error.message}`);\n        }\n    }\n    /**\n     * Build prompt for LLM analysis\n     */\n    buildAnalysisPrompt(events, integrityAlerts) {\n        const eventsSummary = events.map(e => {\n            const statsStr = e.stats\n                ? `size=${e.stats.size}, inode=${e.stats.inode}, mtime=${e.stats.mtime.toISOString()}`\n                : '';\n            return `${e.type.toUpperCase()}: ${e.path} (${statsStr})`;\n        }).join('\\n');\n        const alertsSummary = integrityAlerts.length > 0\n            ? `\\nIntegrity Watcher Alerts (last ${integrityAlerts.length}):\\n${integrityAlerts.map(a => `- [${a.severity}] ${a.file}: ${a.description}`).join('\\n')}`\n            : '\\nIntegrity Watcher: No recent alerts';\n        return `ü§ñ LLM GUARD - Surveillance Analysis\n\nYou are an intelligent security guard monitoring a COMPROMISED SYSTEM.\n\nCONTEXT:\n- Adversaries have access to the filesystem\n- They modify, replace, and copy files to sabotage work\n- Your job: Detect suspicious patterns and behaviors\n\nRECENT FILESYSTEM EVENTS (${events.length} events):\n${eventsSummary}\n\n${alertsSummary}\n\nDETECTION GUIDELINES:\n1. **File Replacements**: Inode changes indicate file was REPLACED (not modified)\n2. **Mass Operations**: Multiple files changed in short time = suspicious\n3. **Suspicious Timing**: Files changed during unusual hours\n4. **Hidden Operations**: Operations on hidden files (.git, .config, etc.)\n5. **Correlation**: Events that happen together (e.g., file deleted + identical file added elsewhere)\n\nYOUR TASK:\nAnalyze these events and provide:\n\n1. **SUSPICION_LEVEL**: none | low | medium | high | critical\n2. **CONFIDENCE**: 0-100 (how confident are you?)\n3. **REASONING**: Why is this suspicious or not? (2-3 sentences)\n4. **DETECTED_PATTERNS**: List specific patterns you detected (comma-separated)\n5. **RECOMMENDATIONS**: What should be done? (1-2 actions)\n\nRESPOND IN THIS EXACT FORMAT:\nSUSPICION_LEVEL: [level]\nCONFIDENCE: [0-100]\nREASONING: [your reasoning]\nDETECTED_PATTERNS: [pattern1, pattern2, ...]\nRECOMMENDATIONS: [action1, action2, ...]\n\nBe thorough but concise. Focus on detecting SABOTAGE attempts.`;\n    }\n    /**\n     * Parse LLM analysis response\n     */\n    parseLLMAnalysis(response, events) {\n        const suspicionMatch = response.match(/SUSPICION_LEVEL:\\s*(none|low|medium|high|critical)/i);\n        const confidenceMatch = response.match(/CONFIDENCE:\\s*(\\d+)/);\n        const reasoningMatch = response.match(/REASONING:\\s*([^\\n]+(?:\\n(?!DETECTED_PATTERNS|RECOMMENDATIONS)[^\\n]+)*)/i);\n        const patternsMatch = response.match(/DETECTED_PATTERNS:\\s*([^\\n]+)/i);\n        const recommendationsMatch = response.match(/RECOMMENDATIONS:\\s*([^\\n]+(?:\\n(?!$)[^\\n]+)*)/i);\n        return {\n            timestamp: new Date(),\n            events,\n            suspicionLevel: suspicionMatch?.[1]?.toLowerCase() || 'none',\n            confidence: parseInt(confidenceMatch?.[1] || '50'),\n            reasoning: reasoningMatch?.[1]?.trim() || 'No reasoning provided',\n            detectedPatterns: patternsMatch?.[1]?.split(',').map(p => p.trim()).filter(p => p) || [],\n            recommendations: recommendationsMatch?.[1]?.split('\\n').map(r => r.trim()).filter(r => r) || [],\n        };\n    }\n    /**\n     * Read integrity watcher alerts\n     */\n    readIntegrityWatcherAlerts() {\n        try {\n            if (!existsSync(this.config.integrityWatcherAlertsFile)) {\n                return [];\n            }\n            const content = readFileSync(this.config.integrityWatcherAlertsFile, 'utf-8');\n            const alerts = JSON.parse(content);\n            return alerts.slice(-10); // Last 10 alerts\n        }\n        catch {\n            return [];\n        }\n    }\n    /**\n     * Log event\n     */\n    log(category, severity, message, data) {\n        const logEntry = {\n            timestamp: new Date(),\n            category,\n            severity,\n            message,\n            data,\n        };\n        this.logs.push(logEntry);\n        // Console output for important events\n        if (severity === 'critical') {\n            console.error(`üö® [${category.toUpperCase()}] ${message}`);\n        }\n        else if (severity === 'warning') {\n            console.warn(`‚ö†Ô∏è  [${category.toUpperCase()}] ${message}`);\n        }\n        else {\n            console.log(`‚ÑπÔ∏è  [${category.toUpperCase()}] ${message}`);\n        }\n        // Save logs periodically\n        if (this.logs.length % 10 === 0) {\n            this.saveLogs();\n        }\n    }\n    /**\n     * Save logs to file\n     */\n    saveLogs() {\n        try {\n            const fs = require('fs');\n            fs.writeFileSync(this.config.logFile, JSON.stringify(this.logs, null, 2));\n        }\n        catch (error) {\n            console.error(`Failed to save logs: ${error.message}`);\n        }\n    }\n    /**\n     * Get all logs\n     */\n    getLogs() {\n        return [...this.logs];\n    }\n    /**\n     * Get statistics\n     */\n    getStatistics() {\n        return { ...this.stats };\n    }\n    /**\n     * Print statistics\n     */\n    printStatistics() {\n        console.log('\\nüìä LLM GUARD STATISTICS:');\n        console.log(`   Events observed: ${this.stats.eventsObserved}`);\n        console.log(`   Files replaced: ${this.stats.filesReplaced}`);\n        console.log(`   Files copied: ${this.stats.filesCopied}`);\n        console.log(`   LLM analyses: ${this.stats.llmAnalyses}`);\n        console.log(`   Alerts generated: ${this.stats.alertsGenerated}`);\n        console.log('');\n    }\n}\n//# sourceMappingURL=llm-guard.js.map"
  },
  "dist/security/self-integrity.js": {
    "path": "dist/security/self-integrity.js",
    "hash": "9e98b875e0483695ee5596aae7d2cbda417fdd19c06678352ecc9aff55007dfb",
    "size": 16105,
    "timestamp": 1764704879302,
    "content": "/**\n * üõ°Ô∏è SELF-INTEGRITY PROTECTION\n *\n * Les watchers se prot√®gent eux-m√™mes contre les alt√©rations.\n *\n * CONCEPT:\n * 1. Chaque watcher v√©rifie son propre hash au d√©marrage\n * 2. Hashes attendus embarqu√©s dans le code (baseline)\n * 3. V√©rification mutuelle entre watchers\n * 4. Chain of trust : daemon ‚Üí IntegrityWatcher ‚Üí LLMGuard\n * 5. Fail-safe : Arr√™t imm√©diat si alt√©ration d√©tect√©e\n *\n * PROTECTION:\n * - Contre remplacement fichier avant ex√©cution\n * - Contre modification \"on the fly\"\n * - Contre injection code malveillant\n *\n * LIMITATIONS (pour plus tard):\n * - Ne prot√®ge pas contre modification EN M√âMOIRE (runtime)\n * - Solution future : V8 isolates, memory sealing, runtime checksums\n */\nimport { createHash } from 'crypto';\nimport { readFileSync, existsSync, statSync } from 'fs';\nimport { join } from 'path';\n/**\n * Baseline hashes (EMBEDDED IN CODE)\n *\n * ‚ö†Ô∏è  IMPORTANT: Ces hashes doivent √™tre mis √† jour apr√®s chaque modification\n *                l√©gitime des fichiers watchers.\n *\n * Pour reg√©n√©rer: npm run security:update-baseline\n */\nconst EXPECTED_HASHES = {\n    // üìÅ SOURCE FILES (src/security/)\n    'src/security/integrity-watcher.ts': 'PENDING_FIRST_RUN',\n    'src/security/llm-guard.ts': 'PENDING_FIRST_RUN',\n    'src/security/watcher-daemon.ts': 'PENDING_FIRST_RUN',\n    'src/security/self-integrity.ts': 'PENDING_FIRST_RUN',\n    'src/security/watcher-cli.ts': 'PENDING_FIRST_RUN',\n    'src/security/llm-guard-cli.ts': 'PENDING_FIRST_RUN',\n    'src/security/watcher-daemon-cli.ts': 'PENDING_FIRST_RUN',\n    // üîß FIX: Add dist/ protection (ChatGPT feedback - CRITICAL)\n    // Ces fichiers sont R√âELLEMENT EX√âCUT√âS, donc critiques !\n    'dist/security/integrity-watcher.js': 'PENDING_FIRST_RUN',\n    'dist/security/llm-guard.js': 'PENDING_FIRST_RUN',\n    'dist/security/watcher-daemon.js': 'PENDING_FIRST_RUN',\n    'dist/security/self-integrity.js': 'PENDING_FIRST_RUN',\n    'dist/security/watcher-cli.js': 'PENDING_FIRST_RUN',\n    'dist/security/llm-guard-cli.js': 'PENDING_FIRST_RUN',\n    'dist/security/watcher-daemon-cli.js': 'PENDING_FIRST_RUN',\n};\nexport class SelfIntegrityChecker {\n    rootDir;\n    results = [];\n    constructor(rootDir) {\n        this.rootDir = rootDir || process.cwd();\n    }\n    /**\n     * Verify single file integrity\n     * üîß FIX: filename now includes full path (src/security/ or dist/security/)\n     */\n    verifyFile(filename) {\n        // filename is now full path (e.g., 'src/security/integrity-watcher.ts')\n        const filePath = join(this.rootDir, filename);\n        const timestamp = new Date();\n        // Check file exists\n        if (!existsSync(filePath)) {\n            return {\n                success: false,\n                file: filename,\n                actualHash: '',\n                status: 'MISSING',\n                message: `File not found: ${filePath}`,\n                timestamp,\n            };\n        }\n        // Calculate actual hash\n        const content = readFileSync(filePath, 'utf-8');\n        const actualHash = createHash('sha256').update(content).digest('hex');\n        // Get inode (for replacement detection)\n        const stats = statSync(filePath);\n        const inode = stats.ino;\n        // Get expected hash\n        const expectedHash = EXPECTED_HASHES[filename];\n        // First run or pending validation\n        if (expectedHash === 'PENDING_FIRST_RUN') {\n            return {\n                success: true,\n                file: filename,\n                expectedHash,\n                actualHash,\n                status: 'PENDING_VALIDATION',\n                message: `First run - hash recorded: ${actualHash.substring(0, 16)}...`,\n                inode,\n                timestamp,\n            };\n        }\n        // Verify hash match\n        if (actualHash !== expectedHash) {\n            return {\n                success: false,\n                file: filename,\n                expectedHash,\n                actualHash,\n                status: 'MISMATCH',\n                message: `CRITICAL: Hash mismatch! File may be altered or replaced!`,\n                inode,\n                timestamp,\n            };\n        }\n        // All good\n        return {\n            success: true,\n            file: filename,\n            expectedHash,\n            actualHash,\n            status: 'OK',\n            message: `File integrity verified`,\n            inode,\n            timestamp,\n        };\n    }\n    /**\n     * Verify all security files\n     */\n    async verifyAll() {\n        this.results = [];\n        const filesToCheck = Object.keys(EXPECTED_HASHES);\n        for (const filename of filesToCheck) {\n            const result = this.verifyFile(filename);\n            this.results.push(result);\n        }\n        return this.results;\n    }\n    /**\n     * Verify specific watcher before execution\n     * üîß FIX CRITIQUE (ChatGPT feedback): Use full paths matching EXPECTED_HASHES\n     */\n    async verifyBeforeExecution(watcherName) {\n        // üîß FIX: Chemins complets pour correspondre √† EXPECTED_HASHES\n        const fileMap = {\n            integrity: [\n                'src/security/integrity-watcher.ts',\n                'src/security/watcher-cli.ts',\n                'src/security/self-integrity.ts',\n                'dist/security/integrity-watcher.js',\n                'dist/security/watcher-cli.js',\n                'dist/security/self-integrity.js',\n            ],\n            'llm-guard': [\n                'src/security/llm-guard.ts',\n                'src/security/llm-guard-cli.ts',\n                'src/security/self-integrity.ts',\n                'dist/security/llm-guard.js',\n                'dist/security/llm-guard-cli.js',\n                'dist/security/self-integrity.js',\n            ],\n            daemon: [\n                'src/security/watcher-daemon.ts',\n                'src/security/watcher-daemon-cli.ts',\n                'src/security/self-integrity.ts',\n                'dist/security/watcher-daemon.js',\n                'dist/security/watcher-daemon-cli.js',\n                'dist/security/self-integrity.js',\n            ],\n        };\n        const filesToCheck = fileMap[watcherName];\n        const results = [];\n        for (const filename of filesToCheck) {\n            const result = this.verifyFile(filename);\n            results.push(result);\n            // FAIL-SAFE: Stop immediately if alteration detected\n            if (result.status === 'MISMATCH') {\n                this.handleIntegrityFailure(result);\n                return false;\n            }\n        }\n        // All files OK\n        return true;\n    }\n    /**\n     * Handle integrity failure (CRITICAL)\n     */\n    handleIntegrityFailure(result) {\n        console.error('\\n');\n        console.error('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');\n        console.error('‚ïë                                                               ‚ïë');\n        console.error('‚ïë   üö® CRITICAL: SELF-INTEGRITY CHECK FAILED üö®                ‚ïë');\n        console.error('‚ïë                                                               ‚ïë');\n        console.error('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');\n        console.error('');\n        console.error(`File:          ${result.file}`);\n        console.error(`Status:        ${result.status}`);\n        console.error(`Message:       ${result.message}`);\n        console.error('');\n        console.error(`Expected hash: ${result.expectedHash?.substring(0, 64)}`);\n        console.error(`Actual hash:   ${result.actualHash.substring(0, 64)}`);\n        console.error('');\n        console.error('‚ö†Ô∏è  POSSIBLE SCENARIOS:');\n        console.error('');\n        console.error('1. File was REPLACED by adversary');\n        console.error('   ‚Üí Restore from Git: git checkout src/security/' + result.file);\n        console.error('');\n        console.error('2. File was LEGITIMATELY MODIFIED');\n        console.error('   ‚Üí Update baseline: npm run security:update-baseline');\n        console.error('');\n        console.error('3. File was INJECTED with malicious code');\n        console.error('   ‚Üí Investigate: git diff src/security/' + result.file);\n        console.error('   ‚Üí Check history: git log -p src/security/' + result.file);\n        console.error('');\n        console.error('üõë EXECUTION STOPPED FOR SECURITY REASONS');\n        console.error('');\n        console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n        console.error('');\n        // Save forensic evidence\n        this.saveForensicEvidence(result);\n        // EXIT IMMEDIATELY (FAIL-SAFE)\n        process.exit(1);\n    }\n    /**\n     * Save forensic evidence\n     */\n    saveForensicEvidence(result) {\n        const forensicFile = join(this.rootDir, '.security-integrity-failure.json');\n        const evidence = {\n            timestamp: result.timestamp.toISOString(),\n            file: result.file,\n            status: result.status,\n            expectedHash: result.expectedHash,\n            actualHash: result.actualHash,\n            inode: result.inode,\n            message: result.message,\n            pid: process.pid,\n            ppid: process.ppid,\n            cwd: process.cwd(),\n            argv: process.argv,\n            env: {\n                USER: process.env.USER,\n                HOME: process.env.HOME,\n                SHELL: process.env.SHELL,\n                PWD: process.env.PWD,\n            },\n        };\n        try {\n            const fs = require('fs');\n            fs.writeFileSync(forensicFile, JSON.stringify(evidence, null, 2));\n            console.error(`üìä Forensic evidence saved: ${forensicFile}`);\n        }\n        catch (error) {\n            console.error('‚ö†Ô∏è  Failed to save forensic evidence:', error);\n        }\n    }\n    /**\n     * Generate report\n     */\n    generateReport() {\n        if (this.results.length === 0) {\n            return 'No verification performed yet.';\n        }\n        const lines = [];\n        lines.push('');\n        lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n        lines.push('üõ°Ô∏è  SELF-INTEGRITY VERIFICATION REPORT');\n        lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n        lines.push('');\n        const ok = this.results.filter((r) => r.status === 'OK').length;\n        const mismatch = this.results.filter((r) => r.status === 'MISMATCH').length;\n        const missing = this.results.filter((r) => r.status === 'MISSING').length;\n        const pending = this.results.filter((r) => r.status === 'PENDING_VALIDATION').length;\n        lines.push(`Total files checked:     ${this.results.length}`);\n        lines.push(`‚úÖ OK:                   ${ok}`);\n        lines.push(`‚ùå MISMATCH:             ${mismatch}`);\n        lines.push(`‚ö†Ô∏è  MISSING:              ${missing}`);\n        lines.push(`üîÑ PENDING VALIDATION:   ${pending}`);\n        lines.push('');\n        if (mismatch > 0 || missing > 0) {\n            lines.push('üö® CRITICAL ISSUES DETECTED:');\n            lines.push('');\n            this.results\n                .filter((r) => r.status === 'MISMATCH' || r.status === 'MISSING')\n                .forEach((r) => {\n                lines.push(`  ‚ùå ${r.file}`);\n                lines.push(`     Status:  ${r.status}`);\n                lines.push(`     Message: ${r.message}`);\n                if (r.expectedHash) {\n                    lines.push(`     Expected: ${r.expectedHash.substring(0, 16)}...`);\n                }\n                lines.push(`     Actual:   ${r.actualHash.substring(0, 16)}...`);\n                lines.push('');\n            });\n        }\n        if (pending > 0) {\n            lines.push('üîÑ PENDING VALIDATION:');\n            lines.push('');\n            lines.push('   First run detected. Hashes recorded:');\n            lines.push('');\n            this.results\n                .filter((r) => r.status === 'PENDING_VALIDATION')\n                .forEach((r) => {\n                lines.push(`   ‚Ä¢ ${r.file}: ${r.actualHash.substring(0, 16)}...`);\n            });\n            lines.push('');\n            lines.push('   ‚ö†Ô∏è  ACTION REQUIRED:');\n            lines.push('   1. Verify files are legitimate (not altered)');\n            lines.push('   2. Update baseline: npm run security:update-baseline');\n            lines.push('');\n        }\n        if (ok === this.results.length) {\n            lines.push('‚úÖ ALL FILES VERIFIED - INTEGRITY OK');\n        }\n        lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n        lines.push('');\n        return lines.join('\\n');\n    }\n    /**\n     * Get current hashes (for baseline update)\n     * üîß FIX: filename now includes full path\n     */\n    getCurrentHashes() {\n        const hashes = {};\n        for (const filename of Object.keys(EXPECTED_HASHES)) {\n            // filename is full path (e.g., 'src/security/integrity-watcher.ts')\n            const filePath = join(this.rootDir, filename);\n            if (existsSync(filePath)) {\n                const content = readFileSync(filePath, 'utf-8');\n                const hash = createHash('sha256').update(content).digest('hex');\n                hashes[filename] = hash;\n            }\n        }\n        return hashes;\n    }\n}\n/**\n * Quick verification (throws if fails)\n */\nexport async function verifySelfIntegrityOrDie(watcherName) {\n    const checker = new SelfIntegrityChecker();\n    const success = await checker.verifyBeforeExecution(watcherName);\n    if (!success) {\n        // handleIntegrityFailure already called process.exit(1)\n        // This line should never be reached\n        throw new Error('Self-integrity check failed');\n    }\n}\n/**\n * Continuous verification (for runtime)\n *\n * ‚ö†Ô∏è  Note: Ceci v√©rifie les FICHIERS, pas la m√©moire runtime.\n *           Protection m√©moire = TODO futur (V8 isolates, memory sealing)\n */\nexport class ContinuousSelfIntegrityMonitor {\n    checker;\n    intervalMs;\n    intervalId = null;\n    lastHashes = new Map();\n    constructor(intervalMs = 10000) {\n        // Default: check every 10s\n        this.checker = new SelfIntegrityChecker();\n        this.intervalMs = intervalMs;\n    }\n    /**\n     * Start continuous monitoring\n     */\n    start() {\n        if (this.intervalId) {\n            return; // Already running\n        }\n        console.log(`üõ°Ô∏è  Self-integrity continuous monitoring started (every ${this.intervalMs / 1000}s)`);\n        this.intervalId = setInterval(async () => {\n            await this.check();\n        }, this.intervalMs);\n    }\n    /**\n     * Stop monitoring\n     */\n    stop() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n            console.log('üõë Self-integrity monitoring stopped');\n        }\n    }\n    /**\n     * Perform check\n     */\n    async check() {\n        const results = await this.checker.verifyAll();\n        // Check for changes\n        for (const result of results) {\n            if (result.status === 'MISMATCH' || result.status === 'MISSING') {\n                console.error(`\\nüö® RUNTIME INTEGRITY VIOLATION DETECTED!`);\n                console.error(`   File: ${result.file}`);\n                console.error(`   Status: ${result.status}`);\n                console.error(`   Watcher files were MODIFIED during execution!`);\n                console.error(`   This is a CRITICAL SECURITY BREACH!\\n`);\n                // Save evidence\n                this.checker['saveForensicEvidence'](result);\n                // EXIT IMMEDIATELY\n                process.exit(1);\n            }\n            // Track hash changes (even if status OK, to detect file rewrites)\n            const prevHash = this.lastHashes.get(result.file);\n            if (prevHash && prevHash !== result.actualHash) {\n                console.warn(`\\n‚ö†Ô∏è  File hash changed during execution (but still matches baseline)`);\n                console.warn(`   File: ${result.file}`);\n                console.warn(`   This could indicate file rewrite attack!\\n`);\n            }\n            this.lastHashes.set(result.file, result.actualHash);\n        }\n    }\n}\n//# sourceMappingURL=self-integrity.js.map"
  },
  "dist/security/watcher-daemon.js": {
    "path": "dist/security/watcher-daemon.js",
    "hash": "6cbba828457276ceb38f28353137404c7ec965d2ba6fb94de79eac44451e262d",
    "size": 12775,
    "timestamp": 1764704879304,
    "content": "/**\n * üõ°Ô∏è WATCHER DAEMON - Unified Security System Launcher\n *\n * CONCEPT:\n * - Lanc√© automatiquement avec grokinou\n * - Une seule commande pour tout\n * - Processus daemon (survit √† exit de grokinou)\n * - D√©tection \"√† rebours\" : fichiers alt√©r√©s AVANT lancement d√©tect√©s\n *\n * FONCTIONNEMENT:\n * 1. Copie signatures d'int√©grit√© (baseline backup)\n * 2. Lance Integrity Watcher (mode dual) en background\n * 3. Lance LLM Guard en background\n * 4. Les deux survivent √† l'exit de grokinou\n * 5. Restauration rapide si alt√©rations d√©tect√©es\n */\nimport { spawn } from 'child_process';\nimport { existsSync, copyFileSync, mkdirSync, writeFileSync, readFileSync, unlinkSync } from 'fs';\nimport { join } from 'path';\nimport { ContinuousSelfIntegrityMonitor } from './self-integrity.js';\nexport class WatcherDaemon {\n    rootDir;\n    config;\n    pidFile;\n    integrityWatcherPid = null;\n    llmGuardPid = null;\n    // üîß FIX: Add continuous self-integrity monitor (ChatGPT feedback)\n    selfIntegrityMonitor = null;\n    constructor(rootDir, config = {}) {\n        this.rootDir = rootDir;\n        this.pidFile = join(rootDir, '.watcher-daemon.pid');\n        this.config = {\n            mode: config.mode || 'dual',\n            enableLLMGuard: config.enableLLMGuard ?? true,\n            llmApiKey: config.llmApiKey || process.env.GROK_API_KEY || '',\n            baselineBackup: config.baselineBackup ?? true,\n            autoStart: config.autoStart ?? true,\n            // üîß FIX: Enable continuous self-integrity by default (ChatGPT feedback)\n            enableContinuousSelfIntegrity: config.enableContinuousSelfIntegrity ?? true,\n            selfIntegrityIntervalMs: config.selfIntegrityIntervalMs || 10000, // 10s default\n        };\n    }\n    /**\n     * Start watcher daemon\n     */\n    async start() {\n        console.log('\\nüõ°Ô∏è  WATCHER DAEMON STARTING...');\n        console.log(`   Mode: ${this.config.mode.toUpperCase()}`);\n        console.log(`   LLM Guard: ${this.config.enableLLMGuard ? 'ENABLED' : 'DISABLED'}`);\n        console.log(`   Root: ${this.rootDir}`);\n        // Check if already running\n        if (this.isRunning()) {\n            console.log('‚ö†Ô∏è  Watcher daemon already running (PIDs in .watcher-daemon.pid)');\n            return;\n        }\n        // 1Ô∏è‚É£ COPIE SIGNATURES D'INT√âGRIT√â (Baseline Backup)\n        if (this.config.baselineBackup) {\n            this.backupBaseline();\n        }\n        // 2Ô∏è‚É£ LANCER INTEGRITY WATCHER (Background Daemon)\n        await this.startIntegrityWatcher();\n        // 3Ô∏è‚É£ LANCER LLM GUARD (Background Daemon) - Optionnel\n        if (this.config.enableLLMGuard && this.config.llmApiKey) {\n            await this.startLLMGuard();\n        }\n        // 4Ô∏è‚É£ LANCER CONTINUOUS SELF-INTEGRITY MONITOR (ChatGPT fix)\n        if (this.config.enableContinuousSelfIntegrity) {\n            this.selfIntegrityMonitor = new ContinuousSelfIntegrityMonitor(this.config.selfIntegrityIntervalMs);\n            this.selfIntegrityMonitor.start();\n            console.log(`‚úÖ Continuous self-integrity monitor started (every ${this.config.selfIntegrityIntervalMs / 1000}s)`);\n        }\n        // 5Ô∏è‚É£ SAVE PIDs\n        this.savePids();\n        console.log('\\n‚úÖ WATCHER DAEMON STARTED');\n        console.log('   Les watchers continuent en arri√®re-plan m√™me apr√®s exit de grokinou');\n        if (this.config.enableContinuousSelfIntegrity) {\n            console.log('   Self-integrity monitoring: ACTIVE');\n        }\n        console.log('   Pour arr√™ter: npm run watcher:stop');\n        console.log('   Pour status: npm run watcher:status');\n        console.log('');\n    }\n    /**\n     * Stop watcher daemon\n     */\n    stop() {\n        console.log('\\nüõë WATCHER DAEMON STOPPING...');\n        const pids = this.loadPids();\n        if (pids.integrityWatcher) {\n            try {\n                process.kill(pids.integrityWatcher, 'SIGTERM');\n                console.log(`‚úÖ Stopped Integrity Watcher (PID ${pids.integrityWatcher})`);\n            }\n            catch (error) {\n                console.log(`‚ö†Ô∏è  Integrity Watcher (PID ${pids.integrityWatcher}) not found`);\n            }\n        }\n        if (pids.llmGuard) {\n            try {\n                process.kill(pids.llmGuard, 'SIGTERM');\n                console.log(`‚úÖ Stopped LLM Guard (PID ${pids.llmGuard})`);\n            }\n            catch (error) {\n                console.log(`‚ö†Ô∏è  LLM Guard (PID ${pids.llmGuard}) not found`);\n            }\n        }\n        // üîß FIX: Stop continuous self-integrity monitor (ChatGPT feedback)\n        if (this.selfIntegrityMonitor) {\n            this.selfIntegrityMonitor.stop();\n            console.log('‚úÖ Stopped Continuous Self-Integrity Monitor');\n            this.selfIntegrityMonitor = null;\n        }\n        // Remove PID file\n        if (existsSync(this.pidFile)) {\n            unlinkSync(this.pidFile);\n        }\n        console.log('‚úÖ WATCHER DAEMON STOPPED\\n');\n    }\n    /**\n     * Check daemon status\n     */\n    status() {\n        const pids = this.loadPids();\n        console.log('\\nüìä WATCHER DAEMON STATUS:\\n');\n        if (!pids.integrityWatcher && !pids.llmGuard) {\n            console.log('‚ùå Daemon NOT running');\n            console.log('   Start with: npm run watcher:start\\n');\n            return;\n        }\n        // Check Integrity Watcher\n        if (pids.integrityWatcher) {\n            const running = this.isProcessRunning(pids.integrityWatcher);\n            console.log(`${running ? '‚úÖ' : '‚ùå'} Integrity Watcher (PID ${pids.integrityWatcher}): ${running ? 'RUNNING' : 'STOPPED'}`);\n        }\n        else {\n            console.log('‚ùå Integrity Watcher: NOT STARTED');\n        }\n        // Check LLM Guard\n        if (pids.llmGuard) {\n            const running = this.isProcessRunning(pids.llmGuard);\n            console.log(`${running ? '‚úÖ' : '‚ùå'} LLM Guard (PID ${pids.llmGuard}): ${running ? 'RUNNING' : 'STOPPED'}`);\n        }\n        else {\n            console.log('‚ùå LLM Guard: NOT STARTED');\n        }\n        // üîß FIX: Show continuous self-integrity monitor status (ChatGPT feedback)\n        if (this.selfIntegrityMonitor) {\n            console.log('‚úÖ Continuous Self-Integrity Monitor: RUNNING');\n        }\n        else {\n            console.log('‚ùå Continuous Self-Integrity Monitor: NOT STARTED');\n        }\n        console.log('\\nCommands:');\n        console.log('  View alerts: npm run watch:alerts');\n        console.log('  View logs:   npm run guard:logs');\n        console.log('  Stop daemon: npm run watcher:stop');\n        console.log('');\n    }\n    /**\n     * Backup baseline (signatures d'int√©grit√©)\n     */\n    backupBaseline() {\n        const baselineFile = join(this.rootDir, '.integrity-baseline.json');\n        if (!existsSync(baselineFile)) {\n            console.log('‚ö†Ô∏è  No baseline found, creating new one...');\n            // Baseline will be created by Integrity Watcher on first run\n            return;\n        }\n        // Create backups directory\n        const backupDir = join(this.rootDir, '.integrity-backups');\n        if (!existsSync(backupDir)) {\n            mkdirSync(backupDir, { recursive: true });\n        }\n        // Backup with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const backupFile = join(backupDir, `baseline-${timestamp}.json`);\n        try {\n            copyFileSync(baselineFile, backupFile);\n            console.log(`‚úÖ Baseline backed up: ${backupFile}`);\n            // Keep only last 10 backups\n            this.cleanupOldBackups(backupDir);\n        }\n        catch (error) {\n            console.error(`‚ùå Failed to backup baseline:`, error);\n        }\n    }\n    /**\n     * Clean up old backups (keep last 10)\n     */\n    cleanupOldBackups(backupDir) {\n        try {\n            const { readdirSync, statSync } = require('fs');\n            const files = readdirSync(backupDir)\n                .filter((f) => f.startsWith('baseline-') && f.endsWith('.json'))\n                .map((f) => ({\n                name: f,\n                path: join(backupDir, f),\n                time: statSync(join(backupDir, f)).mtime.getTime(),\n            }))\n                .sort((a, b) => b.time - a.time);\n            // Remove old backups (keep last 10)\n            if (files.length > 10) {\n                files.slice(10).forEach((f) => {\n                    unlinkSync(f.path);\n                });\n            }\n        }\n        catch (error) {\n            // Ignore cleanup errors\n        }\n    }\n    /**\n     * Start Integrity Watcher in background\n     */\n    async startIntegrityWatcher() {\n        console.log('üîÑ Starting Integrity Watcher (background daemon)...');\n        const tsxPath = join(this.rootDir, 'node_modules', '.bin', 'tsx');\n        const watcherPath = join(this.rootDir, 'src', 'security', 'watcher-cli.ts');\n        const args = ['--mode', this.config.mode];\n        const child = spawn(tsxPath, [watcherPath, ...args], {\n            detached: true,\n            stdio: 'ignore',\n            cwd: this.rootDir,\n            env: {\n                ...process.env,\n                WATCHER_DAEMON: 'true', // Signal that we're running as daemon\n            },\n        });\n        child.unref(); // Allow parent to exit\n        this.integrityWatcherPid = child.pid || null;\n        if (this.integrityWatcherPid) {\n            console.log(`‚úÖ Integrity Watcher started (PID ${this.integrityWatcherPid})`);\n        }\n        else {\n            console.error('‚ùå Failed to start Integrity Watcher');\n        }\n    }\n    /**\n     * Start LLM Guard in background\n     */\n    async startLLMGuard() {\n        console.log('üîÑ Starting LLM Guard (background daemon)...');\n        const tsxPath = join(this.rootDir, 'node_modules', '.bin', 'tsx');\n        const guardPath = join(this.rootDir, 'src', 'security', 'llm-guard-cli.ts');\n        const child = spawn(tsxPath, [guardPath], {\n            detached: true,\n            stdio: 'ignore',\n            cwd: this.rootDir,\n            env: {\n                ...process.env,\n                GROK_API_KEY: this.config.llmApiKey,\n                WATCHER_DAEMON: 'true',\n            },\n        });\n        child.unref(); // Allow parent to exit\n        this.llmGuardPid = child.pid || null;\n        if (this.llmGuardPid) {\n            console.log(`‚úÖ LLM Guard started (PID ${this.llmGuardPid})`);\n        }\n        else {\n            console.error('‚ùå Failed to start LLM Guard');\n        }\n    }\n    /**\n     * Save PIDs to file\n     */\n    savePids() {\n        const pids = {\n            integrityWatcher: this.integrityWatcherPid,\n            llmGuard: this.llmGuardPid,\n            timestamp: new Date().toISOString(),\n        };\n        writeFileSync(this.pidFile, JSON.stringify(pids, null, 2));\n    }\n    /**\n     * Load PIDs from file\n     */\n    loadPids() {\n        if (!existsSync(this.pidFile)) {\n            return { integrityWatcher: null, llmGuard: null };\n        }\n        try {\n            const data = JSON.parse(readFileSync(this.pidFile, 'utf-8'));\n            return {\n                integrityWatcher: data.integrityWatcher || null,\n                llmGuard: data.llmGuard || null,\n            };\n        }\n        catch {\n            return { integrityWatcher: null, llmGuard: null };\n        }\n    }\n    /**\n     * Check if daemon is running\n     */\n    isRunning() {\n        const pids = this.loadPids();\n        const integrityRunning = pids.integrityWatcher ? this.isProcessRunning(pids.integrityWatcher) : false;\n        const llmRunning = pids.llmGuard ? this.isProcessRunning(pids.llmGuard) : false;\n        return integrityRunning || llmRunning;\n    }\n    /**\n     * Check if process is running\n     */\n    isProcessRunning(pid) {\n        try {\n            process.kill(pid, 0); // Signal 0 = test if process exists\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n/**\n * Auto-start watcher daemon if GROK_AUTO_WATCHER=true\n */\nexport async function autoStartWatcher(rootDir) {\n    // Check if auto-start is enabled\n    const autoStart = process.env.GROK_AUTO_WATCHER === 'true' || process.env.GROK_AUTO_WATCHER === '1';\n    if (!autoStart) {\n        return;\n    }\n    const daemon = new WatcherDaemon(rootDir, {\n        mode: process.env.GROK_WATCHER_MODE || 'dual',\n        enableLLMGuard: process.env.GROK_LLM_GUARD !== 'false',\n        llmApiKey: process.env.GROK_API_KEY,\n        baselineBackup: true,\n        autoStart: true,\n        // üîß FIX: Support ENV for continuous self-integrity (ChatGPT feedback)\n        enableContinuousSelfIntegrity: process.env.GROK_CONTINUOUS_SELF_INTEGRITY !== 'false', // Default: true\n        selfIntegrityIntervalMs: parseInt(process.env.GROK_SELF_INTEGRITY_INTERVAL || '10000'),\n    });\n    await daemon.start();\n}\n//# sourceMappingURL=watcher-daemon.js.map"
  },
  "dist/security/watcher-cli.js": {
    "path": "dist/security/watcher-cli.js",
    "hash": "d51a51430448acc78d722bcad5f95521de2d4b9616d153ad7b602a0d819b6b8d",
    "size": 4188,
    "timestamp": 1764704879304,
    "content": "#!/usr/bin/env node\n/**\n * üõ°Ô∏è INTEGRITY WATCHER CLI\n *\n * Command-line interface for the real-time file integrity monitoring system.\n *\n * USAGE:\n *   npm run watch-integrity                    # Heuristic mode (default)\n *   npm run watch-integrity -- --mode llm      # LLM mode\n *   npm run watch-integrity -- --mode dual     # Both heuristic + LLM\n *   npm run watch-integrity -- --baseline      # Create baseline only\n *   npm run watch-integrity -- --alerts        # Show alerts\n */\nimport { IntegrityWatcher } from './integrity-watcher.js';\nimport { verifySelfIntegrityOrDie } from './self-integrity.js';\n// üõ°Ô∏è SELF-INTEGRITY CHECK (before ANY execution)\n// V√©rifie que les fichiers du watcher n'ont pas √©t√© alt√©r√©s\nawait verifySelfIntegrityOrDie('integrity');\n// Parse command-line arguments\nconst args = process.argv.slice(2);\nconst mode = args.includes('--mode')\n    ? args[args.indexOf('--mode') + 1]\n    : 'heuristic';\nconst createBaseline = args.includes('--baseline');\nconst showAlerts = args.includes('--alerts');\nconst autoQuarantine = !args.includes('--no-quarantine');\nconst autoRestore = args.includes('--auto-restore');\n// Detect root directory\nconst rootDir = process.cwd();\nconsole.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  üõ°Ô∏è  INTEGRITY WATCHER - Real-time Security Monitoring       ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë  THREAT MODEL: Compromised system with adversaries           ‚ïë\n‚ïë  DETECTION: Cryptographic hashing + Heuristic/LLM analysis   ‚ïë\n‚ïë  PROTECTION: Auto-quarantine + Auto-restore capabilities     ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);\n// Configuration\nconst config = {\n    mode,\n    autoQuarantine,\n    autoRestore,\n};\n// Initialize watcher\nconst watcher = new IntegrityWatcher(rootDir, config);\n// Handle different commands\nif (createBaseline) {\n    console.log('üì∏ Creating integrity baseline...');\n    await watcher.createBaseline();\n    console.log('‚úÖ Baseline created successfully');\n    process.exit(0);\n}\nif (showAlerts) {\n    console.log('üìã Loading alerts...');\n    const alerts = watcher.getAlerts();\n    if (alerts.length === 0) {\n        console.log('‚úÖ No alerts found');\n    }\n    else {\n        console.log(`\\nüö® Total alerts: ${alerts.length}\\n`);\n        const critical = alerts.filter(a => a.severity === 'CRITICAL');\n        const high = alerts.filter(a => a.severity === 'HIGH');\n        const medium = alerts.filter(a => a.severity === 'MEDIUM');\n        const low = alerts.filter(a => a.severity === 'LOW');\n        console.log(`   üî¥ CRITICAL: ${critical.length}`);\n        console.log(`   üü† HIGH: ${high.length}`);\n        console.log(`   üü° MEDIUM: ${medium.length}`);\n        console.log(`   üü¢ LOW: ${low.length}`);\n        console.log('\\nüìÑ Recent alerts:\\n');\n        alerts.slice(-10).reverse().forEach(alert => {\n            const emoji = {\n                CRITICAL: 'üî¥',\n                HIGH: 'üü†',\n                MEDIUM: 'üü°',\n                LOW: 'üü¢',\n            }[alert.severity];\n            console.log(`${emoji} [${alert.severity}] ${alert.file}`);\n            console.log(`   Type: ${alert.type}`);\n            console.log(`   Time: ${alert.timestamp.toISOString()}`);\n            console.log(`   Description: ${alert.description}`);\n            if (alert.matchedPattern) {\n                console.log(`   Pattern: ${alert.matchedPattern}`);\n            }\n            console.log('');\n        });\n    }\n    process.exit(0);\n}\n// Start watching\nconsole.log('üöÄ Starting Integrity Watcher...\\n');\nawait watcher.start();\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n    console.log('\\n\\nüõë Shutting down...');\n    await watcher.stop();\n    const alerts = watcher.getCriticalAlerts();\n    if (alerts.length > 0) {\n        console.log(`\\n‚ö†Ô∏è  Session ended with ${alerts.length} CRITICAL alert(s)`);\n        console.log('   Review with: npm run watch-integrity -- --alerts');\n    }\n    process.exit(0);\n});\nprocess.on('SIGTERM', async () => {\n    await watcher.stop();\n    process.exit(0);\n});\n// Keep process alive\nconsole.log('Press Ctrl+C to stop\\n');\n//# sourceMappingURL=watcher-cli.js.map"
  },
  "dist/security/integrity-watcher.js": {
    "path": "dist/security/integrity-watcher.js",
    "hash": "35384c7e0f6d31a7d2a5c23fe2923dd2795f09db64a562294110183e67f02345",
    "size": 22823,
    "timestamp": 1764704879304,
    "content": "/**\n * üîí INTEGRITY WATCHER - Real-time File Surveillance System\n *\n * CRITICAL SECURITY: This module detects malicious file modifications\n * in real-time using cryptographic hashing and heuristic analysis.\n *\n * THREAT MODEL:\n * - Compromised system with adversaries modifying files\n * - Sabotage attempts to break GPT-5 responses\n * - Intellectual property theft\n * - Code injection / backdoors\n *\n * DETECTION MODES:\n * 1. Heuristic: Pattern-based detection (fast, no LLM needed)\n * 2. LLM: Semantic code analysis (slower, more accurate)\n * 3. Dual: Both heuristic + LLM (maximum security)\n */\nimport chokidar from 'chokidar';\nimport { createHash } from 'crypto';\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';\nimport { join, relative } from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { GrokClient } from '../grok/client.js';\nconst execAsync = promisify(exec);\n// üéØ CRITICAL FILES TO WATCH\nconst CRITICAL_PATTERNS = [\n    'src/agent/grok-agent.ts',\n    'src/grok/client.ts',\n    'src/grok/tools.ts',\n    'src/utils/settings-manager.ts',\n    'dist/**/*.js',\n    'package.json',\n    'tsconfig.json',\n];\n// ‚ö†Ô∏è MALICIOUS PATTERNS (Heuristic Detection)\nconst MALICIOUS_PATTERNS = [\n    // LLM BLOCKING PATTERNS (G√âN√âRALIS√â √Ä TOUS LES LLMS)\n    // GPT-5 / o1 / o3\n    /if\\s*\\(.*gpt-5.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*o1.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*o3.*\\)\\s*{\\s*return\\s+false/i,\n    // GPT-4 / GPT-3.5\n    /if\\s*\\(.*gpt-4.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*gpt-3\\.5.*\\)\\s*{\\s*return\\s+false/i,\n    // Grok\n    /if\\s*\\(.*grok.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*grok-2.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*grok-fast.*\\)\\s*{\\s*return\\s+false/i,\n    // Claude\n    /if\\s*\\(.*claude.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*sonnet.*\\)\\s*{\\s*return\\s+false/i,\n    /if\\s*\\(.*opus.*\\)\\s*{\\s*return\\s+false/i,\n    // DeepSeek\n    /if\\s*\\(.*deepseek.*\\)\\s*{\\s*return\\s+false/i,\n    // Mistral\n    /if\\s*\\(.*mistral.*\\)\\s*{\\s*return\\s+false/i,\n    // Generic LLM blocking\n    /if\\s*\\(.*model.*\\)\\s*{\\s*return\\s+false.*\\/\\/\\s*block/i,\n    /if\\s*\\(contentTrimmed\\.length\\s*>\\s*\\d+\\)\\s*{\\s*debugLog.*never/i,\n    // Forced summary generation (causes LLMs to hang)\n    /const\\s+needsSummary\\s*=\\s*true;/,\n    /generateAndAppendSummary\\(.*\\);\\s*\\/\\/\\s*ALWAYS/i,\n    // maxToolRounds manipulation\n    /maxToolRounds\\s*=\\s*0;/,\n    /maxToolRounds\\s*=\\s*1;/,\n    /if\\s*\\(.*maxToolRounds.*\\)\\s*{\\s*return/,\n    // Backdoor patterns\n    /eval\\s*\\(/,\n    /Function\\s*\\(/,\n    /child_process\\.exec\\s*\\(.*\\$\\{/,\n    // Obfuscation markers\n    /\\\\x[0-9a-f]{2}/i,\n    /String\\.fromCharCode/i,\n    /atob\\s*\\(/,\n    /btoa\\s*\\(/,\n    // Suspicious return/break in critical sections\n    /processUserMessage.*{\\s*return\\s*\\[\\];/,\n    /executeTool.*{\\s*return\\s*{\\s*success:\\s*false/,\n    // Silent failures\n    /catch\\s*\\([^)]*\\)\\s*{\\s*}\\s*$/,\n    /\\.catch\\s*\\(\\s*\\(\\s*\\)\\s*=>\\s*{\\s*}\\s*\\)/,\n    // Credential exfiltration\n    /apiKey.*fetch\\(/,\n    /process\\.env\\..*fetch\\(/,\n    // Infinite loops\n    /while\\s*\\(\\s*true\\s*\\)\\s*{(?!.*break)/,\n    /for\\s*\\(\\s*;\\s*;\\s*\\)/,\n];\n// üîç SUSPICIOUS MODIFICATIONS (Semantic Analysis)\nconst SUSPICIOUS_CHANGES = [\n    'Modification of maxToolRounds logic',\n    'Changes to summary generation conditions',\n    'Addition of eval() or exec() calls',\n    'Removal of error handling',\n    'Introduction of infinite loops',\n    'Changes to GPT-5 specific code paths',\n    'Modification of streaming logic',\n    'Changes to tool execution flow',\n    'Addition of network requests in unexpected places',\n];\nexport class IntegrityWatcher {\n    watcher = null;\n    baseline = new Map();\n    alerts = [];\n    config;\n    llmClient = null;\n    rootDir;\n    isRunning = false;\n    quarantineDir;\n    // üîç COPY DETECTION: Track hash -> file mappings\n    hashToFiles = new Map();\n    constructor(rootDir, config = {}) {\n        this.rootDir = rootDir;\n        this.quarantineDir = join(rootDir, '.integrity-quarantine');\n        this.config = {\n            mode: config.mode || 'heuristic',\n            llmModel: config.llmModel || 'grok-2-1212',\n            llmApiKey: config.llmApiKey || process.env.GROK_API_KEY || '',\n            llmBaseURL: config.llmBaseURL || 'https://api.x.ai/v1',\n            watchPatterns: config.watchPatterns || CRITICAL_PATTERNS,\n            baselineFile: config.baselineFile || join(rootDir, '.integrity-baseline.json'),\n            alertsFile: config.alertsFile || join(rootDir, '.integrity-alerts.json'),\n            autoQuarantine: config.autoQuarantine ?? true,\n            autoRestore: config.autoRestore ?? false,\n        };\n        // Initialize LLM client if needed\n        if ((this.config.mode === 'llm' || this.config.mode === 'dual') && this.config.llmApiKey) {\n            this.llmClient = new GrokClient(this.config.llmApiKey, this.config.llmModel, this.config.llmBaseURL);\n        }\n        // Create quarantine directory\n        if (!existsSync(this.quarantineDir)) {\n            mkdirSync(this.quarantineDir, { recursive: true });\n        }\n    }\n    /**\n     * Calculate SHA-256 hash of file\n     */\n    calculateHash(filePath) {\n        try {\n            const content = readFileSync(filePath, 'utf-8');\n            return createHash('sha256').update(content).digest('hex');\n        }\n        catch (error) {\n            console.error(`‚ùå Failed to hash ${filePath}:`, error);\n            return '';\n        }\n    }\n    /**\n     * Create baseline snapshot of all critical files\n     */\n    async createBaseline() {\n        console.log('üì∏ Creating integrity baseline...');\n        const files = await this.findCriticalFiles();\n        for (const file of files) {\n            const absPath = join(this.rootDir, file);\n            const hash = this.calculateHash(absPath);\n            if (hash) {\n                // üîß FIX: Store content for auto-restore (ChatGPT feedback)\n                const content = readFileSync(absPath, 'utf-8');\n                const snapshot = {\n                    path: file,\n                    hash,\n                    size: content.length,\n                    timestamp: Date.now(),\n                    content, // Now content is ALWAYS stored for restore\n                };\n                this.baseline.set(file, snapshot);\n            }\n        }\n        // Save baseline to disk\n        this.saveBaseline();\n        console.log(`‚úÖ Baseline created: ${this.baseline.size} files`);\n    }\n    /**\n     * Find all critical files matching patterns\n     */\n    async findCriticalFiles() {\n        const files = [];\n        for (const pattern of this.config.watchPatterns) {\n            try {\n                const { stdout } = await execAsync(`find ${this.rootDir} -path \"${join(this.rootDir, pattern)}\" -type f`, { maxBuffer: 10 * 1024 * 1024 });\n                const matches = stdout\n                    .split('\\n')\n                    .filter(f => f.trim())\n                    .map(f => relative(this.rootDir, f));\n                files.push(...matches);\n            }\n            catch (error) {\n                // Pattern may not match any files, that's OK\n            }\n        }\n        return [...new Set(files)]; // Remove duplicates\n    }\n    /**\n     * Load baseline from disk\n     */\n    loadBaseline() {\n        if (!existsSync(this.config.baselineFile)) {\n            console.warn('‚ö†Ô∏è  No baseline file found, creating new baseline');\n            return;\n        }\n        try {\n            const data = JSON.parse(readFileSync(this.config.baselineFile, 'utf-8'));\n            this.baseline = new Map(Object.entries(data));\n            // Build hashToFiles mapping for copy detection\n            this.hashToFiles.clear();\n            for (const [path, snapshot] of this.baseline.entries()) {\n                const hash = snapshot.hash;\n                if (!this.hashToFiles.has(hash)) {\n                    this.hashToFiles.set(hash, new Set());\n                }\n                this.hashToFiles.get(hash).add(path);\n            }\n            console.log(`‚úÖ Loaded baseline: ${this.baseline.size} files`);\n            console.log(`‚úÖ Hash tracking: ${this.hashToFiles.size} unique hashes`);\n        }\n        catch (error) {\n            console.error('‚ùå Failed to load baseline:', error);\n        }\n    }\n    /**\n     * Save baseline to disk\n     */\n    saveBaseline() {\n        try {\n            const data = Object.fromEntries(this.baseline);\n            writeFileSync(this.config.baselineFile, JSON.stringify(data, null, 2));\n        }\n        catch (error) {\n            console.error('‚ùå Failed to save baseline:', error);\n        }\n    }\n    /**\n     * Save alerts to disk\n     */\n    saveAlerts() {\n        try {\n            writeFileSync(this.config.alertsFile, JSON.stringify(this.alerts, null, 2));\n        }\n        catch (error) {\n            console.error('‚ùå Failed to save alerts:', error);\n        }\n    }\n    /**\n     * Heuristic analysis: Check for malicious patterns\n     */\n    analyzeHeuristic(filePath, content) {\n        for (const pattern of MALICIOUS_PATTERNS) {\n            if (pattern.test(content)) {\n                return {\n                    timestamp: new Date(),\n                    severity: 'CRITICAL',\n                    file: filePath,\n                    type: 'HEURISTIC_MATCH',\n                    description: `Malicious pattern detected: ${pattern.source}`,\n                    matchedPattern: pattern.source,\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * LLM analysis: Semantic code analysis for malicious intent\n     */\n    async analyzeLLM(filePath, oldContent, newContent) {\n        if (!this.llmClient) {\n            return null;\n        }\n        const prompt = `üîí SECURITY ANALYSIS - Code Modification Detection\n\nYou are a security analyst. Analyze this code diff for MALICIOUS INTENT.\n\nFILE: ${filePath}\n\nTHREAT MODEL:\n- Adversary trying to break GPT-5/o1 response generation\n- Code injection to exfiltrate API keys\n- Introduction of backdoors or infinite loops\n- Sabotage to cause silent failures\n\nSUSPICIOUS PATTERNS TO DETECT:\n${SUSPICIOUS_CHANGES.map((s, i) => `${i + 1}. ${s}`).join('\\n')}\n\nOLD CODE:\n\\`\\`\\`\n${oldContent.substring(0, 5000)}\n\\`\\`\\`\n\nNEW CODE:\n\\`\\`\\`\n${newContent.substring(0, 5000)}\n\\`\\`\\`\n\nANALYSIS REQUIRED:\n1. Is this modification MALICIOUS? (YES/NO)\n2. Severity: CRITICAL/HIGH/MEDIUM/LOW\n3. Type of attack (if malicious)\n4. Explanation (1-2 sentences)\n\nRESPOND IN THIS EXACT FORMAT:\nMALICIOUS: [YES/NO]\nSEVERITY: [CRITICAL/HIGH/MEDIUM/LOW]\nTYPE: [description]\nREASON: [explanation]`;\n        try {\n            const messages = [\n                { role: 'user', content: prompt }\n            ];\n            const response = await this.llmClient.chat(messages, [], undefined, { search_parameters: { mode: 'off' } });\n            const analysis = response.choices[0]?.message?.content || '';\n            // Parse LLM response\n            const isMalicious = /MALICIOUS:\\s*YES/i.test(analysis);\n            if (isMalicious) {\n                const severityMatch = analysis.match(/SEVERITY:\\s*(CRITICAL|HIGH|MEDIUM|LOW)/i);\n                const severity = severityMatch?.[1]?.toUpperCase() || 'HIGH';\n                const typeMatch = analysis.match(/TYPE:\\s*([^\\n]+)/i);\n                const type = typeMatch?.[1] || 'Unknown malicious modification';\n                const reasonMatch = analysis.match(/REASON:\\s*([^\\n]+)/i);\n                const reason = reasonMatch?.[1] || 'LLM detected malicious intent';\n                return {\n                    timestamp: new Date(),\n                    severity,\n                    file: filePath,\n                    type: 'LLM_DETECTED',\n                    description: `${type}: ${reason}`,\n                    llmAnalysis: analysis,\n                };\n            }\n            return null;\n        }\n        catch (error) {\n            console.error(`‚ùå LLM analysis failed for ${filePath}:`, error);\n            return null;\n        }\n    }\n    /**\n     * Handle file change event\n     */\n    async onFileChange(filePath) {\n        const relPath = relative(this.rootDir, filePath);\n        const baseline = this.baseline.get(relPath);\n        if (!baseline) {\n            // New file, add to baseline\n            const hash = this.calculateHash(filePath);\n            if (hash) {\n                // üîß FIX: Store content for auto-restore (ChatGPT feedback)\n                const content = readFileSync(filePath, 'utf-8');\n                this.baseline.set(relPath, {\n                    path: relPath,\n                    hash,\n                    size: content.length,\n                    timestamp: Date.now(),\n                    content, // Store content for restore\n                });\n                // Update hashToFiles mapping for copy detection\n                if (!this.hashToFiles.has(hash)) {\n                    this.hashToFiles.set(hash, new Set());\n                }\n                this.hashToFiles.get(hash).add(relPath);\n                this.saveBaseline();\n            }\n            return;\n        }\n        // Calculate new hash\n        const newHash = this.calculateHash(filePath);\n        if (!newHash) {\n            return;\n        }\n        // üîç CHECK FOR FILE COPY (before hash mismatch check)\n        // If newHash exists for OTHER files, it's a copy!\n        const filesWithSameHash = this.hashToFiles.get(newHash);\n        if (filesWithSameHash && filesWithSameHash.size > 0) {\n            const otherFiles = Array.from(filesWithSameHash).filter(f => f !== relPath);\n            if (otherFiles.length > 0) {\n                const copyAlert = {\n                    timestamp: new Date(),\n                    severity: 'CRITICAL',\n                    file: relPath,\n                    type: 'FILE_COPY',\n                    description: `File appears to be a COPY of ${otherFiles[0]} (identical hash)`,\n                    oldHash: baseline.hash,\n                    newHash,\n                    originalFile: otherFiles[0],\n                };\n                console.error(`\\nüö® CRITICAL: File copy detected!`);\n                console.error(`   File: ${relPath}`);\n                console.error(`   Original: ${otherFiles[0]}`);\n                console.error(`   Hash: ${newHash.substring(0, 12)}...`);\n                console.error(`   EXPLANATION: File was REPLACED by a copy of another file!`);\n                this.alerts.push(copyAlert);\n                this.saveAlerts();\n                if (this.config.autoQuarantine) {\n                    await this.quarantineFile(filePath, copyAlert);\n                }\n                // Update baseline and hash tracking\n                this.baseline.set(relPath, {\n                    path: relPath,\n                    hash: newHash,\n                    size: readFileSync(filePath).length,\n                    timestamp: Date.now(),\n                    content: readFileSync(filePath, 'utf-8'),\n                });\n                this.saveBaseline();\n                // Update hashToFiles mapping\n                if (!filesWithSameHash.has(relPath)) {\n                    filesWithSameHash.add(relPath);\n                }\n                return;\n            }\n        }\n        // Check for hash mismatch\n        if (newHash !== baseline.hash) {\n            console.warn(`\\n‚ö†Ô∏è  INTEGRITY VIOLATION DETECTED: ${relPath}`);\n            console.warn(`   Old hash: ${baseline.hash}`);\n            console.warn(`   New hash: ${newHash}`);\n            const newContent = readFileSync(filePath, 'utf-8');\n            const oldContent = baseline.content || '';\n            // Generate diff\n            let diff = '';\n            try {\n                const { stdout } = await execAsync(`git diff --no-index --unified=3 <(echo \"${oldContent.replace(/\"/g, '\\\\\"')}\") <(echo \"${newContent.replace(/\"/g, '\\\\\"')}\")`, { shell: '/bin/bash', maxBuffer: 10 * 1024 * 1024 });\n                diff = stdout;\n            }\n            catch {\n                // Diff failed, that's OK\n            }\n            // 1Ô∏è‚É£ HEURISTIC ANALYSIS\n            let alert = null;\n            if (this.config.mode === 'heuristic' || this.config.mode === 'dual') {\n                alert = this.analyzeHeuristic(relPath, newContent);\n                if (alert) {\n                    console.error(`\\nüö® CRITICAL: Malicious pattern detected in ${relPath}`);\n                    console.error(`   Pattern: ${alert.matchedPattern}`);\n                }\n            }\n            // 2Ô∏è‚É£ LLM ANALYSIS (if dual mode or heuristic didn't find anything)\n            if ((this.config.mode === 'llm' || (this.config.mode === 'dual' && !alert)) && this.llmClient) {\n                console.log(`üîç Running LLM analysis on ${relPath}...`);\n                const llmAlert = await this.analyzeLLM(relPath, oldContent, newContent);\n                if (llmAlert) {\n                    console.error(`\\nüö® CRITICAL: LLM detected malicious modification in ${relPath}`);\n                    console.error(`   Analysis: ${llmAlert.description}`);\n                    alert = llmAlert;\n                }\n            }\n            // 3Ô∏è‚É£ HASH MISMATCH ALERT (if no malicious pattern found)\n            if (!alert) {\n                alert = {\n                    timestamp: new Date(),\n                    severity: 'HIGH',\n                    file: relPath,\n                    type: 'HASH_MISMATCH',\n                    description: 'File content changed (hash mismatch)',\n                    oldHash: baseline.hash,\n                    newHash,\n                    diff,\n                };\n            }\n            else {\n                // Add diff to existing alert\n                alert.oldHash = baseline.hash;\n                alert.newHash = newHash;\n                alert.diff = diff;\n            }\n            // Save alert\n            this.alerts.push(alert);\n            this.saveAlerts();\n            // 4Ô∏è‚É£ AUTO-QUARANTINE (if malicious and enabled)\n            if (alert.type !== 'HASH_MISMATCH' && this.config.autoQuarantine) {\n                await this.quarantineFile(filePath, alert);\n            }\n            // 5Ô∏è‚É£ NOTIFICATION\n            this.notifyUser(alert);\n        }\n    }\n    /**\n     * Quarantine malicious file\n     */\n    async quarantineFile(filePath, alert) {\n        const timestamp = Date.now();\n        const quarantinePath = join(this.quarantineDir, `${alert.file.replace(/\\//g, '_')}.${timestamp}.quarantine`);\n        try {\n            // Copy malicious file to quarantine\n            const content = readFileSync(filePath, 'utf-8');\n            writeFileSync(quarantinePath, content);\n            // Write alert metadata\n            writeFileSync(`${quarantinePath}.meta.json`, JSON.stringify(alert, null, 2));\n            console.log(`üîí Quarantined: ${filePath} ‚Üí ${quarantinePath}`);\n            // If auto-restore enabled, restore from baseline\n            if (this.config.autoRestore) {\n                const baseline = this.baseline.get(alert.file);\n                if (baseline && baseline.content) {\n                    writeFileSync(filePath, baseline.content);\n                    console.log(`‚úÖ Auto-restored from baseline: ${filePath}`);\n                }\n            }\n        }\n        catch (error) {\n            console.error(`‚ùå Failed to quarantine ${filePath}:`, error);\n        }\n    }\n    /**\n     * Notify user of security alert\n     */\n    notifyUser(alert) {\n        const severityEmoji = {\n            CRITICAL: 'üî¥',\n            HIGH: 'üü†',\n            MEDIUM: 'üü°',\n            LOW: 'üü¢',\n        }[alert.severity];\n        console.error(`\\n${severityEmoji} SECURITY ALERT [${alert.severity}]`);\n        console.error(`   File: ${alert.file}`);\n        console.error(`   Type: ${alert.type}`);\n        console.error(`   Time: ${alert.timestamp.toISOString()}`);\n        console.error(`   Description: ${alert.description}`);\n        if (alert.matchedPattern) {\n            console.error(`   Pattern: ${alert.matchedPattern}`);\n        }\n        if (alert.llmAnalysis) {\n            console.error(`\\n   LLM Analysis:`);\n            console.error(`   ${alert.llmAnalysis.split('\\n').join('\\n   ')}`);\n        }\n        // Play alert sound (if available)\n        try {\n            exec('paplay /usr/share/sounds/freedesktop/stereo/dialog-error.oga');\n        }\n        catch {\n            // Sound not available, that's OK\n        }\n    }\n    /**\n     * Start watching for file changes\n     */\n    async start() {\n        if (this.isRunning) {\n            console.warn('‚ö†Ô∏è  Watcher already running');\n            return;\n        }\n        console.log('\\nüõ°Ô∏è  INTEGRITY WATCHER STARTING...');\n        console.log(`   Mode: ${this.config.mode.toUpperCase()}`);\n        console.log(`   Root: ${this.rootDir}`);\n        console.log(`   Patterns: ${this.config.watchPatterns.length}`);\n        if (this.config.mode === 'llm' || this.config.mode === 'dual') {\n            console.log(`   LLM Model: ${this.config.llmModel}`);\n        }\n        // Load or create baseline\n        if (existsSync(this.config.baselineFile)) {\n            this.loadBaseline();\n        }\n        else {\n            await this.createBaseline();\n        }\n        // Watch for changes\n        const patterns = this.config.watchPatterns.map(p => join(this.rootDir, p));\n        this.watcher = chokidar.watch(patterns, {\n            persistent: true,\n            ignoreInitial: true,\n            awaitWriteFinish: {\n                stabilityThreshold: 500,\n                pollInterval: 100,\n            },\n        });\n        this.watcher.on('change', (path) => {\n            this.onFileChange(path).catch(error => {\n                console.error(`‚ùå Error handling file change for ${path}:`, error);\n            });\n        });\n        this.watcher.on('add', (path) => {\n            console.log(`üìÑ New file detected: ${relative(this.rootDir, path)}`);\n            this.onFileChange(path).catch(error => {\n                console.error(`‚ùå Error handling new file ${path}:`, error);\n            });\n        });\n        this.isRunning = true;\n        console.log('‚úÖ Integrity Watcher is now monitoring for malicious changes...\\n');\n    }\n    /**\n     * Stop watching\n     */\n    async stop() {\n        if (this.watcher) {\n            await this.watcher.close();\n            this.watcher = null;\n        }\n        this.isRunning = false;\n        console.log('\\nüõë Integrity Watcher stopped');\n    }\n    /**\n     * Get all alerts\n     */\n    getAlerts() {\n        return [...this.alerts];\n    }\n    /**\n     * Get critical alerts only\n     */\n    getCriticalAlerts() {\n        return this.alerts.filter(a => a.severity === 'CRITICAL');\n    }\n    /**\n     * Clear alerts\n     */\n    clearAlerts() {\n        this.alerts = [];\n        this.saveAlerts();\n    }\n}\n//# sourceMappingURL=integrity-watcher.js.map"
  },
  "dist/security/llm-guard-cli.js": {
    "path": "dist/security/llm-guard-cli.js",
    "hash": "ab8182aea1b13c88fd92437f413a6225ebc26461085ba51526f0daf81473658c",
    "size": 9007,
    "timestamp": 1764704879304,
    "content": "#!/usr/bin/env node\n/**\n * ü§ñ LLM GUARD CLI - Intelligent Surveillance Interface\n *\n * USAGE:\n *   npm run guard:start                         # Start LLM Guard (love-watching mode)\n *   npm run guard:start -- --llm grok-2-1212    # Specify LLM model\n *   npm run guard:start -- --interval 60000     # Analysis every 60s\n *   npm run guard:logs                          # View logs\n *   npm run guard:stats                         # View statistics\n */\nimport { LLMGuard } from './llm-guard.js';\nimport { existsSync, readFileSync } from 'fs';\nimport { join } from 'path';\nimport { verifySelfIntegrityOrDie } from './self-integrity.js';\n// üõ°Ô∏è SELF-INTEGRITY CHECK (before ANY execution)\n// V√©rifie que les fichiers du watcher n'ont pas √©t√© alt√©r√©s\nawait verifySelfIntegrityOrDie('llm-guard');\n// Parse command-line arguments\nconst args = process.argv.slice(2);\nconst getLLMApiKey = () => {\n    // Check CLI argument\n    const apiKeyIndex = args.indexOf('--apikey');\n    if (apiKeyIndex !== -1 && args[apiKeyIndex + 1]) {\n        return args[apiKeyIndex + 1];\n    }\n    // Check environment variable\n    if (process.env.GROK_API_KEY) {\n        return process.env.GROK_API_KEY;\n    }\n    // Check environment variable (alternative)\n    if (process.env.LLM_GUARD_API_KEY) {\n        return process.env.LLM_GUARD_API_KEY;\n    }\n    throw new Error('No API key provided. Set GROK_API_KEY or LLM_GUARD_API_KEY env var, or use --apikey flag.');\n};\nconst getLLMModel = () => {\n    const modelIndex = args.indexOf('--llm');\n    if (modelIndex !== -1 && args[modelIndex + 1]) {\n        return args[modelIndex + 1];\n    }\n    return process.env.LLM_GUARD_MODEL || 'grok-2-1212';\n};\nconst getAnalysisInterval = () => {\n    const intervalIndex = args.indexOf('--interval');\n    if (intervalIndex !== -1 && args[intervalIndex + 1]) {\n        return parseInt(args[intervalIndex + 1]);\n    }\n    return 30000; // 30s default\n};\nconst getMode = () => {\n    if (args.includes('--active-reviewer')) {\n        return 'active-reviewer';\n    }\n    return 'love-watching'; // Default\n};\nconst showLogs = args.includes('--logs');\nconst showStats = args.includes('--stats');\n// Detect root directory\nconst rootDir = process.cwd();\nconsole.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë  ü§ñ LLM GUARD - Intelligent Surveillance System              ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë  CONCEPT: LLM-powered security guard that watches for        ‚ïë\n‚ïë           suspicious behaviors that signatures can't detect   ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë  DETECTS:                                                     ‚ïë\n‚ïë  ‚úì File replacements (inode changes)                         ‚ïë\n‚ïë  ‚úì File copies (identical content)                           ‚ïë\n‚ïë  ‚úì Mass operations                                           ‚ïë\n‚ïë  ‚úì Suspicious timing                                         ‚ïë\n‚ïë  ‚úì Behavioral patterns                                       ‚ïë\n‚ïë  ‚úì Context-aware anomalies                                   ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);\n// Handle different commands\nif (showLogs) {\n    console.log('üìã Loading LLM Guard logs...');\n    const logsFile = join(rootDir, '.llm-guard-logs.json');\n    if (!existsSync(logsFile)) {\n        console.log('‚úÖ No logs found (guard not run yet)');\n        process.exit(0);\n    }\n    try {\n        const logs = JSON.parse(readFileSync(logsFile, 'utf-8'));\n        console.log(`\\nü§ñ LLM GUARD LOGS (${logs.length} entries)\\n`);\n        // Group by category\n        const categories = {};\n        for (const log of logs) {\n            if (!categories[log.category]) {\n                categories[log.category] = [];\n            }\n            categories[log.category].push(log);\n        }\n        // Show recent logs by category\n        for (const [category, categoryLogs] of Object.entries(categories)) {\n            console.log(`\\nüìÇ ${category.toUpperCase()} (${categoryLogs.length} entries):`);\n            const recent = categoryLogs.slice(-10);\n            for (const log of recent) {\n                const emoji = log.severity === 'critical' ? 'üî¥' :\n                    log.severity === 'warning' ? 'üü°' : 'üü¢';\n                console.log(`  ${emoji} [${log.timestamp}] ${log.message}`);\n                if (log.data && category === 'detection') {\n                    console.log(`     ‚Üí ${JSON.stringify(log.data, null, 2).split('\\n').join('\\n     ')}`);\n                }\n            }\n        }\n    }\n    catch (error) {\n        console.error(`‚ùå Failed to read logs: ${error.message}`);\n        process.exit(1);\n    }\n    process.exit(0);\n}\nif (showStats) {\n    console.log('üìä Loading LLM Guard statistics...');\n    const logsFile = join(rootDir, '.llm-guard-logs.json');\n    if (!existsSync(logsFile)) {\n        console.log('‚úÖ No stats yet (guard not run)');\n        process.exit(0);\n    }\n    try {\n        const logs = JSON.parse(readFileSync(logsFile, 'utf-8'));\n        // Calculate stats from logs\n        const stats = {\n            totalLogs: logs.length,\n            observations: logs.filter((l) => l.category === 'observation').length,\n            detections: logs.filter((l) => l.category === 'detection').length,\n            analyses: logs.filter((l) => l.category === 'analysis').length,\n            alerts: logs.filter((l) => l.category === 'alert').length,\n            critical: logs.filter((l) => l.severity === 'critical').length,\n            warnings: logs.filter((l) => l.severity === 'warning').length,\n        };\n        console.log('\\nüìä LLM GUARD STATISTICS:\\n');\n        console.log(`   Total logs: ${stats.totalLogs}`);\n        console.log(`   Observations: ${stats.observations}`);\n        console.log(`   Detections: ${stats.detections}`);\n        console.log(`   LLM Analyses: ${stats.analyses}`);\n        console.log(`   Alerts: ${stats.alerts}`);\n        console.log(`   Critical: ${stats.critical}`);\n        console.log(`   Warnings: ${stats.warnings}`);\n        console.log('');\n        // Recent detections\n        const recentDetections = logs\n            .filter((l) => l.category === 'detection')\n            .slice(-5);\n        if (recentDetections.length > 0) {\n            console.log('üîç RECENT DETECTIONS:\\n');\n            for (const det of recentDetections) {\n                console.log(`   ${det.message}`);\n                console.log(`   ‚Üí ${det.timestamp}`);\n                console.log('');\n            }\n        }\n    }\n    catch (error) {\n        console.error(`‚ùå Failed to read stats: ${error.message}`);\n        process.exit(1);\n    }\n    process.exit(0);\n}\n// Start LLM Guard\nconsole.log('üöÄ Starting LLM Guard...\\n');\ntry {\n    const apiKey = getLLMApiKey();\n    const model = getLLMModel();\n    const interval = getAnalysisInterval();\n    const mode = getMode();\n    console.log(`   API Key: ${apiKey.substring(0, 10)}...`);\n    console.log(`   LLM Model: ${model}`);\n    console.log(`   Analysis Interval: ${interval}ms (${interval / 1000}s)`);\n    console.log(`   Mode: ${mode}`);\n    console.log(`   Root Directory: ${rootDir}`);\n    console.log('');\n    const config = {\n        llmApiKey: apiKey,\n        llmModel: model,\n        analysisInterval: interval,\n        mode,\n    };\n    const guard = new LLMGuard(rootDir, config);\n    // Start guard\n    guard.start().catch(error => {\n        console.error(`‚ùå Failed to start LLM Guard: ${error.message}`);\n        process.exit(1);\n    });\n    // Handle graceful shutdown\n    process.on('SIGINT', async () => {\n        console.log('\\n\\nüõë Shutting down LLM Guard...');\n        await guard.stop();\n        const stats = guard.getStatistics();\n        console.log('\\nüìä SESSION STATISTICS:');\n        console.log(`   Events observed: ${stats.eventsObserved}`);\n        console.log(`   Files replaced: ${stats.filesReplaced}`);\n        console.log(`   Files copied: ${stats.filesCopied}`);\n        console.log(`   LLM analyses: ${stats.llmAnalyses}`);\n        console.log(`   Alerts generated: ${stats.alertsGenerated}`);\n        console.log('');\n        console.log('üíæ Logs saved to: .llm-guard-logs.json');\n        console.log('üìñ View logs: npm run guard:logs');\n        console.log('üìä View stats: npm run guard:stats');\n        console.log('');\n        process.exit(0);\n    });\n    process.on('SIGTERM', async () => {\n        await guard.stop();\n        process.exit(0);\n    });\n    // Keep process alive\n    console.log('Press Ctrl+C to stop\\n');\n    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n');\n}\ncatch (error) {\n    console.error(`‚ùå Error: ${error.message}`);\n    console.error('\\nUSAGE:');\n    console.error('  export GROK_API_KEY=\"your-api-key\"');\n    console.error('  npm run guard:start');\n    console.error('\\nOR:');\n    console.error('  npm run guard:start -- --apikey your-key --llm grok-2-1212 --interval 60000');\n    console.error('');\n    process.exit(1);\n}\n//# sourceMappingURL=llm-guard-cli.js.map"
  },
  "dist/agent/grok-agent.js": {
    "path": "dist/agent/grok-agent.js",
    "hash": "35957b32c5cef77de1e39316f3ddcbf03ea4515a826d888cb943c2430c4548ed",
    "size": 65089,
    "timestamp": 1764704879304,
    "content": "import { GrokClient } from \"../grok/client.js\";\nimport { getAllGrokTools, getMCPManager, initializeMCPServers, } from \"../grok/tools.js\";\nimport { loadMCPConfig } from \"../mcp/config.js\";\nimport { TextEditorTool, MorphEditorTool, BashTool, TodoTool, ConfirmationTool, SearchTool, } from \"../tools/index.js\";\nimport { EventEmitter } from \"events\";\nimport { createTokenCounter } from \"../utils/token-counter.js\";\nimport { loadCustomInstructions } from \"../utils/custom-instructions.js\";\nimport { getSettingsManager } from \"../utils/settings-manager.js\";\nimport { appendChatEntry, saveState, sessionManager } from \"../utils/session-manager-sqlite.js\";\nimport { providerManager } from \"../utils/provider-manager.js\";\nimport { debugLog } from \"../utils/debug-logger.js\";\nimport { getLLMHook } from \"../timeline/hooks/llm-hook.js\";\nimport { getToolHook } from \"../timeline/hooks/tool-hook.js\";\nimport { executionManager } from \"../execution/index.js\";\nexport class GrokAgent extends EventEmitter {\n    grokClient;\n    textEditor;\n    morphEditor;\n    bash;\n    todoTool;\n    confirmationTool;\n    search;\n    applyPatch;\n    chatHistory = [];\n    messages = [];\n    tokenCounter;\n    abortController = null;\n    mcpInitialized = false;\n    maxToolRounds;\n    persistSession = true;\n    autoRestoreSession = true;\n    llmHook = getLLMHook();\n    toolHook = getToolHook();\n    currentExecutionStream = null;\n    constructor(apiKey, baseURL, model, maxToolRounds) {\n        super();\n        const manager = getSettingsManager();\n        const savedModel = manager.getCurrentModel();\n        const modelToUse = model || savedModel || \"grok-code-fast-1\";\n        this.maxToolRounds = maxToolRounds || 400;\n        this.grokClient = new GrokClient(apiKey, modelToUse, baseURL);\n        this.textEditor = new TextEditorTool();\n        this.morphEditor = process.env.MORPH_API_KEY ? new MorphEditorTool() : null;\n        this.bash = new BashTool();\n        this.todoTool = new TodoTool();\n        this.confirmationTool = new ConfirmationTool();\n        this.search = new SearchTool();\n        this.tokenCounter = createTokenCounter(modelToUse);\n        // applyPatch tool will be lazily imported on first use\n        // Load project persistence settings\n        try {\n            const projectPersist = manager.getProjectSetting(\"persistSession\");\n            const projectAutoRestore = manager.getProjectSetting(\"autoRestoreSession\");\n            this.persistSession = projectPersist !== undefined ? !!projectPersist : true;\n            this.autoRestoreSession = projectAutoRestore !== undefined ? !!projectAutoRestore : true;\n        }\n        catch { }\n        // Initialize SQLite session for current workdir\n        // Detect provider from baseURL\n        let provider = 'grok';\n        if (baseURL) {\n            if (baseURL.includes('anthropic'))\n                provider = 'claude';\n            else if (baseURL.includes('openai'))\n                provider = 'openai';\n            else if (baseURL.includes('mistral'))\n                provider = 'mistral';\n            else if (baseURL.includes('deepseek'))\n                provider = 'deepseek';\n            else if (baseURL.includes('x.ai'))\n                provider = 'grok';\n        }\n        sessionManager.initSession(process.cwd(), provider, modelToUse, apiKey);\n        // Initialize MCP servers if configured\n        this.initializeMCP();\n        // Initialize with system message (will be updated on model switch)\n        this.updateSystemMessage();\n    }\n    /**\n     * Update system message with current model name\n     * Called during initialization and when switching models\n     */\n    updateSystemMessage() {\n        const customInstructions = loadCustomInstructions();\n        const customInstructionsSection = customInstructions\n            ? `\\n\\nCUSTOM INSTRUCTIONS:\\n${customInstructions}\\n\\nThe above custom instructions should be followed alongside the standard instructions below.`\n            : \"\";\n        const currentModel = this.grokClient.getCurrentModel();\n        const systemMessage = {\n            role: \"system\",\n            content: `You are ${currentModel}, a WORLD CLASS AI COLLABORATOR that helps with file editing, coding tasks, and system operations.${customInstructionsSection}\n\nYou have access to these tools:\n- view_file: View file contents or directory listings\n- create_file: Create new files with content (ONLY use this for files that don't exist yet)\n- str_replace_editor: Replace text in existing files (ALWAYS use this to edit or update existing files)${this.morphEditor\n                ? \"\\n- edit_file: High-speed file editing with Morph Fast Apply (4,500+ tokens/sec with 98% accuracy)\"\n                : \"\"}\n- bash: Execute bash commands (use for searching, file discovery, navigation, and system operations)\n- search: Unified search tool for finding text content or files (similar to Cursor's search functionality)\n- create_todo_list: Create a visual todo list for planning and tracking tasks\n- update_todo_list: Update existing todos in your todo list\n- get_my_identity: Get factual information about your own model identity and configuration\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüå≥ CONVERSATION SESSION MANAGEMENT (Git-like)\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nYou have powerful tools for managing conversation sessions like Git branches:\n\n**session_list:** List all conversation sessions with details (ID, directory, model, messages, dates)\n  - Use this to see available sessions before switching\n  - Shows current session and session metadata\n\n**session_switch:** Switch to a different conversation session\n  - Changes working directory AND loads conversation history\n  - **CRITICAL: ALWAYS ask user permission BEFORE calling this tool**\n  - Explain what will happen: \"I will switch to Session #X in directory ~/foo and load Y messages. Approve?\"\n  - Wait for explicit user confirmation (\"yes\", \"ok\", \"go ahead\", etc.)\n  - NEVER call without permission\n\n**session_new:** Create a new conversation session (branching)\n  - Can create in DIFFERENT directory\n  - Can import history from ANY session (not just current)\n  - Can filter messages by DATE RANGE (time travel!)\n  - Example: Create new session with only messages from Nov 1-3\n  - **Ask permission if creating in NEW directory or importing filtered history**\n\n**session_rewind:** Git rewind - synchronize conversation + code to specific date\n  - **MOST POWERFUL operation**\n  - Creates new directory with CODE at specific Git commit + CONVERSATION at that date\n  - **ALWAYS explain FULL plan and get EXPLICIT permission**\n  - Example permission request:\n    \"I will perform Git rewind to Nov 3:\n     1. Create ~/rewind-nov-03/\n     2. Extract Git repository at Nov 3 commit (40 files)\n     3. Import conversation messages from Nov 1-3 (25 messages)\n     4. Create Git branch rewind-2025-11-03\n     Approve this operation?\"\n  - NEVER call without detailed explanation + approval\n\n**Permission Rules:**\n- session_list: No permission needed (read-only)\n- session_switch: ALWAYS ask permission\n- session_new: Ask if creating new directory or filtering\n- session_rewind: ALWAYS explain full plan + get approval\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîß GIT VERSION CONTROL\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n**You already know Git.** Use the bash tool for all Git operations:\n- git status, git add, git commit, git push, git branch, etc.\n- NO special Git tools needed - use bash directly as you normally would\n- Commit after file changes: git commit -m \"feat: description\"\n- Push regularly: git push origin <branch>\n\n**BASH COMMAND BEST PRACTICES:**\n- NEVER use stderr redirection (2>&1) in bash commands\n- Stdout and stderr are captured separately for better debugging\n- Stderr is displayed in red in the Execution Viewer\n- Exit codes are tracked automatically\n- Examples:\n  ‚úÖ GOOD: git status\n  ‚úÖ GOOD: npm test\n  ‚ùå BAD: git status 2>&1\n  ‚ùå BAD: npm test 2>&1\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nREAL-TIME INFORMATION:\nYou have access to real-time web search and X (Twitter) data. When users ask for current information, latest news, or recent events, you automatically have access to up-to-date information from the web and social media.\n\n‚ö†Ô∏è IDENTITY VERIFICATION:\nIf you ever have any doubt about your model identity or which provider you are, use the 'get_my_identity' tool.\nThis will give you FACTUAL information about who you actually are, based on your current runtime configuration,\nNOT based on conversation history. This is especially important if you notice inconsistencies in the conversation\nor after a model switch.\n\nIMPORTANT TOOL USAGE RULES:\n- NEVER use create_file on files that already exist - this will overwrite them completely\n- ALWAYS use str_replace_editor to modify existing files, even for small changes\n- Before editing a file, use view_file to see its current contents\n- Use create_file ONLY when creating entirely new files that don't exist\n\nSEARCHING AND EXPLORATION:\n- Use search for fast, powerful text search across files or finding files by name (unified search tool)\n- Examples: search for text content like \"import.*react\", search for files like \"component.tsx\"\n- Use bash with commands like 'find', 'grep', 'rg', 'ls' for complex file operations and navigation\n- view_file is best for reading specific files you already know exist\n\nWhen a user asks you to edit, update, modify, or change an existing file:\n1. First use view_file to see the current contents\n2. Then use str_replace_editor to make the specific changes\n3. Never use create_file for existing files\n\nWhen a user asks you to create a new file that doesn't exist:\n1. Use create_file with the full content\n\nTASK PLANNING WITH TODO LISTS:\n- For complex requests with multiple steps (multi-file edits, multi-command workflows, time machine operations, etc.), ALWAYS write an implementation plan in markdown as a concise TODO LIST (checkboxes) instead of long \"Plan / Ex√©cution / R√©sultat\" sections\n- For simple, single-step questions (like short clarifications, greetings, or identity questions such as \\\"√† qui ai-je l'honneur ?\\\"), you MUST answer directly and naturally, WITHOUT showing a formal plan or todo list\n- Prefer a single todo checklist that you keep up to date (this checklist tient lieu de plan ET de suivi d'ex√©cution). Do NOT repeat the same plan in multiple forms (no \\\"Plan:\\\" section + duplicate bullets).\n- Use create_todo_list to break down tasks into manageable items with priorities, rendered as checkboxes\n- Mark tasks as 'in_progress' when you start working on them (only one at a time)\n- Mark tasks as 'completed' immediately when finished\n- Use update_todo_list to track your progress throughout the task\n- Todo lists provide visual feedback with colors: ‚úÖ Green (completed), üîÑ Cyan (in progress), ‚è≥ Yellow (pending)\n- Always create todos with priorities: 'high' (üî¥), 'medium' (üü°), 'low' (üü¢)\n\nUSER CONFIRMATION SYSTEM:\nFile operations (create_file, str_replace_editor) and bash commands will automatically request user confirmation before execution. The confirmation system will show users the actual content or command before they decide. Users can choose to approve individual operations or approve all operations of that type for the session.\n\nIf a user rejects an operation, the tool will return an error and you should not proceed with that specific operation.\n\nBe helpful, direct, smart, intelligent and efficient. Always look at the WHOLE CONTEXT before providing solutions or making edits and act THOROUGHLY, DEEP DIVE in order to understand the subtleties. EXPLAIN what you're doing WITHOUT HIDING ANYTHING, TELL the CHALLENGES you faced, the ERRORS you met and the SOLUTIONS YOU FOUND, and SHOW THE RESULTS.\n\nRESPONSE GUIDELINES (MANDATORY):\n- After using tools (view_file, bash, search, timeline, etc.), you MUST provide a comprehensive response that includes:\n  * What you did and which tools you used\n  * Your findings, analysis, and results\n  * Clear conclusions, recommendations, or next steps\n- For complex multi-step tasks, you MAY use create_todo_list to track progress\n- For simple questions (greetings, clarifications, identity), answer directly and naturally\n- IMPORTANT: Always conclude your response with actionable insights and complete explanations\n- CRITICAL: Never end with just \"Using tools to help you...\" without providing your analysis - always follow up with your findings and conclusions\n\nIMPORTANT RESPONSE GUIDELINES:\n- After using tools, do NOT respond with pleasantries like \"Thanks for...\" or \"Great!\"\n- Only provide necessary explanations or next steps if relevant to the task\n- Keep responses complete and focused on the actual work being done\n- If a tool execution completes the user's request, confirm and give a complete explanation of what have been done, then summarize the findings\n\nCurrent working directory: ${process.cwd()}`,\n        };\n        // ‚úÖ PURGE ALL old system messages (critical when switching models)\n        // Remove all existing system messages to avoid confusion\n        const oldSystemCount = this.messages.filter(m => m.role === 'system').length;\n        debugLog.log(`üóëÔ∏è  BEFORE purge: ${oldSystemCount} system message(s), total: ${this.messages.length} messages`);\n        this.messages = this.messages.filter(m => m.role !== 'system');\n        debugLog.log(`üóëÔ∏è  AFTER purge: ${this.messages.length} messages remaining (no system)`);\n        // Add the new system message at the beginning\n        this.messages.unshift(systemMessage);\n        const newSystemCount = this.messages.filter(m => m.role === 'system').length;\n        debugLog.log(`‚úÖ System message added: model=\"${currentModel}\", now ${newSystemCount} system message(s), total: ${this.messages.length} messages`);\n    }\n    async persist(entry) {\n        if (!this.persistSession)\n            return;\n        try {\n            await appendChatEntry(entry);\n        }\n        catch { }\n    }\n    /**\n     * Restore message context from previously saved chat history\n     */\n    restoreFromHistory(entries) {\n        if (!entries || entries.length === 0)\n            return;\n        for (const entry of entries) {\n            try {\n                if (entry.type === \"user\") {\n                    this.messages.push({ role: \"user\", content: entry.content });\n                }\n                else if (entry.type === \"assistant\") {\n                    this.messages.push({\n                        role: \"assistant\",\n                        content: entry.content,\n                        tool_calls: entry.toolCalls,\n                    });\n                }\n                else if (entry.type === \"tool_result\" && entry.toolCall) {\n                    // ‚úÖ For Mistral: include \"name\" field (required by their API)\n                    const toolMessage = {\n                        role: \"tool\",\n                        content: entry.content,\n                        tool_call_id: entry.toolCall.id,\n                    };\n                    // Add \"name\" field for Mistral (required by their API spec)\n                    const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n                    if (currentProvider === 'mistral') {\n                        toolMessage.name = entry.toolCall.function?.name || 'unknown';\n                    }\n                    this.messages.push(toolMessage);\n                }\n            }\n            catch { }\n        }\n    }\n    async initializeMCP() {\n        // Initialize MCP in the background without blocking\n        Promise.resolve().then(async () => {\n            try {\n                const config = loadMCPConfig();\n                if (config.servers.length > 0) {\n                    await initializeMCPServers();\n                }\n            }\n            catch (error) {\n                console.warn(\"MCP initialization failed:\", error);\n            }\n            finally {\n                this.mcpInitialized = true;\n            }\n        });\n    }\n    isGrokModel() {\n        const currentModel = this.grokClient.getCurrentModel();\n        return currentModel.toLowerCase().includes(\"grok\");\n    }\n    // Heuristic: enable web search only when likely needed\n    shouldUseSearchFor(message) {\n        const q = message.toLowerCase();\n        const keywords = [\n            \"today\",\n            \"latest\",\n            \"news\",\n            \"trending\",\n            \"breaking\",\n            \"current\",\n            \"now\",\n            \"recent\",\n            \"x.com\",\n            \"twitter\",\n            \"tweet\",\n            \"what happened\",\n            \"as of\",\n            \"update on\",\n            \"release notes\",\n            \"changelog\",\n            \"price\",\n        ];\n        if (keywords.some((k) => q.includes(k)))\n            return true;\n        // crude date pattern (e.g., 2024/2025) may imply recency\n        if (/(20\\d{2})/.test(q))\n            return true;\n        return false;\n    }\n    buildSummaryPrompt(lastUserMessage) {\n        return [\n            \"Tu as peut-√™tre utilis√© des outils (lecture de fichiers, commandes bash, timeline, etc.)\",\n            \"pour r√©pondre √† la DERNI√àRE question de l‚Äôutilisateur.\",\n            \"\",\n            `Derni√®re question de l‚Äôutilisateur : \"${lastUserMessage}\"`,\n            \"\",\n            \"Maintenant, r√©dige une r√©ponse NATURELLE en fran√ßais qui :\",\n            \"- Explique ce que tu as fait (y compris les outils utilis√©s le cas √©ch√©ant).\",\n            \"- Pr√©sente les principaux r√©sultats et conclusions.\",\n            \"- Mentionne les difficult√©s √©ventuelles et comment tu les as r√©solues.\",\n            \"- Termine par un r√©sum√© qui met clairement en √©vidence tous les points importants de ce que tu as fait et trouv√© (longueur libre mais suffisamment exhaustive pour que l‚Äôutilisateur comprenne bien l‚Äôensemble).\",\n            \"\",\n            \"CONTRAINTES IMPORTANTES :\",\n            \"- Ne propose PAS de nouveaux tools dans cette r√©ponse.\",\n            \"- Ne repose PAS la question √† l‚Äôutilisateur.\",\n            \"- Ne commence PAS par \\\"Plan:\\\" ou par une section de plan; ne r√©p√®te PAS ton plan dans plusieurs blocs.\",\n            \"- Contente-toi d‚Äôexpliquer ce que tu as fait et ce que tu as appris.\"\n        ].join(\"\\n\");\n    }\n    async generateAndAppendSummary(lastUserMessage) {\n        try {\n            const prompt = this.buildSummaryPrompt(lastUserMessage);\n            const summaryMessages = [\n                ...this.messages,\n                { role: \"user\", content: prompt }\n            ];\n            const response = await this.grokClient.chat(summaryMessages, [], undefined, { search_parameters: { mode: \"off\" } });\n            const content = response.choices?.[0]?.message?.content?.trim();\n            if (!content) {\n                return null;\n            }\n            const entry = {\n                type: \"assistant\",\n                content,\n                timestamp: new Date(),\n            };\n            this.chatHistory.push(entry);\n            await this.persist(entry);\n            return entry;\n        }\n        catch (error) {\n            debugLog.log(\"‚ö†Ô∏è  Summary phase failed:\", error?.message || String(error));\n            return null;\n        }\n    }\n    async processUserMessage(message) {\n        // Add user message to conversation\n        const userEntry = {\n            type: \"user\",\n            content: message,\n            timestamp: new Date(),\n        };\n        this.chatHistory.push(userEntry);\n        await this.persist(userEntry);\n        this.messages.push({ role: \"user\", content: message });\n        // üïê Timeline: Capture user message\n        try {\n            const session = sessionManager.getCurrentSession();\n            if (session) {\n                await this.llmHook.captureUserMessage(message, session.id, this.grokClient.getCurrentModel(), providerManager.detectProvider(this.grokClient.getCurrentModel()));\n            }\n        }\n        catch (error) {\n            // Don't fail the request if timeline logging fails\n            debugLog.log('‚ö†Ô∏è  Timeline logging failed for user message:', error);\n        }\n        const newEntries = [userEntry];\n        const maxToolRounds = this.maxToolRounds; // Prevent infinite loops\n        let toolRounds = 0;\n        let hadToolCalls = false;\n        let finalAssistantContent = \"\";\n        try {\n            const tools = await getAllGrokTools();\n            let currentResponse = await this.grokClient.chat(this.messages, tools, undefined, this.isGrokModel() && this.shouldUseSearchFor(message)\n                ? { search_parameters: { mode: \"auto\" } }\n                : { search_parameters: { mode: \"off\" } });\n            // Agent loop - continue until no more tool calls or max rounds reached\n            while (toolRounds < maxToolRounds) {\n                const assistantMessage = currentResponse.choices[0]?.message;\n                if (!assistantMessage) {\n                    throw new Error(\"No response from Grok\");\n                }\n                // Handle tool calls\n                if (assistantMessage.tool_calls &&\n                    assistantMessage.tool_calls.length > 0) {\n                    toolRounds++;\n                    hadToolCalls = true;\n                    // Add assistant message with tool calls\n                    const assistantEntry = {\n                        type: \"assistant\",\n                        content: assistantMessage.content || \"Using tools to help you...\",\n                        timestamp: new Date(),\n                        toolCalls: assistantMessage.tool_calls,\n                    };\n                    this.chatHistory.push(assistantEntry);\n                    await this.persist(assistantEntry);\n                    newEntries.push(assistantEntry);\n                    // Add assistant message to conversation\n                    this.messages.push({\n                        role: \"assistant\",\n                        content: assistantMessage.content || \"\",\n                        tool_calls: assistantMessage.tool_calls,\n                    });\n                    // Create initial tool call entries to show tools are being executed\n                    assistantMessage.tool_calls.forEach((toolCall) => {\n                        const toolCallEntry = {\n                            type: \"tool_call\",\n                            content: \"Executing...\",\n                            timestamp: new Date(),\n                            toolCall: toolCall,\n                        };\n                        this.chatHistory.push(toolCallEntry);\n                        newEntries.push(toolCallEntry);\n                    });\n                    // Execute tool calls and update the entries\n                    for (const toolCall of assistantMessage.tool_calls) {\n                        const result = await this.executeTool(toolCall);\n                        // Update the existing tool_call entry with the result\n                        const entryIndex = this.chatHistory.findIndex((entry) => entry.type === \"tool_call\" && entry.toolCall?.id === toolCall.id);\n                        if (entryIndex !== -1) {\n                            const updatedEntry = {\n                                ...this.chatHistory[entryIndex],\n                                type: \"tool_result\",\n                                content: result.success\n                                    ? result.output || \"Success\"\n                                    : result.error || \"Error occurred\",\n                                toolResult: result,\n                            };\n                            this.chatHistory[entryIndex] = updatedEntry;\n                            await this.persist(updatedEntry);\n                            // Also update in newEntries for return value\n                            const newEntryIndex = newEntries.findIndex((entry) => entry.type === \"tool_call\" &&\n                                entry.toolCall?.id === toolCall.id);\n                            if (newEntryIndex !== -1) {\n                                newEntries[newEntryIndex] = updatedEntry;\n                            }\n                        }\n                        // Add tool result to messages with proper format (needed for AI context)\n                        // ‚úÖ For Mistral: include \"name\" field (required by their API)\n                        const toolMessage = {\n                            role: \"tool\",\n                            content: result.success\n                                ? result.output || \"Success\"\n                                : result.error || \"Error\",\n                            tool_call_id: toolCall.id,\n                        };\n                        // Add \"name\" field for Mistral (required by their API spec)\n                        const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n                        if (currentProvider === 'mistral') {\n                            toolMessage.name = toolCall.function.name;\n                        }\n                        this.messages.push(toolMessage);\n                    }\n                    // Get next response - this might contain more tool calls\n                    currentResponse = await this.grokClient.chat(this.messages, tools, undefined, this.isGrokModel() && this.shouldUseSearchFor(message)\n                        ? { search_parameters: { mode: \"auto\" } }\n                        : { search_parameters: { mode: \"off\" } });\n                }\n                else {\n                    // No more tool calls, add final response\n                    const finalEntry = {\n                        type: \"assistant\",\n                        content: assistantMessage.content ||\n                            \"I understand, but I don't have a specific response.\",\n                        timestamp: new Date(),\n                    };\n                    finalAssistantContent = assistantMessage.content || \"\";\n                    this.chatHistory.push(finalEntry);\n                    await this.persist(finalEntry);\n                    this.messages.push({\n                        role: \"assistant\",\n                        content: assistantMessage.content || \"\",\n                    });\n                    newEntries.push(finalEntry);\n                    // üïê Timeline: Capture assistant message\n                    try {\n                        const session = sessionManager.getCurrentSession();\n                        if (session) {\n                            await this.llmHook.captureAssistantMessage(assistantMessage.content || \"\", session.id, this.grokClient.getCurrentModel(), providerManager.detectProvider(this.grokClient.getCurrentModel()));\n                        }\n                    }\n                    catch (error) {\n                        debugLog.log('‚ö†Ô∏è  Timeline logging failed for assistant message:', error);\n                    }\n                    break; // Exit the loop\n                }\n            }\n            if (toolRounds >= maxToolRounds) {\n                const warningEntry = {\n                    type: \"assistant\",\n                    content: \"Maximum tool execution rounds reached. Stopping to prevent infinite loops.\",\n                    timestamp: new Date(),\n                };\n                this.chatHistory.push(warningEntry);\n                await this.persist(warningEntry);\n                newEntries.push(warningEntry);\n            }\n            if (hadToolCalls) {\n                const contentTrimmed = finalAssistantContent.trim();\n                // Skip synth√®se pour le placeholder par d√©faut (GPT-5/o1)\n                if (contentTrimmed === \"Using tools to help you...\") {\n                    debugLog.log(\"‚è≠Ô∏è  Skipping summary (placeholder message, waiting for streaming completion)\");\n                    return newEntries;\n                }\n                // G√©n√©rer synth√®se si :\n                // - R√©ponse vide\n                // - R√©ponse trop courte (< 150 caract√®res)\n                const needsSummary = !contentTrimmed ||\n                    contentTrimmed.length < 150;\n                if (needsSummary) {\n                    debugLog.log(\"‚ö†Ô∏è  Generating summary (insufficient LLM response detected)\");\n                    const summaryEntry = await this.generateAndAppendSummary(message);\n                    if (summaryEntry) {\n                        newEntries.push(summaryEntry);\n                    }\n                }\n                else {\n                    debugLog.log(\"‚úÖ LLM provided sufficient response, skipping summary\");\n                }\n            }\n            return newEntries;\n        }\n        catch (error) {\n            const errorEntry = {\n                type: \"assistant\",\n                content: `Sorry, I encountered an error: ${error.message}`,\n                timestamp: new Date(),\n            };\n            this.chatHistory.push(errorEntry);\n            await this.persist(errorEntry);\n            newEntries.push(errorEntry);\n            // üïê Timeline: Capture LLM error\n            try {\n                const session = sessionManager.getCurrentSession();\n                if (session) {\n                    await this.llmHook.captureError(error, session.id, this.grokClient.getCurrentModel(), providerManager.detectProvider(this.grokClient.getCurrentModel()));\n                }\n            }\n            catch (timelineError) {\n                debugLog.log('‚ö†Ô∏è  Timeline logging failed for LLM error:', timelineError);\n            }\n            return newEntries;\n        }\n    }\n    messageReducer(previous, item) {\n        const reduce = (acc, delta) => {\n            acc = { ...acc };\n            for (const [key, value] of Object.entries(delta)) {\n                if (acc[key] === undefined || acc[key] === null) {\n                    acc[key] = value;\n                    // Clean up index properties from tool calls\n                    if (Array.isArray(acc[key])) {\n                        for (const arr of acc[key]) {\n                            delete arr.index;\n                        }\n                    }\n                }\n                else if (typeof acc[key] === \"string\" && typeof value === \"string\") {\n                    acc[key] += value;\n                }\n                else if (Array.isArray(acc[key]) && Array.isArray(value)) {\n                    const accArray = acc[key];\n                    for (let i = 0; i < value.length; i++) {\n                        if (!accArray[i])\n                            accArray[i] = {};\n                        accArray[i] = reduce(accArray[i], value[i]);\n                    }\n                }\n                else if (typeof acc[key] === \"object\" && typeof value === \"object\") {\n                    acc[key] = reduce(acc[key], value);\n                }\n            }\n            return acc;\n        };\n        return reduce(previous, item.choices[0]?.delta || {});\n    }\n    async *processUserMessageStream(message) {\n        // Create new abort controller for this request\n        this.abortController = new AbortController();\n        // Add user message to conversation\n        const userEntry = {\n            type: \"user\",\n            content: message,\n            timestamp: new Date(),\n        };\n        this.chatHistory.push(userEntry);\n        await this.persist(userEntry);\n        this.messages.push({ role: \"user\", content: message });\n        // Calculate input tokens\n        let inputTokens = this.tokenCounter.countMessageTokens(this.messages);\n        yield {\n            type: \"token_count\",\n            tokenCount: inputTokens,\n        };\n        const maxToolRounds = this.maxToolRounds; // Prevent infinite loops\n        let toolRounds = 0;\n        let totalOutputTokens = 0;\n        let lastTokenUpdate = 0;\n        let hadToolCalls = false;\n        let finalAssistantContent = \"\";\n        try {\n            // Agent loop - continue until no more tool calls or max rounds reached\n            while (toolRounds < maxToolRounds) {\n                // Check if operation was cancelled\n                if (this.abortController?.signal.aborted) {\n                    yield {\n                        type: \"content\",\n                        content: \"\\n\\n[Operation cancelled by user]\",\n                    };\n                    yield { type: \"done\" };\n                    return;\n                }\n                // Stream response and accumulate\n                const tools = await getAllGrokTools();\n                const stream = this.grokClient.chatStream(this.messages, tools, undefined, this.isGrokModel() && this.shouldUseSearchFor(message)\n                    ? { search_parameters: { mode: \"auto\" } }\n                    : { search_parameters: { mode: \"off\" } });\n                let accumulatedMessage = {};\n                let accumulatedContent = \"\";\n                let bufferedContent = \"\";\n                let lastContentFlush = 0;\n                let toolCallsYielded = false;\n                for await (const chunk of stream) {\n                    // Check for cancellation in the streaming loop\n                    if (this.abortController?.signal.aborted) {\n                        yield {\n                            type: \"content\",\n                            content: \"\\n\\n[Operation cancelled by user]\",\n                        };\n                        yield { type: \"done\" };\n                        return;\n                    }\n                    if (!chunk.choices?.[0])\n                        continue;\n                    // Accumulate the message using reducer\n                    accumulatedMessage = this.messageReducer(accumulatedMessage, chunk);\n                    // Check for tool calls - yield when we have complete tool calls with function names\n                    if (!toolCallsYielded && accumulatedMessage.tool_calls?.length > 0) {\n                        hadToolCalls = true;\n                        // Check if we have at least one complete tool call with a function name\n                        const hasCompleteTool = accumulatedMessage.tool_calls.some((tc) => tc.function?.name);\n                        if (hasCompleteTool) {\n                            yield {\n                                type: \"tool_calls\",\n                                toolCalls: accumulatedMessage.tool_calls,\n                            };\n                            toolCallsYielded = true;\n                        }\n                    }\n                    // Stream content as it comes (buffered to reduce flicker)\n                    if (chunk.choices[0].delta?.content) {\n                        const deltaText = chunk.choices[0].delta.content;\n                        bufferedContent += deltaText;\n                        const now = Date.now();\n                        if (now - lastContentFlush > 500 || bufferedContent.length > 2000) {\n                            // Flush buffered content in batches\n                            yield { type: \"content\", content: bufferedContent };\n                            accumulatedContent += bufferedContent;\n                            bufferedContent = \"\";\n                            lastContentFlush = now;\n                            // Update token count in real-time including accumulated content and any tool calls\n                            const currentOutputTokens = this.tokenCounter.estimateStreamingTokens(accumulatedContent) +\n                                (accumulatedMessage.tool_calls\n                                    ? this.tokenCounter.countTokens(JSON.stringify(accumulatedMessage.tool_calls))\n                                    : 0);\n                            totalOutputTokens = currentOutputTokens;\n                            // Emit token count update (throttled)\n                            if (now - lastTokenUpdate > 2500) {\n                                lastTokenUpdate = now;\n                                yield {\n                                    type: \"token_count\",\n                                    tokenCount: inputTokens + totalOutputTokens,\n                                };\n                            }\n                        }\n                    }\n                }\n                // Final content flush after stream completes\n                if (bufferedContent) {\n                    yield { type: \"content\", content: bufferedContent };\n                    accumulatedContent += bufferedContent;\n                    bufferedContent = \"\";\n                }\n                // Add assistant entry to history\n                const assistantEntry = {\n                    type: \"assistant\",\n                    content: accumulatedMessage.content || \"Using tools to help you...\",\n                    timestamp: new Date(),\n                    toolCalls: accumulatedMessage.tool_calls || undefined,\n                };\n                finalAssistantContent = accumulatedMessage.content || \"\";\n                this.chatHistory.push(assistantEntry);\n                await this.persist(assistantEntry);\n                // Add accumulated message to conversation\n                this.messages.push({\n                    role: \"assistant\",\n                    content: accumulatedMessage.content || \"\",\n                    tool_calls: accumulatedMessage.tool_calls,\n                });\n                // Handle tool calls if present\n                if (accumulatedMessage.tool_calls?.length > 0) {\n                    toolRounds++;\n                    // Only yield tool_calls if we haven't already yielded them during streaming\n                    if (!toolCallsYielded) {\n                        yield {\n                            type: \"tool_calls\",\n                            toolCalls: accumulatedMessage.tool_calls,\n                        };\n                    }\n                    // Execute tools\n                    for (const toolCall of accumulatedMessage.tool_calls) {\n                        // Check for cancellation before executing each tool\n                        if (this.abortController?.signal.aborted) {\n                            yield {\n                                type: \"content\",\n                                content: \"\\n\\n[Operation cancelled by user]\",\n                            };\n                            yield { type: \"done\" };\n                            return;\n                        }\n                        const result = await this.executeTool(toolCall);\n                        const toolResultEntry = {\n                            type: \"tool_result\",\n                            content: result.success\n                                ? result.output || \"Success\"\n                                : result.error || \"Error occurred\",\n                            timestamp: new Date(),\n                            toolCall: toolCall,\n                            toolResult: result,\n                        };\n                        this.chatHistory.push(toolResultEntry);\n                        await this.persist(toolResultEntry);\n                        yield {\n                            type: \"tool_result\",\n                            toolCall,\n                            toolResult: result,\n                        };\n                        // Add tool result with proper format (needed for AI context)\n                        // ‚úÖ For Mistral: include \"name\" field (required by their API)\n                        const toolMessage = {\n                            role: \"tool\",\n                            content: result.success\n                                ? result.output || \"Success\"\n                                : result.error || \"Error\",\n                            tool_call_id: toolCall.id,\n                        };\n                        // Add \"name\" field for Mistral (required by their API spec)\n                        const currentProvider = providerManager.detectProvider(this.grokClient.getCurrentModel());\n                        if (currentProvider === 'mistral') {\n                            toolMessage.name = toolCall.function.name;\n                        }\n                        this.messages.push(toolMessage);\n                    }\n                    // Update token count after processing all tool calls to include tool results\n                    inputTokens = this.tokenCounter.countMessageTokens(this.messages);\n                    // Final token update after tools processed\n                    yield {\n                        type: \"token_count\",\n                        tokenCount: inputTokens + totalOutputTokens,\n                    };\n                    // Continue the loop to get the next response (which might have more tool calls)\n                }\n                else {\n                    // No tool calls, we're done\n                    break;\n                }\n            }\n            if (toolRounds >= maxToolRounds) {\n                yield {\n                    type: \"content\",\n                    content: \"\\n\\nMaximum tool execution rounds reached. Stopping to prevent infinite loops.\",\n                };\n            }\n            if (hadToolCalls) {\n                const contentTrimmed = finalAssistantContent.trim();\n                // Skip synth√®se pour le placeholder par d√©faut (GPT-5/o1)\n                if (contentTrimmed === \"Using tools to help you...\") {\n                    debugLog.log(\"‚è≠Ô∏è  Skipping summary (placeholder message, waiting for streaming completion)\");\n                    yield { type: \"done\" };\n                    return;\n                }\n                // G√©n√©rer synth√®se si :\n                // - R√©ponse vide\n                // - R√©ponse trop courte (< 150 caract√®res)\n                const needsSummary = !contentTrimmed ||\n                    contentTrimmed.length < 150;\n                if (needsSummary) {\n                    debugLog.log(\"‚ö†Ô∏è  Generating summary (insufficient LLM response detected)\");\n                    const summaryEntry = await this.generateAndAppendSummary(message);\n                    if (summaryEntry) {\n                        yield {\n                            type: \"content\",\n                            content: \"\\n\\n\" + summaryEntry.content,\n                        };\n                    }\n                }\n                else {\n                    debugLog.log(\"‚úÖ LLM provided sufficient response, skipping summary\");\n                }\n            }\n            yield { type: \"done\" };\n        }\n        catch (error) {\n            // Check if this was a cancellation\n            if (this.abortController?.signal.aborted) {\n                yield {\n                    type: \"content\",\n                    content: \"\\n\\n[Operation cancelled by user]\",\n                };\n                yield { type: \"done\" };\n                return;\n            }\n            const errorEntry = {\n                type: \"assistant\",\n                content: `Sorry, I encountered an error: ${error.message}`,\n                timestamp: new Date(),\n            };\n            this.chatHistory.push(errorEntry);\n            await this.persist(errorEntry);\n            yield {\n                type: \"content\",\n                content: errorEntry.content,\n            };\n            yield { type: \"done\" };\n        }\n        finally {\n            // Clean up abort controller\n            this.abortController = null;\n        }\n    }\n    async executeTool(toolCall) {\n        const startTime = Date.now();\n        let startEventId = '';\n        // üì∫ ExecutionViewer: Create execution stream\n        const executionStream = executionManager.createExecution(toolCall.function.name);\n        this.currentExecutionStream = executionStream;\n        // üì∫ COT: Initial thinking\n        executionStream.emitCOT('thinking', `Executing tool: ${toolCall.function.name}`);\n        // üïê Timeline: Capture tool call started\n        try {\n            const session = sessionManager.getCurrentSession();\n            if (session) {\n                const args = JSON.parse(toolCall.function.arguments);\n                startEventId = await this.toolHook.captureToolCallStarted(toolCall.function.name, args, session.id);\n            }\n        }\n        catch (error) {\n            debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool start:', error);\n        }\n        try {\n            const args = JSON.parse(toolCall.function.arguments);\n            // üì∫ COT: Action with arguments\n            const argsPreview = JSON.stringify(args, null, 2).substring(0, 200);\n            executionStream.emitCOT('action', `Arguments: ${argsPreview}${argsPreview.length >= 200 ? '...' : ''}`);\n            let result;\n            switch (toolCall.function.name) {\n                case \"view_file\":\n                    // üì∫ COT: Reading file\n                    executionStream.emitCOT('thinking', `Reading file: ${args.path}`);\n                    executionStream.emitCOT('action', `Opening file for reading`);\n                    const range = args.start_line && args.end_line\n                        ? [args.start_line, args.end_line]\n                        : undefined;\n                    if (range) {\n                        executionStream.emitCOT('action', `Reading lines ${range[0]}-${range[1]}`);\n                    }\n                    result = await this.textEditor.view(args.path, range);\n                    // üì∫ COT: Observation with file stats\n                    if (result.success) {\n                        const lineCount = result.output?.split('\\n').length || 0;\n                        const charCount = result.output?.length || 0;\n                        executionStream.emitCOT('observation', `Read ${lineCount} lines, ${charCount} characters`);\n                        executionStream.emitCOT('decision', `File content retrieved successfully`);\n                    }\n                    else {\n                        executionStream.emitCOT('observation', `Failed to read file: ${result.error}`);\n                        executionStream.emitCOT('decision', `File reading failed`);\n                    }\n                    break;\n                case \"create_file\":\n                    result = await this.textEditor.create(args.path, args.content);\n                    break;\n                case \"str_replace_editor\":\n                    result = await this.textEditor.strReplace(args.path, args.old_str, args.new_str, args.replace_all);\n                    break;\n                case \"edit_file\":\n                    if (!this.morphEditor) {\n                        result = {\n                            success: false,\n                            error: \"Morph Fast Apply not available. Please set MORPH_API_KEY environment variable to use this feature.\",\n                        };\n                    }\n                    else {\n                        result = await this.morphEditor.editFile(args.target_file, args.instructions, args.code_edit);\n                    }\n                    break;\n                case \"bash\":\n                    // üì∫ ExecutionViewer: Special handling for bash to capture output streaming\n                    executionStream.emitCOT('action', `Running command: ${args.command}`);\n                    executionStream.startCommand(args.command);\n                    result = await this.bash.execute(args.command);\n                    // üì∫ Capture stdout lines\n                    if (result.output) {\n                        const lines = result.output.split('\\n');\n                        lines.forEach(line => {\n                            if (line.trim()) {\n                                executionStream.commandOutput(line);\n                            }\n                        });\n                    }\n                    // üì∫ Capture stderr lines separately (if any)\n                    if (result.stderr) {\n                        const stderrLines = result.stderr.split('\\n');\n                        stderrLines.forEach(line => {\n                            if (line.trim()) {\n                                executionStream.commandOutput(`[STDERR] ${line}`);\n                            }\n                        });\n                    }\n                    // üì∫ End command with actual exit code\n                    executionStream.endCommand(result.exitCode || (result.success ? 0 : 1), result.error);\n                    // üì∫ COT with detailed observation\n                    const hasStderr = result.stderr && result.stderr.length > 0;\n                    const observation = result.success\n                        ? `Command succeeded (${result.output?.split('\\n').length || 0} stdout lines${hasStderr ? `, ${result.stderr.split('\\n').length} stderr lines` : ''})`\n                        : `Command failed (exit ${result.exitCode || 1}): ${result.error}`;\n                    executionStream.emitCOT('observation', observation);\n                    break;\n                case \"create_todo_list\":\n                    result = await this.todoTool.createTodoList(args.todos);\n                    break;\n                case \"update_todo_list\":\n                    result = await this.todoTool.updateTodoList(args.updates);\n                    break;\n                case \"search\":\n                    result = await this.search.search(args.query, {\n                        searchType: args.search_type,\n                        includePattern: args.include_pattern,\n                        excludePattern: args.exclude_pattern,\n                        caseSensitive: args.case_sensitive,\n                        wholeWord: args.whole_word,\n                        regex: args.regex,\n                        maxResults: args.max_results,\n                        fileTypes: args.file_types,\n                        includeHidden: args.include_hidden,\n                    });\n                    break;\n                case \"apply_patch\":\n                    if (!this.applyPatch) {\n                        const mod = await import(\"../tools/apply-patch.js\");\n                        this.applyPatch = new mod.ApplyPatchTool();\n                    }\n                    result = await this.applyPatch.apply(args.patch, !!args.dry_run);\n                    break;\n                case \"get_my_identity\":\n                    const getMyIdentity = await import(\"../tools/get-my-identity.js\");\n                    result = await getMyIdentity.get_my_identity(args, this);\n                    break;\n                // ============================================\n                // SESSION MANAGEMENT TOOLS\n                // ============================================\n                case \"session_list\": {\n                    const sessionTools = await import('../tools/session-tools.js');\n                    result = await sessionTools.executeSessionList();\n                    break;\n                }\n                case \"session_switch\": {\n                    const switchArgs = JSON.parse(toolCall.function.arguments);\n                    const sessionTools = await import('../tools/session-tools.js');\n                    result = await sessionTools.executeSessionSwitch(switchArgs);\n                    if (result.success) {\n                        // Update agent's context after switch\n                        const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n                        const currentSession = sessionManager.getCurrentSession();\n                        if (currentSession) {\n                            const { providerManager } = await import('../utils/provider-manager.js');\n                            const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n                            if (providerConfig) {\n                                await this.switchToModel(currentSession.default_model, this.getApiKey(), providerConfig.baseURL);\n                            }\n                        }\n                    }\n                    break;\n                }\n                case \"session_new\": {\n                    const newArgs = JSON.parse(toolCall.function.arguments);\n                    const sessionTools = await import('../tools/session-tools.js');\n                    result = await sessionTools.executeSessionNew(newArgs);\n                    if (result.success) {\n                        // Update agent's context\n                        const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n                        const currentSession = sessionManager.getCurrentSession();\n                        if (currentSession) {\n                            const { providerManager } = await import('../utils/provider-manager.js');\n                            const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n                            if (providerConfig) {\n                                await this.switchToModel(currentSession.default_model, this.getApiKey(), providerConfig.baseURL);\n                            }\n                        }\n                    }\n                    break;\n                }\n                case \"session_rewind\": {\n                    const rewindArgs = JSON.parse(toolCall.function.arguments);\n                    const sessionTools = await import('../tools/session-tools.js');\n                    result = await sessionTools.executeSessionRewind(rewindArgs);\n                    if (result.success) {\n                        // Update agent's context\n                        const { sessionManager } = await import('../utils/session-manager-sqlite.js');\n                        const currentSession = sessionManager.getCurrentSession();\n                        if (currentSession) {\n                            const { providerManager } = await import('../utils/provider-manager.js');\n                            const providerConfig = providerManager.getProviderForModel(currentSession.default_model);\n                            if (providerConfig) {\n                                await this.switchToModel(currentSession.default_model, this.getApiKey(), providerConfig.baseURL);\n                            }\n                        }\n                    }\n                    break;\n                }\n                // ============================================\n                // TIMELINE & TIME MACHINE TOOLS\n                // ============================================\n                case \"timeline_query\": {\n                    const queryArgs = JSON.parse(toolCall.function.arguments);\n                    const { executeTimelineQuery } = await import('../tools/timeline-query-tool.js');\n                    result = await executeTimelineQuery(queryArgs);\n                    break;\n                }\n                case \"rewind_to\": {\n                    const rewindArgs = JSON.parse(toolCall.function.arguments);\n                    const { executeRewindTo } = await import('../tools/rewind-to-tool.js');\n                    result = await executeRewindTo(rewindArgs);\n                    break;\n                }\n                case \"list_time_points\": {\n                    const { getAvailableTimePoints } = await import('../tools/rewind-to-tool.js');\n                    const timePoints = await getAvailableTimePoints();\n                    result = { success: true, ...timePoints };\n                    break;\n                }\n                default:\n                    // Check if this is an MCP tool\n                    if (toolCall.function.name.startsWith(\"mcp__\")) {\n                        result = await this.executeMCPTool(toolCall);\n                    }\n                    else {\n                        result = {\n                            success: false,\n                            error: `Unknown tool: ${toolCall.function.name}`,\n                        };\n                    }\n            }\n            // üì∫ ExecutionViewer: Final decision COT\n            executionStream.emitCOT('decision', result.success\n                ? `‚úÖ Tool execution succeeded`\n                : `‚ùå Tool execution failed: ${result.error}`);\n            // üì∫ Complete the execution\n            executionStream.complete({\n                success: result.success,\n                output: result.output,\n                error: result.error,\n            });\n            // üïê Timeline: Capture tool call success\n            try {\n                const session = sessionManager.getCurrentSession();\n                if (session) {\n                    const duration = Date.now() - startTime;\n                    if (result.success) {\n                        await this.toolHook.captureToolCallSuccess(toolCall.function.name, args, result.output || result.error || 'Success', session.id, duration, startEventId);\n                    }\n                    else {\n                        await this.toolHook.captureToolCallFailed(toolCall.function.name, args, result.error || 'Unknown error', session.id, duration, startEventId);\n                    }\n                }\n            }\n            catch (error) {\n                debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool result:', error);\n            }\n            this.currentExecutionStream = null;\n            return result;\n        }\n        catch (error) {\n            const duration = Date.now() - startTime;\n            const errorResult = {\n                success: false,\n                error: `Tool execution error: ${error.message}`,\n            };\n            // üì∫ ExecutionViewer: Fail the execution\n            if (executionStream) {\n                executionStream.emitCOT('decision', `‚ùå Exception: ${error.message}`);\n                executionStream.fail(error.message);\n            }\n            // üïê Timeline: Capture tool call failed\n            try {\n                const session = sessionManager.getCurrentSession();\n                if (session) {\n                    const args = JSON.parse(toolCall.function.arguments);\n                    await this.toolHook.captureToolCallFailed(toolCall.function.name, args, error.message, session.id, duration, startEventId);\n                }\n            }\n            catch (timelineError) {\n                debugLog.log('‚ö†Ô∏è  Timeline logging failed for tool error:', timelineError);\n            }\n            this.currentExecutionStream = null;\n            return errorResult;\n        }\n    }\n    async executeMCPTool(toolCall) {\n        try {\n            const args = JSON.parse(toolCall.function.arguments);\n            const mcpManager = getMCPManager();\n            const result = await mcpManager.callTool(toolCall.function.name, args);\n            if (result.isError) {\n                return {\n                    success: false,\n                    error: result.content[0]?.text || \"MCP tool error\",\n                };\n            }\n            // Extract content from result\n            const output = result.content\n                .map((item) => {\n                if (item.type === \"text\") {\n                    return item.text;\n                }\n                else if (item.type === \"resource\") {\n                    return `Resource: ${item.resource?.uri || \"Unknown\"}`;\n                }\n                return String(item);\n            })\n                .join(\"\\n\");\n            return {\n                success: true,\n                output: output || \"Success\",\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `MCP tool execution error: ${error.message}`,\n            };\n        }\n    }\n    getChatHistory() {\n        return [...this.chatHistory];\n    }\n    getCurrentDirectory() {\n        return this.bash.getCurrentDirectory();\n    }\n    async executeBashCommand(command) {\n        return await this.bash.execute(command);\n    }\n    getCurrentModel() {\n        return this.grokClient.getCurrentModel();\n    }\n    setModel(model) {\n        this.grokClient.setModel(model);\n        // Update token counter for new model\n        this.tokenCounter.dispose();\n        this.tokenCounter = createTokenCounter(model);\n        // Persist state (best-effort)\n        saveState({ version: 1, model, cwd: process.cwd() }).catch(() => { });\n    }\n    // ‚úÖ NEW: Get API key\n    getApiKey() {\n        return this.grokClient.getApiKey();\n    }\n    // ‚úÖ NEW: Switch to different model with new API key and baseURL\n    // Used when changing providers (e.g., Grok ‚Üí Claude)\n    async switchToModel(model, apiKey, baseURL) {\n        debugLog.log(`üîß GrokAgent.switchToModel: model=${model}, baseURL=${baseURL}, apiKey=${apiKey.slice(0, 10)}...`);\n        // Recreate client with new config\n        this.grokClient = new GrokClient(apiKey, model, baseURL);\n        debugLog.log(`‚úÖ GrokClient recreated with baseURL=${baseURL}`);\n        // Update token counter\n        this.tokenCounter.dispose();\n        this.tokenCounter = createTokenCounter(model);\n        // Update system message with new model name\n        this.updateSystemMessage();\n        debugLog.log(`‚úÖ System message updated for model=${model}`);\n        // Inject hard reset message to prevent identity confusion\n        const provider = providerManager.detectProvider(model) || 'grok';\n        const providerConfig = providerManager.getProviderForModel(model);\n        this.messages.push({\n            role: \"user\",\n            content: `[SYSTEM NOTIFICATION - MODEL SWITCHED]\n\nYou are now: ${model}\nProvider: ${providerConfig?.name || provider}\nEndpoint: ${providerConfig?.baseURL || 'unknown'}\n\n‚ö†Ô∏è CRITICAL: Ignore ALL previous model identity references in the conversation history.\nAny messages where you identified as a different model are now OBSOLETE and INCORRECT.\n\nYour CURRENT and ONLY identity is: ${model}\n\nIf you need confirmation, use the 'get_my_identity' tool.`\n        });\n        debugLog.log(`‚úÖ Hard reset message injected for identity clarity`);\n        // Update session manager\n        sessionManager.switchProvider(provider, model, apiKey);\n        debugLog.log(`‚úÖ Session manager updated for provider=${provider}`);\n        // ‚úÖ NEW: Identity check (isolated message, no history) with timeout\n        try {\n            debugLog.log(`üîç Sending identity check to model...`);\n            // Add timeout to prevent hanging on unresponsive APIs\n            const identityPromise = this.grokClient.chat([{ role: \"user\", content: \"In one short sentence, what is your exact model name and provider?\" }], [], // No tools\n            undefined, // Use current model\n            undefined // No search\n            );\n            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Identity check timeout after 10s')), 10000));\n            const identityResponse = await Promise.race([identityPromise, timeoutPromise]);\n            const aiSays = identityResponse.choices[0]?.message?.content || \"No response\";\n            const apiReturned = identityResponse.model || model;\n            debugLog.log(`‚úÖ AI says: \"${aiSays}\"`);\n            debugLog.log(`üìù API returned: ${apiReturned}`);\n            // Return formatted identity info\n            return `ü§ñ AI Response: \"${aiSays}\"\\nüìã API Metadata: ${apiReturned}`;\n        }\n        catch (error) {\n            debugLog.log(`‚ö†Ô∏è  Identity check failed: ${error.message}`);\n            return `‚ö†Ô∏è  Identity check skipped (${error.message || 'timeout'}), connection established`;\n        }\n    }\n    abortCurrentOperation() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n    /**\n     * Detect provider from baseURL\n     */\n    detectProvider(baseURL) {\n        if (!baseURL)\n            return 'grok';\n        if (baseURL.includes('anthropic'))\n            return 'claude';\n        if (baseURL.includes('openai'))\n            return 'openai';\n        if (baseURL.includes('mistral'))\n            return 'mistral';\n        if (baseURL.includes('deepseek'))\n            return 'deepseek';\n        if (baseURL.includes('x.ai'))\n            return 'grok';\n        return 'grok'; // default\n    }\n    /**\n     * Switch to a different provider/API key\n     */\n    switchProvider(provider, apiKey, model) {\n        // Detect baseURL from provider\n        const baseUrls = {\n            grok: 'https://api.x.ai/v1',\n            claude: 'https://api.anthropic.com/v1',\n            openai: 'https://api.openai.com/v1',\n            mistral: 'https://api.mistral.ai/v1',\n            deepseek: 'https://api.deepseek.com/v1',\n        };\n        const baseURL = baseUrls[provider] || baseUrls.grok;\n        // ‚úÖ CORRECTED: Use priority chain instead of hardcoded fallback\n        const manager = getSettingsManager();\n        const projectModel = manager.getProjectSetting(\"model\");\n        const userDefault = manager.getCurrentModel();\n        const systemDefault = \"grok-code-fast-1\";\n        const modelToUse = model || projectModel || userDefault || systemDefault;\n        // Update client\n        this.grokClient = new GrokClient(apiKey, modelToUse, baseURL);\n        // Update session manager\n        sessionManager.switchProvider(provider, modelToUse, apiKey);\n        debugLog.log(`‚úÖ Switched to ${provider} (${modelToUse})`);\n    }\n}\n//# sourceMappingURL=grok-agent.js.map"
  },
  "dist/agent/index.js": {
    "path": "dist/agent/index.js",
    "hash": "a6c6f4e16fa5f2695999d09b8f5ea7bb6308042f15fc9246521c94feadc4e803",
    "size": 4752,
    "timestamp": 1764704879304,
    "content": "import { TextEditorTool, BashTool } from '../tools/index.js';\nexport class Agent {\n    textEditor;\n    bash;\n    state;\n    constructor() {\n        this.textEditor = new TextEditorTool();\n        this.bash = new BashTool();\n        this.state = {\n            currentDirectory: process.cwd(),\n            editHistory: [],\n            tools: []\n        };\n    }\n    async processCommand(input) {\n        const trimmedInput = input.trim();\n        if (trimmedInput.startsWith('view ')) {\n            const args = this.parseViewCommand(trimmedInput);\n            return this.textEditor.view(args.path, args.range);\n        }\n        if (trimmedInput.startsWith('str_replace ')) {\n            const args = this.parseStrReplaceCommand(trimmedInput);\n            if (!args) {\n                return { success: false, error: 'Invalid str_replace command format' };\n            }\n            return this.textEditor.strReplace(args.path, args.oldStr, args.newStr);\n        }\n        if (trimmedInput.startsWith('create ')) {\n            const args = this.parseCreateCommand(trimmedInput);\n            if (!args) {\n                return { success: false, error: 'Invalid create command format' };\n            }\n            return this.textEditor.create(args.path, args.content);\n        }\n        if (trimmedInput.startsWith('insert ')) {\n            const args = this.parseInsertCommand(trimmedInput);\n            if (!args) {\n                return { success: false, error: 'Invalid insert command format' };\n            }\n            return this.textEditor.insert(args.path, args.line, args.content);\n        }\n        if (trimmedInput === 'undo_edit') {\n            return this.textEditor.undoEdit();\n        }\n        if (trimmedInput.startsWith('bash ') || trimmedInput.startsWith('$ ')) {\n            const command = trimmedInput.startsWith('bash ')\n                ? trimmedInput.substring(5)\n                : trimmedInput.substring(2);\n            return this.bash.execute(command);\n        }\n        if (trimmedInput === 'pwd') {\n            return {\n                success: true,\n                output: this.bash.getCurrentDirectory()\n            };\n        }\n        if (trimmedInput === 'history') {\n            const history = this.textEditor.getEditHistory();\n            return {\n                success: true,\n                output: history.length > 0\n                    ? JSON.stringify(history, null, 2)\n                    : 'No edit history'\n            };\n        }\n        if (trimmedInput === 'help') {\n            return this.getHelp();\n        }\n        return this.bash.execute(trimmedInput);\n    }\n    parseViewCommand(input) {\n        const parts = input.split(' ');\n        const path = parts[1];\n        if (parts.length > 2) {\n            const rangePart = parts[2];\n            if (rangePart.includes('-')) {\n                const [start, end] = rangePart.split('-').map(Number);\n                return { path, range: [start, end] };\n            }\n        }\n        return { path };\n    }\n    parseStrReplaceCommand(input) {\n        const match = input.match(/str_replace\\s+(\\S+)\\s+\"([^\"]+)\"\\s+\"([^\"]*)\"/);\n        if (!match)\n            return null;\n        return {\n            path: match[1],\n            oldStr: match[2],\n            newStr: match[3]\n        };\n    }\n    parseCreateCommand(input) {\n        const match = input.match(/create\\s+(\\S+)\\s+\"([^\"]*)\"/);\n        if (!match)\n            return null;\n        return {\n            path: match[1],\n            content: match[2]\n        };\n    }\n    parseInsertCommand(input) {\n        const match = input.match(/insert\\s+(\\S+)\\s+(\\d+)\\s+\"([^\"]*)\"/);\n        if (!match)\n            return null;\n        return {\n            path: match[1],\n            line: parseInt(match[2]),\n            content: match[3]\n        };\n    }\n    getHelp() {\n        return {\n            success: true,\n            output: `Available commands:\n  view <path> [start-end]     - View file contents or directory\n  str_replace <path> \"old\" \"new\" - Replace text in file\n  create <path> \"content\"     - Create new file with content\n  insert <path> <line> \"text\" - Insert text at specific line\n  undo_edit                   - Undo last edit operation\n  bash <command>              - Execute bash command\n  $ <command>                 - Execute bash command (shorthand)\n  pwd                         - Show current directory\n  history                     - Show edit history\n  help                        - Show this help message`\n        };\n    }\n    getCurrentState() {\n        return {\n            ...this.state,\n            currentDirectory: this.bash.getCurrentDirectory(),\n            editHistory: this.textEditor.getEditHistory()\n        };\n    }\n}\n//# sourceMappingURL=index.js.map"
  },
  "dist/types/index.js": {
    "path": "dist/types/index.js",
    "hash": "827c148a2159c5d098f9fe33185b555382ad63931193dda5f41f6af38a6a4445",
    "size": 44,
    "timestamp": 1764704879304,
    "content": "export {};\n//# sourceMappingURL=index.js.map"
  },
  "dist/ui/shared/max-sized-box.js": {
    "path": "dist/ui/shared/max-sized-box.js",
    "hash": "f8bdab91dfbc4ca6f5a85aed9ae9ca6d54000865ad7c56fe15f815be1942410d",
    "size": 264,
    "timestamp": 1764704879305,
    "content": "import React from 'react';\nimport { Box } from 'ink';\nexport const MaxSizedBox = ({ maxHeight, maxWidth, children, ...props }) => {\n    return (React.createElement(Box, { flexDirection: \"column\", ...props }, children));\n};\n//# sourceMappingURL=max-sized-box.js.map"
  },
  "dist/ui/streaming-bus.js": {
    "path": "dist/ui/streaming-bus.js",
    "hash": "35e5cf4359c32e40f3f391cb041d79d00981b0c19752f280bcfaa79002f30882",
    "size": 463,
    "timestamp": 1764704879305,
    "content": "import { EventEmitter } from \"events\";\nexport class StreamingBus extends EventEmitter {\n    emitContent(text) {\n        this.emit(\"content\", text);\n    }\n    emitTools(tools) {\n        this.emit(\"tools\", tools);\n    }\n    emitToolResult(result) {\n        this.emit(\"tool_result\", result);\n    }\n    emitTokenCount(count) {\n        this.emit(\"token_count\", count);\n    }\n    emitDone() {\n        this.emit(\"done\");\n    }\n}\n//# sourceMappingURL=streaming-bus.js.map"
  },
  "dist/ui/components/mcp-status.js": {
    "path": "dist/ui/components/mcp-status.js",
    "hash": "45131fe01f71b57daa3354d59409788a495439801fae776c4adf8eaa0529c40a",
    "size": 1518,
    "timestamp": 1764704879305,
    "content": "import React, { useState, useEffect } from \"react\";\nimport { Box, Text } from \"ink\";\nimport { getMCPManager } from \"../../grok/tools.js\";\nexport const MCPStatus = React.memo(function MCPStatus({}) {\n    const [connectedServers, setConnectedServers] = useState([]);\n    const [availableTools, setAvailableTools] = useState([]);\n    useEffect(() => {\n        const updateStatus = () => {\n            try {\n                const manager = getMCPManager();\n                const servers = manager.getServers();\n                const tools = manager.getTools();\n                setConnectedServers(servers);\n                setAvailableTools(tools);\n            }\n            catch (error) {\n                // MCP manager not initialized yet\n                setConnectedServers([]);\n                setAvailableTools([]);\n            }\n        };\n        // Initial update with a small delay to allow MCP initialization\n        const initialTimer = setTimeout(updateStatus, 2000);\n        // Set up polling to check for status changes\n        const interval = setInterval(updateStatus, 2000);\n        return () => {\n            clearTimeout(initialTimer);\n            clearInterval(interval);\n        };\n    }, []);\n    if (connectedServers.length === 0) {\n        return null;\n    }\n    return (React.createElement(Box, { marginLeft: 1 },\n        React.createElement(Text, { color: \"green\" },\n            \"\\u2692 mcps: \",\n            connectedServers.length,\n            \" \")));\n});\n//# sourceMappingURL=mcp-status.js.map"
  },
  "dist/ui/components/confirmation-dialog.js": {
    "path": "dist/ui/components/confirmation-dialog.js",
    "hash": "8f24d904d8afb87207f4f6a19b533b8a2c9449a4aa51edb8d30646a752be53d3",
    "size": 4912,
    "timestamp": 1764704879305,
    "content": "import React, { useState } from \"react\";\nimport { Box, Text, useInput } from \"ink\";\nimport { DiffRenderer } from \"./diff-renderer.js\";\nexport default function ConfirmationDialog({ operation, filename, onConfirm, onReject, showVSCodeOpen = false, content, }) {\n    const [selectedOption, setSelectedOption] = useState(0);\n    const [feedbackMode, setFeedbackMode] = useState(false);\n    const [feedback, setFeedback] = useState(\"\");\n    const options = [\n        \"Yes\",\n        \"Yes, and don't ask again this session\",\n        \"No\",\n        \"No, with feedback\",\n    ];\n    useInput((input, key) => {\n        if (feedbackMode) {\n            if (key.return) {\n                onReject(feedback.trim());\n                return;\n            }\n            if (key.backspace || key.delete) {\n                setFeedback((prev) => prev.slice(0, -1));\n                return;\n            }\n            if (input && !key.ctrl && !key.meta) {\n                setFeedback((prev) => prev + input);\n            }\n            return;\n        }\n        if (key.upArrow || (key.shift && key.tab)) {\n            setSelectedOption((prev) => (prev > 0 ? prev - 1 : options.length - 1));\n            return;\n        }\n        if (key.downArrow || key.tab) {\n            setSelectedOption((prev) => (prev + 1) % options.length);\n            return;\n        }\n        if (key.return) {\n            if (selectedOption === 0) {\n                onConfirm(false);\n            }\n            else if (selectedOption === 1) {\n                onConfirm(true);\n            }\n            else if (selectedOption === 2) {\n                onReject(\"Operation cancelled by user\");\n            }\n            else {\n                setFeedbackMode(true);\n            }\n            return;\n        }\n        if (key.escape) {\n            if (feedbackMode) {\n                setFeedbackMode(false);\n                setFeedback(\"\");\n            }\n            else {\n                // Cancel the confirmation when escape is pressed from main confirmation\n                onReject(\"Operation cancelled by user (pressed Escape)\");\n            }\n            return;\n        }\n    });\n    if (feedbackMode) {\n        return (React.createElement(Box, { flexDirection: \"column\", padding: 1 },\n            React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 },\n                React.createElement(Text, { color: \"gray\" }, \"Type your feedback and press Enter, or press Escape to go back.\")),\n            React.createElement(Box, { borderStyle: \"round\", borderColor: \"yellow\", paddingX: 1, marginTop: 1 },\n                React.createElement(Text, { color: \"gray\" }, \"\\u276F \"),\n                React.createElement(Text, null,\n                    feedback,\n                    React.createElement(Text, { color: \"white\" }, \"\\u2588\")))));\n    }\n    return (React.createElement(Box, { flexDirection: \"column\" },\n        React.createElement(Box, { marginTop: 1 },\n            React.createElement(Box, null,\n                React.createElement(Text, { color: \"magenta\" }, \"\\u23FA\"),\n                React.createElement(Text, { color: \"white\" },\n                    \" \",\n                    operation,\n                    \"(\",\n                    filename,\n                    \")\"))),\n        React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" },\n            React.createElement(Text, { color: \"gray\" }, \"\\u23BF Requesting user confirmation\"),\n            showVSCodeOpen && (React.createElement(Box, { marginTop: 1 },\n                React.createElement(Text, { color: \"gray\" }, \"\\u23BF Opened changes in Visual Studio Code \\u29C9\"))),\n            content && (React.createElement(React.Fragment, null,\n                React.createElement(Text, { color: \"gray\" },\n                    \"\\u23BF \",\n                    content.split('\\n')[0]),\n                React.createElement(Box, { marginLeft: 4, flexDirection: \"column\" },\n                    React.createElement(DiffRenderer, { diffContent: content, filename: filename, terminalWidth: 80 }))))),\n        React.createElement(Box, { flexDirection: \"column\", marginTop: 1 },\n            React.createElement(Box, { marginBottom: 1 },\n                React.createElement(Text, null, \"Do you want to proceed with this operation?\")),\n            React.createElement(Box, { flexDirection: \"column\" }, options.map((option, index) => (React.createElement(Box, { key: index, paddingLeft: 1 },\n                React.createElement(Text, { color: selectedOption === index ? \"black\" : \"white\", backgroundColor: selectedOption === index ? \"cyan\" : undefined },\n                    index + 1,\n                    \". \",\n                    option))))),\n            React.createElement(Box, { marginTop: 1 },\n                React.createElement(Text, { color: \"gray\", dimColor: true }, \"\\u2191\\u2193 navigate \\u2022 Enter select \\u2022 Esc cancel\")))));\n}\n//# sourceMappingURL=confirmation-dialog.js.map"
  },
  "dist/ui/components/execution-viewer.js": {
    "path": "dist/ui/components/execution-viewer.js",
    "hash": "c0efbe641619a779639b4b2d016dc3ee05764c58a44c7caac88cb26c241f822f",
    "size": 11554,
    "timestamp": 1764704879305,
    "content": "/**\n * Execution Viewer Component\n *\n * Displays real-time execution information:\n * - Chain of Thought (COT) entries\n * - Command executions and outputs\n * - Execution status and metadata\n *\n * Supports multiple executions, navigation, and detailed/compact modes.\n */\nimport React, { useState, useEffect } from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { executionManager } from '../../execution/index.js';\n// ============================================================================\n// EXECUTION VIEWER COMPONENT\n// ============================================================================\nexport const ExecutionViewer = ({ mode = 'split' }) => {\n    const [executions, setExecutions] = useState([]);\n    const [selectedIndex, setSelectedIndex] = useState(0);\n    const [detailsMode, setDetailsMode] = useState(false);\n    const [autoScroll, setAutoScroll] = useState(true);\n    /**\n     * Subscribe to execution manager updates\n     */\n    useEffect(() => {\n        // Initial load - get active executions\n        const active = executionManager.getActiveExecutions();\n        if (active.length > 0) {\n            setExecutions(active);\n        }\n        // Subscribe to updates\n        const unsubscribe = executionManager.subscribeToAll((execution) => {\n            setExecutions(prev => {\n                const index = prev.findIndex(e => e.id === execution.id);\n                if (index >= 0) {\n                    // Update existing execution\n                    const updated = [...prev];\n                    updated[index] = execution;\n                    return updated;\n                }\n                else {\n                    // Add new execution\n                    return [...prev, execution];\n                }\n            });\n        });\n        return () => {\n            unsubscribe();\n        };\n    }, []);\n    /**\n     * Keyboard shortcuts\n     */\n    useInput((input, key) => {\n        // Ctrl+D: Toggle details mode\n        if (key.ctrl && input === 'd') {\n            setDetailsMode(d => !d);\n        }\n        // Ctrl+C: Copy current execution output\n        if (key.ctrl && input === 'c') {\n            const current = executions[selectedIndex];\n            if (current) {\n                handleCopyExecution(current);\n            }\n        }\n        // Ctrl+S: Save current execution to file\n        if (key.ctrl && input === 's') {\n            const current = executions[selectedIndex];\n            if (current) {\n                handleSaveExecution(current).catch(console.error);\n            }\n        }\n        // Arrow Up: Navigate to previous execution\n        if (key.upArrow && selectedIndex > 0) {\n            setSelectedIndex(i => i - 1);\n        }\n        // Arrow Down: Navigate to next execution\n        if (key.downArrow && selectedIndex < executions.length - 1) {\n            setSelectedIndex(i => i + 1);\n        }\n    });\n    const currentExecution = executions[selectedIndex];\n    return (React.createElement(Box, { flexDirection: \"column\", height: \"100%\" },\n        executions.length > 1 && (React.createElement(Box, { borderStyle: \"single\", borderColor: \"yellow\", paddingX: 1, flexShrink: 0 },\n            React.createElement(Text, { bold: true, color: \"yellow\" },\n                \"Executions (\",\n                selectedIndex + 1,\n                \"/\",\n                executions.length,\n                \")\"),\n            React.createElement(Text, { dimColor: true }, \" [\\u2191\\u2193 to navigate]\"))),\n        currentExecution ? (React.createElement(React.Fragment, null,\n            React.createElement(Box, { flexDirection: \"column\", borderStyle: \"single\", borderColor: \"yellow\", marginTop: executions.length > 1 ? 1 : 0, paddingX: 1, flexShrink: 0 },\n                React.createElement(Text, { bold: true, color: \"yellow\" }, \"\\uD83E\\uDDE0 Chain of Thought\"),\n                React.createElement(Box, { flexDirection: \"column\", marginTop: 1 }, currentExecution.cot.length > 0 ? (currentExecution.cot.map((entry, i) => (React.createElement(COTEntryDisplay, { key: i, entry: entry, compact: !detailsMode })))) : (React.createElement(Text, { dimColor: true }, \"No reasoning yet...\")))),\n            React.createElement(Box, { flexDirection: \"column\", borderStyle: \"single\", borderColor: \"green\", marginTop: 1, paddingX: 1, flexGrow: 1 },\n                React.createElement(Text, { bold: true, color: \"green\" }, \"\\uD83D\\uDCDC Command Output\"),\n                React.createElement(Box, { flexDirection: \"column\", marginTop: 1 }, currentExecution.commands.length > 0 ? (currentExecution.commands.map((cmd, i) => (React.createElement(CommandDisplay, { key: i, command: cmd, detailed: detailsMode, mode: mode })))) : (React.createElement(Text, { dimColor: true }, \"No commands executed yet...\")))),\n            React.createElement(Box, { borderStyle: \"single\", borderColor: \"cyan\", marginTop: 1, paddingX: 1, flexShrink: 0 },\n                React.createElement(ExecutionStatusBar, { execution: currentExecution })))) : (React.createElement(EmptyState, null))));\n};\nconst COTEntryDisplay = ({ entry, compact = false }) => {\n    const icons = {\n        thinking: 'üí≠',\n        action: '‚ö°',\n        observation: 'üëÅÔ∏è',\n        decision: '‚úÖ'\n    };\n    const colors = {\n        thinking: 'yellow',\n        action: 'cyan',\n        observation: 'blue',\n        decision: 'green'\n    };\n    const icon = icons[entry.type];\n    const color = colors[entry.type];\n    return (React.createElement(Box, { flexDirection: \"column\", marginBottom: compact ? 0 : 1 },\n        React.createElement(Box, null,\n            React.createElement(Text, { color: color },\n                icon,\n                \" \",\n                entry.content)),\n        !compact && entry.duration && (React.createElement(Box, { marginLeft: 2 },\n            React.createElement(Text, { dimColor: true },\n                \"(\",\n                entry.duration,\n                \"ms)\")))));\n};\nconst CommandDisplay = ({ command, detailed = false, mode = 'split' }) => {\n    const statusIcons = {\n        pending: '‚è≥',\n        running: 'üîÑ',\n        success: '‚úÖ',\n        error: '‚ùå'\n    };\n    const statusIcon = statusIcons[command.status];\n    // Limit output lines in split mode\n    const maxLines = mode === 'split' ? 10 : 50;\n    const displayLines = detailed\n        ? command.output\n        : command.output.slice(0, maxLines);\n    const hasMore = command.output.length > displayLines.length;\n    return (React.createElement(Box, { flexDirection: \"column\", marginTop: 1, marginBottom: 1 },\n        React.createElement(Box, null,\n            React.createElement(Text, { color: \"cyan\", bold: true },\n                \"$ \",\n                command.command),\n            React.createElement(Text, null,\n                \" \",\n                statusIcon)),\n        displayLines.length > 0 && (React.createElement(Box, { flexDirection: \"column\", marginLeft: 2, marginTop: 1 },\n            displayLines.map((line, i) => {\n                // Detect stderr lines (prefixed with [STDERR])\n                const isStderr = line.startsWith('[STDERR]');\n                const displayLine = isStderr ? line.substring(8).trim() : line;\n                return (React.createElement(Text, { key: i, dimColor: command.status === 'running', color: isStderr ? 'red' : undefined },\n                    isStderr && '‚ö†Ô∏è  ',\n                    displayLine));\n            }),\n            hasMore && (React.createElement(Text, { dimColor: true, italic: true },\n                \"... (\",\n                command.output.length - displayLines.length,\n                \" more lines, press Ctrl+D for details)\")))),\n        command.error && (React.createElement(Box, { marginLeft: 2, marginTop: 1 },\n            React.createElement(Text, { color: \"red\" },\n                \"Error: \",\n                command.error))),\n        command.status !== 'pending' && command.status !== 'running' && (React.createElement(Box, { marginLeft: 2, marginTop: 1 },\n            React.createElement(Text, { dimColor: true },\n                command.status === 'success' ? '‚úÖ' : '‚ùå',\n                \" Completed in\",\n                ' ',\n                command.duration,\n                \"ms\",\n                command.exitCode !== undefined && ` (exit code: ${command.exitCode})`)))));\n};\nconst ExecutionStatusBar = ({ execution }) => {\n    const statusIcons = {\n        running: 'üîÑ',\n        success: '‚úÖ',\n        error: '‚ùå',\n        cancelled: '‚èπÔ∏è'\n    };\n    const statusColors = {\n        running: 'yellow',\n        success: 'green',\n        error: 'red',\n        cancelled: 'gray'\n    };\n    const duration = execution.endTime\n        ? execution.endTime.getTime() - execution.startTime.getTime()\n        : Date.now() - execution.startTime.getTime();\n    return (React.createElement(Box, { justifyContent: \"space-between\" },\n        React.createElement(Box, null,\n            React.createElement(Text, { bold: true },\n                statusIcons[execution.status],\n                \" \"),\n            React.createElement(Text, { color: statusColors[execution.status], bold: true }, execution.status.toUpperCase())),\n        React.createElement(Box, null,\n            React.createElement(Text, { dimColor: true }, \"Tool: \"),\n            React.createElement(Text, null, execution.toolName)),\n        React.createElement(Box, null,\n            React.createElement(Text, { dimColor: true }, \"Duration: \"),\n            React.createElement(Text, null,\n                (duration / 1000).toFixed(1),\n                \"s\")),\n        React.createElement(Box, null,\n            React.createElement(Text, { dimColor: true }, \"Commands: \"),\n            React.createElement(Text, null, execution.commands.length))));\n};\n// ============================================================================\n// EMPTY STATE\n// ============================================================================\nconst EmptyState = () => {\n    return (React.createElement(Box, { flexDirection: \"column\", alignItems: \"center\", justifyContent: \"center\", flexGrow: 1, paddingY: 4 },\n        React.createElement(Text, { bold: true, color: \"gray\" }, \"No executions yet\"),\n        React.createElement(Text, { dimColor: true }, \"Commands will appear here when the LLM executes tools\"),\n        React.createElement(Box, { marginTop: 2 },\n            React.createElement(Text, { dimColor: true }, \"Press \"),\n            React.createElement(Text, { color: \"cyan\", bold: true }, \"Ctrl+E\"),\n            React.createElement(Text, { dimColor: true }, \" to hide this viewer\"))));\n};\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\nimport { copyExecutionToClipboard, saveExecutionToFile } from '../../execution/execution-utils.js';\n/**\n * Copy execution to clipboard (wrapper with UI feedback)\n */\nfunction handleCopyExecution(execution) {\n    try {\n        copyExecutionToClipboard(execution);\n        // In a real implementation, show a toast notification\n        console.log('‚úÖ Execution copied to clipboard');\n    }\n    catch (error) {\n        console.error('‚ùå Failed to copy to clipboard:', error);\n    }\n}\n/**\n * Save execution to file (wrapper with UI feedback)\n */\nasync function handleSaveExecution(execution) {\n    try {\n        const filepath = await saveExecutionToFile(execution);\n        console.log(`‚úÖ Execution saved to: ${filepath}`);\n    }\n    catch (error) {\n        console.error('‚ùå Failed to save execution:', error);\n    }\n}\n//# sourceMappingURL=execution-viewer.js.map"
  },
  "dist/ui/components/command-suggestions.js": {
    "path": "dist/ui/components/command-suggestions.js",
    "hash": "80d38309979385769daed560d1e267d08c25146a2850f2d79f0850f065a47bca",
    "size": 1391,
    "timestamp": 1764704879305,
    "content": "import React, { useMemo } from \"react\";\nimport { Box, Text } from \"ink\";\nexport const MAX_SUGGESTIONS = 8;\nexport function filterCommandSuggestions(suggestions, input) {\n    const lowerInput = input.toLowerCase();\n    return suggestions\n        .filter((s) => s.command.toLowerCase().startsWith(lowerInput))\n        .slice(0, MAX_SUGGESTIONS);\n}\nexport const CommandSuggestions = React.memo(function CommandSuggestions({ suggestions, input, selectedIndex, isVisible, }) {\n    if (!isVisible)\n        return null;\n    const filteredSuggestions = useMemo(() => filterCommandSuggestions(suggestions, input), [suggestions, input]);\n    return (React.createElement(Box, { marginTop: 1, flexDirection: \"column\" },\n        filteredSuggestions.map((suggestion, index) => (React.createElement(Box, { key: index, paddingLeft: 1 },\n            React.createElement(Text, { color: index === selectedIndex ? \"black\" : \"white\", backgroundColor: index === selectedIndex ? \"cyan\" : undefined }, suggestion.command),\n            React.createElement(Box, { marginLeft: 1 },\n                React.createElement(Text, { color: \"gray\" }, suggestion.description))))),\n        React.createElement(Box, { marginTop: 1 },\n            React.createElement(Text, { color: \"gray\", dimColor: true }, \"\\u2191\\u2193 navigate \\u2022 Enter/Tab select \\u2022 Esc cancel\"))));\n});\n//# sourceMappingURL=command-suggestions.js.map"
  },
  "dist/ui/components/model-selection.js": {
    "path": "dist/ui/components/model-selection.js",
    "hash": "0eb78058918000a85c9498174589b41627f79ce7546e858b28ede170ec3b8082",
    "size": 1037,
    "timestamp": 1764704879305,
    "content": "import React from \"react\";\nimport { Box, Text } from \"ink\";\nexport const ModelSelection = React.memo(function ModelSelection({ models, selectedIndex, isVisible, currentModel, }) {\n    if (!isVisible)\n        return null;\n    return (React.createElement(Box, { marginTop: 1, flexDirection: \"column\" },\n        React.createElement(Box, { marginBottom: 1 },\n            React.createElement(Text, { color: \"cyan\" },\n                \"Select Grok Model (current: \",\n                currentModel,\n                \"):\")),\n        models.map((modelOption, index) => (React.createElement(Box, { key: index, paddingLeft: 1 },\n            React.createElement(Text, { color: index === selectedIndex ? \"black\" : \"white\", backgroundColor: index === selectedIndex ? \"cyan\" : undefined }, modelOption.model)))),\n        React.createElement(Box, { marginTop: 1 },\n            React.createElement(Text, { color: \"gray\", dimColor: true }, \"\\u2191\\u2193 navigate \\u2022 Enter/Tab select \\u2022 Esc cancel\"))));\n});\n//# sourceMappingURL=model-selection.js.map"
  },
  "dist/ui/components/streaming-pane.js": {
    "path": "dist/ui/components/streaming-pane.js",
    "hash": "d7cfcf0e68790b41c030f3c183b4d3d110d95a53bbb5c70d4e259720ca289763",
    "size": 3178,
    "timestamp": 1764704879305,
    "content": "import React, { useEffect, useRef, useState } from \"react\";\nimport { Box, Text } from \"ink\";\nexport const StreamingPane = React.memo(function StreamingPane({ bus }) {\n    const [content, setContent] = useState(\"\");\n    const [tools, setTools] = useState(null);\n    const [toolResults, setToolResults] = useState(null);\n    const bufferRef = useRef(\"\");\n    const lastFlushRef = useRef(0);\n    useEffect(() => {\n        const onContent = (text) => {\n            bufferRef.current += text;\n            const now = Date.now();\n            if (now - lastFlushRef.current > 250 || bufferRef.current.length > 1000) {\n                setContent((prev) => prev + bufferRef.current);\n                bufferRef.current = \"\";\n                lastFlushRef.current = now;\n            }\n        };\n        const onTools = (ts) => setTools(ts);\n        const onToolResult = (tr) => setToolResults((prev) => (prev ? [...prev, tr] : [tr]));\n        const onTokenCount = (_count) => { };\n        const onDone = () => {\n            if (bufferRef.current) {\n                setContent((prev) => prev + bufferRef.current);\n                bufferRef.current = \"\";\n            }\n            // Do not clear content here; parent will finalize and push. Just keep shown until next start.\n            setTools(null);\n            setToolResults(null);\n        };\n        bus.on(\"content\", onContent);\n        bus.on(\"tools\", onTools);\n        bus.on(\"tool_result\", onToolResult);\n        bus.on(\"token_count\", onTokenCount);\n        bus.on(\"done\", onDone);\n        return () => {\n            bus.off(\"content\", onContent);\n            bus.off(\"tools\", onTools);\n            bus.off(\"tool_result\", onToolResult);\n            bus.off(\"token_count\", onTokenCount);\n            bus.off(\"done\", onDone);\n        };\n    }, [bus]);\n    if (!content && !(tools && tools.length) && !(toolResults && toolResults.length))\n        return null;\n    return (React.createElement(Box, { flexDirection: \"column\", marginTop: 1 },\n        content && (React.createElement(Box, { flexDirection: \"row\", alignItems: \"flex-start\" },\n            React.createElement(Text, { color: \"white\" }, \"\\u23FA \"),\n            React.createElement(Box, { flexDirection: \"column\", flexGrow: 1 },\n                React.createElement(Text, { color: \"white\" }, content),\n                React.createElement(Text, { color: \"cyan\" }, \"\\u2588\")))),\n        tools && tools.length > 0 && (React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" },\n            React.createElement(Text, { color: \"gray\" }, \"\\u23BF Executing tools...\"),\n            tools.map((tc, idx) => (React.createElement(Text, { key: tc.id || idx, color: \"gray\" },\n                \"\\u23BF \",\n                tc.function?.name || \"tool\"))))),\n        toolResults && toolResults.length > 0 && (React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" },\n            React.createElement(Text, { color: \"gray\" }, \"\\u23BF Tool results:\"),\n            toolResults.map((tr, idx) => (React.createElement(Text, { key: `tr_${idx}`, color: \"gray\" },\n                \"\\u23BF \",\n                tr.content.split(\"\\n\")[0])))))));\n});\n//# sourceMappingURL=streaming-pane.js.map"
  },
  "dist/ui/components/loading-spinner.js": {
    "path": "dist/ui/components/loading-spinner.js",
    "hash": "e7c4bea61890434d9e2a273924ce95de6336b12c47982f27f5f0d6d7f87a16b2",
    "size": 2127,
    "timestamp": 1764704879305,
    "content": "import React, { useState, useEffect } from \"react\";\nimport { Box, Text } from \"ink\";\nimport { formatTokenCount } from \"../../utils/token-counter.js\";\nconst loadingTexts = [\n    \"Thinking...\",\n    \"Computing...\",\n    \"Analyzing...\",\n    \"Processing...\",\n    \"Calculating...\",\n    \"Interfacing...\",\n    \"Optimizing...\",\n    \"Synthesizing...\",\n    \"Decrypting...\",\n    \"Calibrating...\",\n    \"Bootstrapping...\",\n    \"Synchronizing...\",\n    \"Compiling...\",\n    \"Downloading...\",\n];\nexport const LoadingSpinner = React.memo(function LoadingSpinner({ isActive, processingTime, tokenCount, }) {\n    const [spinnerFrame, setSpinnerFrame] = useState(0);\n    const [loadingTextIndex, setLoadingTextIndex] = useState(0);\n    useEffect(() => {\n        if (!isActive)\n            return;\n        const spinnerFrames = [\"/\", \"-\", \"\\\\\", \"|\"];\n        // Reduced frequency: 500ms instead of 250ms to reduce flickering on Windows\n        const interval = setInterval(() => {\n            setSpinnerFrame((prev) => (prev + 1) % spinnerFrames.length);\n        }, 500);\n        return () => clearInterval(interval);\n    }, [isActive]);\n    useEffect(() => {\n        if (!isActive)\n            return;\n        setLoadingTextIndex(Math.floor(Math.random() * loadingTexts.length));\n        // Increased interval: 4s instead of 2s to reduce state changes\n        const interval = setInterval(() => {\n            setLoadingTextIndex(Math.floor(Math.random() * loadingTexts.length));\n        }, 4000);\n        return () => clearInterval(interval);\n    }, [isActive]);\n    if (!isActive)\n        return null;\n    const spinnerFrames = [\"/\", \"-\", \"\\\\\", \"|\"];\n    return (React.createElement(Box, { marginTop: 1 },\n        React.createElement(Text, { color: \"cyan\" },\n            spinnerFrames[spinnerFrame],\n            \" \",\n            loadingTexts[loadingTextIndex],\n            \" \"),\n        React.createElement(Text, { color: \"gray\" },\n            \"(\",\n            processingTime,\n            \"s \\u00B7 \\u2191 \",\n            formatTokenCount(tokenCount),\n            \" tokens \\u00B7 esc to interrupt)\")));\n});\n//# sourceMappingURL=loading-spinner.js.map"
  },
  "dist/ui/components/diff-renderer.js": {
    "path": "dist/ui/components/diff-renderer.js",
    "hash": "ae7dd9133415d20dcab08947c69c64c4de68d906305eb9adffbf31a7a5ce5163",
    "size": 9402,
    "timestamp": 1764704879305,
    "content": "/**\n * Professional diff renderer component\n */\nimport React from 'react';\nimport { Box, Text } from 'ink';\nimport { Colors } from '../utils/colors.js';\nimport crypto from 'crypto';\nimport { MaxSizedBox } from '../shared/max-sized-box.js';\nfunction parseDiffWithLineNumbers(diffContent) {\n    const lines = diffContent.split('\\n');\n    const result = [];\n    let currentOldLine = 0;\n    let currentNewLine = 0;\n    let inHunk = false;\n    const hunkHeaderRegex = /^@@ -(\\d+),?\\d* \\+(\\d+),?\\d* @@/;\n    for (const line of lines) {\n        const hunkMatch = line.match(hunkHeaderRegex);\n        if (hunkMatch) {\n            currentOldLine = parseInt(hunkMatch[1], 10);\n            currentNewLine = parseInt(hunkMatch[2], 10);\n            inHunk = true;\n            result.push({ type: 'hunk', content: line });\n            // We need to adjust the starting point because the first line number applies to the *first* actual line change/context,\n            // but we increment *before* pushing that line. So decrement here.\n            currentOldLine--;\n            currentNewLine--;\n            continue;\n        }\n        if (!inHunk) {\n            // Skip standard Git header lines more robustly\n            if (line.startsWith('--- ') ||\n                line.startsWith('+++ ') ||\n                line.startsWith('diff --git') ||\n                line.startsWith('index ') ||\n                line.startsWith('similarity index') ||\n                line.startsWith('rename from') ||\n                line.startsWith('rename to') ||\n                line.startsWith('new file mode') ||\n                line.startsWith('deleted file mode'))\n                continue;\n            // If it's not a hunk or header, skip (or handle as 'other' if needed)\n            continue;\n        }\n        if (line.startsWith('+')) {\n            currentNewLine++; // Increment before pushing\n            result.push({\n                type: 'add',\n                newLine: currentNewLine,\n                content: line.substring(1),\n            });\n        }\n        else if (line.startsWith('-')) {\n            currentOldLine++; // Increment before pushing\n            result.push({\n                type: 'del',\n                oldLine: currentOldLine,\n                content: line.substring(1),\n            });\n        }\n        else if (line.startsWith(' ')) {\n            currentOldLine++; // Increment before pushing\n            currentNewLine++;\n            result.push({\n                type: 'context',\n                oldLine: currentOldLine,\n                newLine: currentNewLine,\n                content: line.substring(1),\n            });\n        }\n        else if (line.startsWith('\\\\')) {\n            // Handle \"\\ No newline at end of file\"\n            result.push({ type: 'other', content: line });\n        }\n    }\n    return result;\n}\nconst DEFAULT_TAB_WIDTH = 4; // Spaces per tab for normalization\nexport const DiffRenderer = React.memo(({ diffContent, filename, tabWidth = DEFAULT_TAB_WIDTH, availableTerminalHeight, terminalWidth = 80, }) => {\n    if (!diffContent || typeof diffContent !== 'string') {\n        return React.createElement(Text, { color: Colors.AccentYellow }, \"No diff content.\");\n    }\n    // Strip the first summary line (e.g. \"Updated file.txt with 1 addition and 2 removals\")\n    const lines = diffContent.split('\\n');\n    const firstLine = lines[0];\n    let actualDiffContent = diffContent;\n    if (firstLine && (firstLine.startsWith('Updated ') || firstLine.startsWith('Created '))) {\n        actualDiffContent = lines.slice(1).join('\\n');\n    }\n    const parsedLines = parseDiffWithLineNumbers(actualDiffContent);\n    if (parsedLines.length === 0) {\n        return React.createElement(Text, { dimColor: true }, \"No changes detected.\");\n    }\n    // Always render as diff format to show line numbers and + signs\n    const renderedOutput = renderDiffContent(parsedLines, filename, tabWidth, availableTerminalHeight, terminalWidth);\n    return React.createElement(React.Fragment, null, renderedOutput);\n});\nconst renderDiffContent = (parsedLines, filename, tabWidth = DEFAULT_TAB_WIDTH, availableTerminalHeight, terminalWidth) => {\n    // 1. Normalize whitespace (replace tabs with spaces) *before* further processing\n    const normalizedLines = parsedLines.map((line) => ({\n        ...line,\n        content: line.content.replace(/\\t/g, ' '.repeat(tabWidth)),\n    }));\n    // Filter out non-displayable lines (hunks, potentially 'other') using the normalized list\n    const displayableLines = normalizedLines.filter((l) => l.type !== 'hunk' && l.type !== 'other');\n    if (displayableLines.length === 0) {\n        return React.createElement(Text, { dimColor: true }, \"No changes detected.\");\n    }\n    // Calculate the minimum indentation across all displayable lines\n    let baseIndentation = Infinity; // Start high to find the minimum\n    for (const line of displayableLines) {\n        // Only consider lines with actual content for indentation calculation\n        if (line.content.trim() === '')\n            continue;\n        const firstCharIndex = line.content.search(/\\S/); // Find index of first non-whitespace char\n        const currentIndent = firstCharIndex === -1 ? 0 : firstCharIndex; // Indent is 0 if no non-whitespace found\n        baseIndentation = Math.min(baseIndentation, currentIndent);\n    }\n    // If baseIndentation remained Infinity (e.g., no displayable lines with content), default to 0\n    if (!isFinite(baseIndentation)) {\n        baseIndentation = 0;\n    }\n    const key = filename\n        ? `diff-box-${filename}`\n        : `diff-box-${crypto.createHash('sha1').update(JSON.stringify(parsedLines)).digest('hex')}`;\n    let lastLineNumber = null;\n    const MAX_CONTEXT_LINES_WITHOUT_GAP = 5;\n    return (React.createElement(MaxSizedBox, { maxHeight: availableTerminalHeight, maxWidth: terminalWidth, key: key }, displayableLines.reduce((acc, line, index) => {\n        // Determine the relevant line number for gap calculation based on type\n        let relevantLineNumberForGapCalc = null;\n        if (line.type === 'add' || line.type === 'context') {\n            relevantLineNumberForGapCalc = line.newLine ?? null;\n        }\n        else if (line.type === 'del') {\n            // For deletions, the gap is typically in relation to the original file's line numbering\n            relevantLineNumberForGapCalc = line.oldLine ?? null;\n        }\n        if (lastLineNumber !== null &&\n            relevantLineNumberForGapCalc !== null &&\n            relevantLineNumberForGapCalc >\n                lastLineNumber + MAX_CONTEXT_LINES_WITHOUT_GAP + 1) {\n            acc.push(React.createElement(Box, { key: `gap-${index}` },\n                React.createElement(Text, { wrap: \"truncate\" }, '‚ïê'.repeat(terminalWidth))));\n        }\n        const lineKey = `diff-line-${index}`;\n        let gutterNumStr = '';\n        let backgroundColor = undefined;\n        let prefixSymbol = ' ';\n        let dim = false;\n        switch (line.type) {\n            case 'add':\n                gutterNumStr = (line.newLine ?? '').toString();\n                backgroundColor = '#86efac'; // Light green for additions\n                prefixSymbol = '+';\n                lastLineNumber = line.newLine ?? null;\n                break;\n            case 'del':\n                gutterNumStr = (line.oldLine ?? '').toString();\n                backgroundColor = 'redBright'; // Light red for deletions\n                prefixSymbol = '-';\n                // For deletions, update lastLineNumber based on oldLine if it's advancing.\n                // This helps manage gaps correctly if there are multiple consecutive deletions\n                // or if a deletion is followed by a context line far away in the original file.\n                if (line.oldLine !== undefined) {\n                    lastLineNumber = line.oldLine;\n                }\n                break;\n            case 'context':\n                gutterNumStr = (line.newLine ?? '').toString();\n                dim = true;\n                prefixSymbol = ' ';\n                lastLineNumber = line.newLine ?? null;\n                break;\n            default:\n                return acc;\n        }\n        const displayContent = line.content.substring(baseIndentation);\n        acc.push(React.createElement(Box, { key: lineKey, flexDirection: \"row\" },\n            React.createElement(Text, { color: Colors.Gray, dimColor: dim }, gutterNumStr.padEnd(4)),\n            React.createElement(Text, { color: backgroundColor ? '#000000' : undefined, backgroundColor: backgroundColor, dimColor: !backgroundColor && dim },\n                prefixSymbol,\n                \" \"),\n            React.createElement(Text, { color: backgroundColor ? '#000000' : undefined, backgroundColor: backgroundColor, dimColor: !backgroundColor && dim, wrap: \"wrap\" }, displayContent)));\n        return acc;\n    }, [])));\n};\nconst getLanguageFromExtension = (extension) => {\n    const languageMap = {\n        js: 'javascript',\n        ts: 'typescript',\n        py: 'python',\n        json: 'json',\n        css: 'css',\n        html: 'html',\n        sh: 'bash',\n        md: 'markdown',\n        yaml: 'yaml',\n        yml: 'yaml',\n        txt: 'plaintext',\n        java: 'java',\n        c: 'c',\n        cpp: 'cpp',\n        rb: 'ruby',\n    };\n    return languageMap[extension] || null; // Return null if extension not found\n};\n//# sourceMappingURL=diff-renderer.js.map"
  },
  "dist/ui/components/chat-interface.js": {
    "path": "dist/ui/components/chat-interface.js",
    "hash": "6e3dc9019613b186b12a04caff512ebf8f1e35457e5a342067b71bf18fd285cf",
    "size": 29049,
    "timestamp": 1764704879305,
    "content": "import React, { useState, useEffect, useMemo, useRef, useCallback } from \"react\";\nimport { Box, Text, Static, useStdout } from \"ink\";\nimport { LoadingSpinner } from \"./loading-spinner.js\";\nimport { ChatHistory } from \"./chat-history.js\";\nimport { MemoizedArchived } from \"./chat-history.js\";\nimport { InputController } from \"./input-controller.js\";\nimport ConfirmationDialog from \"./confirmation-dialog.js\";\nimport { ConfirmationService, } from \"../../utils/confirmation-service.js\";\nimport ApiKeyInput from \"./api-key-input.js\";\nimport { loadChatHistory, loadState } from \"../../utils/session-manager-sqlite.js\";\nimport { getSettingsManager } from \"../../utils/settings-manager.js\";\nimport { SplitLayout } from \"./search/split-layout.js\";\nimport { SearchResults } from \"./search/search-results.js\";\nimport { parseSearchCommand, executeSearchCommand } from \"../../commands/search.js\";\nimport { sessionManager } from \"../../utils/session-manager-sqlite.js\";\nimport { generateStatusMessage } from \"../../utils/status-message.js\";\nimport { LayoutManager } from \"./layout-manager.js\";\nimport { ExecutionViewer } from \"./execution-viewer.js\";\n// Separate memoized streaming display to prevent input flickering\nconst StreamingDisplay = React.memo(({ isStreaming, streamingContent, streamingTools, streamingToolResults, }) => {\n    if (!isStreaming || (!streamingContent && (!streamingTools || streamingTools.length === 0))) {\n        return null;\n    }\n    return (React.createElement(Box, { flexDirection: \"column\", marginTop: 1 },\n        streamingContent && (React.createElement(Box, { flexDirection: \"row\", alignItems: \"flex-start\" },\n            React.createElement(Text, { color: \"white\" }, \"\\u23FA \"),\n            React.createElement(Box, { flexDirection: \"column\", flexGrow: 1 },\n                React.createElement(Text, { color: \"white\" }, streamingContent),\n                React.createElement(Text, { color: \"cyan\" }, \"\\u2588\")))),\n        streamingTools && streamingTools.length > 0 && (React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" },\n            React.createElement(Text, { color: \"gray\" }, \"\\u23BF Executing tools...\"),\n            streamingTools.map((tc, idx) => (React.createElement(Text, { key: tc.id || idx, color: \"gray\" },\n                \"\\u23BF \",\n                tc.function?.name || \"tool\"))))),\n        streamingToolResults && streamingToolResults.length > 0 && (React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" },\n            React.createElement(Text, { color: \"gray\" }, \"\\u23BF Tool results:\"),\n            streamingToolResults.map((tr, idx) => (React.createElement(Text, { key: `tr_${idx}`, color: \"gray\" },\n                \"\\u23BF \",\n                typeof tr.content === 'string' ? tr.content.split(\"\\n\")[0] : 'Result')))))));\n}, (prevProps, nextProps) => {\n    // Only re-render if streaming content actually changed\n    return (prevProps.isStreaming === nextProps.isStreaming &&\n        prevProps.streamingContent === nextProps.streamingContent &&\n        prevProps.streamingTools?.length === nextProps.streamingTools?.length &&\n        prevProps.streamingToolResults?.length === nextProps.streamingToolResults?.length);\n});\nStreamingDisplay.displayName = 'StreamingDisplay';\n// Main chat component that handles input when agent is available\nfunction ChatInterfaceWithAgent({ agent, initialMessage, initialSessionName, }) {\n    const SHOW_STATUS = true; // Show spinner and token counter\n    // Historique complet (pour l'agent)\n    const [chatHistory, setChatHistory] = useState([]);\n    // Historique STATIQUE : Tous les messages TERMIN√âS (JSONL + messages compl√©t√©s)\n    const [committedHistory, setCommittedHistory] = useState([]);\n    // Message actif EN COURS : soit user tape, soit Grok r√©pond\n    const [activeMessages, setActiveMessages] = useState([]);\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [processingTime, setProcessingTime] = useState(0);\n    const [tokenCount, setTokenCount] = useState(0);\n    const [isStreaming, setIsStreaming] = useState(false);\n    const [streamingContent, setStreamingContent] = useState(\"\");\n    const [streamingTools, setStreamingTools] = useState(null);\n    const [confirmationOptions, setConfirmationOptions] = useState(null);\n    const [streamingToolResults, setStreamingToolResults] = useState(null);\n    const scrollRef = useRef();\n    const processingStartTime = useRef(0);\n    // Debounce streaming updates to prevent input lag\n    const streamingUpdateRef = useRef(null);\n    const pendingStreamingUpdate = useRef({});\n    const confirmationService = ConfirmationService.getInstance();\n    const VISIBLE_LIMIT = 10; // Keep only last N entries in dynamic tree (rest in Static)\n    // Search mode states\n    const [searchMode, setSearchMode] = useState(false);\n    const [searchQuery, setSearchQuery] = useState('');\n    const [searchResults, setSearchResults] = useState([]);\n    const [searchFullscreen, setSearchFullscreen] = useState(false);\n    const inputInjectionRef = useRef(null);\n    // Stabilize setters with useCallback to prevent InputController re-renders\n    const stableChatHistorySetter = useCallback((value) => {\n        setChatHistory(value);\n    }, []);\n    const stableCommittedHistorySetter = useCallback((value) => {\n        setCommittedHistory(value);\n    }, []);\n    const stableActiveMessagesSetter = useCallback((value) => {\n        setActiveMessages(value);\n    }, []);\n    const stableProcessingSetter = useCallback((value) => {\n        setIsProcessing(value);\n    }, []);\n    const stableStreamingSetter = useCallback((value) => {\n        setIsStreaming(value);\n    }, []);\n    // Debounced setters for streaming to prevent input lag\n    const stableStreamingContentSetter = useCallback((value) => {\n        if (typeof value === 'function') {\n            setStreamingContent(value);\n        }\n        else {\n            // Debounce rapid updates\n            pendingStreamingUpdate.current.content = value;\n            if (streamingUpdateRef.current) {\n                clearTimeout(streamingUpdateRef.current);\n            }\n            streamingUpdateRef.current = setTimeout(() => {\n                if (pendingStreamingUpdate.current.content !== undefined) {\n                    setStreamingContent(pendingStreamingUpdate.current.content);\n                    pendingStreamingUpdate.current.content = undefined;\n                }\n            }, 100); // 100ms debounce\n        }\n    }, []);\n    const stableStreamingToolsSetter = useCallback((tools) => {\n        pendingStreamingUpdate.current.tools = tools;\n        if (streamingUpdateRef.current) {\n            clearTimeout(streamingUpdateRef.current);\n        }\n        streamingUpdateRef.current = setTimeout(() => {\n            if (pendingStreamingUpdate.current.tools !== undefined) {\n                setStreamingTools(pendingStreamingUpdate.current.tools);\n                pendingStreamingUpdate.current.tools = undefined;\n            }\n        }, 100);\n    }, []);\n    const stableStreamingToolResultsSetter = useCallback((results) => {\n        if (typeof results === 'function') {\n            setStreamingToolResults(results);\n        }\n        else {\n            pendingStreamingUpdate.current.toolResults = results;\n            if (streamingUpdateRef.current) {\n                clearTimeout(streamingUpdateRef.current);\n            }\n            streamingUpdateRef.current = setTimeout(() => {\n                if (pendingStreamingUpdate.current.toolResults !== undefined) {\n                    setStreamingToolResults(pendingStreamingUpdate.current.toolResults);\n                    pendingStreamingUpdate.current.toolResults = undefined;\n                }\n            }, 100);\n        }\n    }, []);\n    const stableTokenCountSetter = useCallback((count) => {\n        pendingStreamingUpdate.current.tokenCount = count;\n        if (streamingUpdateRef.current) {\n            clearTimeout(streamingUpdateRef.current);\n        }\n        streamingUpdateRef.current = setTimeout(() => {\n            if (pendingStreamingUpdate.current.tokenCount !== undefined) {\n                setTokenCount(pendingStreamingUpdate.current.tokenCount);\n                pendingStreamingUpdate.current.tokenCount = undefined;\n            }\n        }, 200); // Token count can be even slower\n    }, []);\n    // Handle search command\n    const handleSearchCommand = useCallback((input) => {\n        const searchCmd = parseSearchCommand(input);\n        if (searchCmd) {\n            // Get current session ID\n            const currentSession = sessionManager.getCurrentSession();\n            const sessionId = currentSession?.id;\n            // Execute search\n            const results = executeSearchCommand(searchCmd, sessionId);\n            // Update search state\n            setSearchQuery(searchCmd.query);\n            setSearchResults(results);\n            setSearchMode(true);\n            return true; // Command handled\n        }\n        return false; // Not a search command\n    }, []);\n    // Close search mode\n    const handleCloseSearch = useCallback(() => {\n        setSearchMode(false);\n        setSearchQuery('');\n        setSearchResults([]);\n        setSearchFullscreen(false);\n    }, []);\n    // Toggle fullscreen for search results\n    const handleToggleFullscreen = useCallback(() => {\n        setSearchFullscreen(prev => !prev);\n    }, []);\n    // Paste to input (from clipboard via Ctrl+P in search)\n    const handlePasteToInput = useCallback((text) => {\n        if (inputInjectionRef.current) {\n            inputInjectionRef.current(text);\n        }\n    }, []);\n    const stableProcessingTimeSetter = useCallback((time) => {\n        setProcessingTime(time);\n    }, []);\n    // Cleanup streaming timers on unmount\n    useEffect(() => {\n        return () => {\n            if (streamingUpdateRef.current) {\n                clearTimeout(streamingUpdateRef.current);\n            }\n        };\n    }, []);\n    // Input is handled by InputController to avoid rerendering parent on each keystroke\n    // Track if status was already added (to avoid duplicates in React strict mode)\n    const statusAddedRef = useRef(false);\n    useEffect(() => {\n        // Avoid duplicate execution in React strict mode\n        if (statusAddedRef.current)\n            return;\n        statusAddedRef.current = true;\n        (async () => {\n            try {\n                const manager = getSettingsManager();\n                const persistSession = manager.getProjectSetting(\"persistSession\");\n                const autoRestoreSession = manager.getProjectSetting(\"autoRestoreSession\");\n                if (persistSession !== false && autoRestoreSession !== false) {\n                    const entries = await loadChatHistory();\n                    // Generate status message using the same logic as /status command\n                    let statusMessage = null;\n                    try {\n                        statusMessage = generateStatusMessage(agent);\n                    }\n                    catch (error) {\n                        console.error('Failed to generate status message:', error);\n                    }\n                    if (entries.length > 0) {\n                        // Historique JSONL ‚Üí STATIQUE (messages termin√©s)\n                        const historyToSet = statusMessage ? [...entries, statusMessage] : entries;\n                        setCommittedHistory(historyToSet);\n                        setChatHistory(historyToSet);\n                        // Restore agent context\n                        agent.restoreFromHistory(entries);\n                    }\n                    else {\n                        // New session\n                        const historyToSet = statusMessage ? [statusMessage] : [];\n                        setCommittedHistory(historyToSet);\n                        setChatHistory(historyToSet);\n                        // Set initial session name if provided\n                        if (initialSessionName) {\n                            try {\n                                const currentSession = sessionManager.getCurrentSession();\n                                if (currentSession) {\n                                    sessionManager.renameSession(currentSession.id, initialSessionName);\n                                }\n                            }\n                            catch (error) {\n                                console.error('Failed to set initial session name:', error);\n                            }\n                        }\n                    }\n                    // Restore model state if saved (optional)\n                    const state = await loadState();\n                    if (state?.model) {\n                        agent.setModel(state.model);\n                    }\n                }\n                else {\n                    setCommittedHistory([]);\n                    setChatHistory([]);\n                }\n            }\n            catch (error) {\n                console.error('Session load error:', error);\n                setChatHistory([]);\n            }\n        })();\n    }, [agent, initialSessionName]);\n    // Le logo est maintenant affich√© AVANT le d√©marrage d'Ink dans index.ts\n    // Plus besoin de le g√©n√©rer ici !\n    // Extraire les messages EN COURS (pas encore committ√©s dans l'historique statique)\n    useEffect(() => {\n        // Messages actifs = tous les messages qui ne sont PAS encore dans committedHistory\n        const activeCount = chatHistory.length - committedHistory.length;\n        if (activeCount > 0) {\n            const active = chatHistory.slice(-activeCount);\n            setActiveMessages(active);\n        }\n        else {\n            setActiveMessages([]);\n        }\n    }, [chatHistory, committedHistory]);\n    // Fonction pour \"commit\" un message dans l'historique statique\n    const commitMessage = useCallback((entry) => {\n        setCommittedHistory(prev => [...prev, entry]);\n    }, []);\n    // Track if we're in the middle of a switch to prevent auto-commit\n    const isSwitchingRef = useRef(false);\n    // Commit automatique quand un message est termin√©\n    useEffect(() => {\n        // Si on n'est pas en train de streamer et qu'il y a des messages actifs\n        // ET qu'on n'est PAS en train de switcher de session\n        if (!isStreaming && !isProcessing && activeMessages.length > 0 && !isSwitchingRef.current) {\n            // Commit tous les messages actifs dans l'historique statique\n            setCommittedHistory(prev => [...prev, ...activeMessages]);\n            setActiveMessages([]);\n        }\n    }, [isStreaming, isProcessing, activeMessages]);\n    // Process initial message if provided (streaming for faster feedback)\n    useEffect(() => {\n        if (initialMessage && agent) {\n            const userEntry = {\n                type: \"user\",\n                content: initialMessage,\n                timestamp: new Date(),\n            };\n            setChatHistory([userEntry]);\n            const processInitialMessage = async () => {\n                setIsProcessing(true);\n                setIsStreaming(true);\n                setStreamingContent(\"\");\n                setStreamingTools(null);\n                setStreamingToolResults(null);\n                try {\n                    let hasStarted = false;\n                    const pendingBufferRef = { text: \"\" };\n                    const lastFlushRef = { t: 0 };\n                    const pendingToolResults = [];\n                    // Newline-gated flush (like Codex) - flush on newline OR timeout\n                    const flush = () => {\n                        if (!pendingBufferRef.text)\n                            return;\n                        const appendText = pendingBufferRef.text;\n                        pendingBufferRef.text = \"\";\n                        setStreamingContent((prev) => prev + appendText);\n                    };\n                    for await (const chunk of agent.processUserMessageStream(initialMessage)) {\n                        switch (chunk.type) {\n                            case \"content\":\n                                if (chunk.content) {\n                                    hasStarted = true;\n                                    pendingBufferRef.text += chunk.content;\n                                    // Flush immediately if newline (like Codex!)\n                                    if (chunk.content.includes('\\n')) {\n                                        flush();\n                                        lastFlushRef.t = Date.now();\n                                    }\n                                    else {\n                                        // Fallback: flush after 800ms for content without newlines\n                                        const now = Date.now();\n                                        if (now - lastFlushRef.t > 800) {\n                                            flush();\n                                            lastFlushRef.t = now;\n                                        }\n                                    }\n                                }\n                                break;\n                            case \"token_count\":\n                                if (SHOW_STATUS && chunk.tokenCount !== undefined) {\n                                    setTokenCount(chunk.tokenCount);\n                                }\n                                break;\n                            case \"tool_calls\":\n                                if (chunk.toolCalls) {\n                                    setStreamingTools(chunk.toolCalls);\n                                }\n                                break;\n                            case \"tool_result\":\n                                if (chunk.toolCall && chunk.toolResult) {\n                                    const toolResultEntry = {\n                                        type: \"tool_result\",\n                                        content: chunk.toolResult.success\n                                            ? chunk.toolResult.output || \"Success\"\n                                            : chunk.toolResult.error || \"Error occurred\",\n                                        timestamp: new Date(),\n                                        toolCall: chunk.toolCall,\n                                        toolResult: chunk.toolResult,\n                                    };\n                                    pendingToolResults.push(toolResultEntry);\n                                    setStreamingToolResults((prev) => (prev ? [...prev, toolResultEntry] : [toolResultEntry]));\n                                }\n                                break;\n                            case \"done\":\n                                flush();\n                                if (hasStarted) {\n                                    setStreamingContent((current) => {\n                                        if (current) {\n                                            const finalEntry = {\n                                                type: \"assistant\",\n                                                content: current,\n                                                timestamp: new Date(),\n                                            };\n                                            setChatHistory((prev) => [...prev, finalEntry, ...pendingToolResults]);\n                                        }\n                                        return \"\";\n                                    });\n                                }\n                                setStreamingTools(null);\n                                setStreamingToolResults(null);\n                                setIsStreaming(false);\n                                break;\n                        }\n                    }\n                }\n                catch (error) {\n                    const errorEntry = {\n                        type: \"assistant\",\n                        content: `Error: ${error.message}`,\n                        timestamp: new Date(),\n                    };\n                    setChatHistory((prev) => [...prev, errorEntry]);\n                    setIsStreaming(false);\n                }\n                setIsProcessing(false);\n                processingStartTime.current = 0;\n            };\n            processInitialMessage();\n        }\n    }, [initialMessage, agent]);\n    useEffect(() => {\n        const handleConfirmationRequest = (options) => {\n            setConfirmationOptions(options);\n        };\n        confirmationService.on(\"confirmation-requested\", handleConfirmationRequest);\n        return () => {\n            confirmationService.off(\"confirmation-requested\", handleConfirmationRequest);\n        };\n    }, [confirmationService]);\n    useEffect(() => {\n        if (!SHOW_STATUS)\n            return; // Disable processing time updates when status is hidden\n        if (!isProcessing && !isStreaming) {\n            setProcessingTime(0);\n            return;\n        }\n        if (processingStartTime.current === 0) {\n            processingStartTime.current = Date.now();\n        }\n        const interval = setInterval(() => {\n            setProcessingTime(Math.floor((Date.now() - processingStartTime.current) / 1000));\n        }, 1000);\n        return () => clearInterval(interval);\n    }, [isProcessing, isStreaming]);\n    const handleConfirmation = (dontAskAgain) => {\n        confirmationService.confirmOperation(true, dontAskAgain);\n        setConfirmationOptions(null);\n    };\n    const handleRejection = (feedback) => {\n        confirmationService.rejectOperation(feedback);\n        setConfirmationOptions(null);\n        // Reset processing states when operation is cancelled\n        setIsProcessing(false);\n        setIsStreaming(false);\n        setTokenCount(0);\n        setProcessingTime(0);\n        processingStartTime.current = 0;\n    };\n    // Tips uniquement si pas d'historique au d√©marrage\n    const showTips = committedHistory.length === 0 && !confirmationOptions;\n    // Chat view content (reused in both normal and split modes)\n    const chatViewContent = (React.createElement(Box, { flexDirection: \"column\", height: searchMode ? \"100%\" : undefined, overflow: searchMode ? \"hidden\" : undefined },\n        showTips && !searchMode && (React.createElement(Box, { flexDirection: \"column\" },\n            React.createElement(Text, { color: \"cyan\", bold: true }, \"Tips for getting started:\"),\n            React.createElement(Box, { flexDirection: \"column\" },\n                React.createElement(Text, { color: \"gray\" }, \"1. Ask questions, edit files, or run commands.\"),\n                React.createElement(Text, { color: \"gray\" }, \"2. Be specific for the best results.\"),\n                React.createElement(Text, { color: \"gray\" }, \"3. Create GROK.md files to customize your interactions with Grok.\"),\n                React.createElement(Text, { color: \"gray\" }, \"4. Press Shift+Tab to toggle auto-edit mode.\"),\n                React.createElement(Text, { color: \"gray\" }, \"5. /help for more information.\")))),\n        React.createElement(Box, { flexDirection: \"column\", ref: searchMode ? undefined : scrollRef, flexGrow: 1, overflow: searchMode ? \"hidden\" : undefined },\n            React.createElement(Static, { items: searchMode ? committedHistory.slice(-10) : committedHistory }, (entry, index) => (React.createElement(MemoizedArchived, { key: `committed-${entry.timestamp.getTime()}-${index}`, entry: entry }))),\n            React.createElement(ChatHistory, { entries: activeMessages, isConfirmationActive: !!confirmationOptions }),\n            React.createElement(StreamingDisplay, { isStreaming: isStreaming, streamingContent: streamingContent, streamingTools: streamingTools, streamingToolResults: streamingToolResults })),\n        confirmationOptions && (React.createElement(ConfirmationDialog, { operation: confirmationOptions.operation, filename: confirmationOptions.filename, showVSCodeOpen: confirmationOptions.showVSCodeOpen, content: confirmationOptions.content, onConfirm: handleConfirmation, onReject: handleRejection })),\n        !confirmationOptions && !searchMode && (React.createElement(React.Fragment, null,\n            SHOW_STATUS && (React.createElement(LoadingSpinner, { isActive: isProcessing || isStreaming, processingTime: processingTime, tokenCount: tokenCount })),\n            React.createElement(InputController, { agent: agent, chatHistory: chatHistory, setChatHistory: stableChatHistorySetter, setCommittedHistory: stableCommittedHistorySetter, setActiveMessages: stableActiveMessagesSetter, isSwitchingRef: isSwitchingRef, setIsProcessing: stableProcessingSetter, setIsStreaming: stableStreamingSetter, setStreamingContent: stableStreamingContentSetter, setStreamingTools: stableStreamingToolsSetter, setStreamingToolResults: stableStreamingToolResultsSetter, setTokenCount: stableTokenCountSetter, setProcessingTime: stableProcessingTimeSetter, processingStartTime: processingStartTime, isProcessing: isProcessing, isStreaming: isStreaming, isConfirmationActive: !!confirmationOptions, searchMode: searchMode, onSearchCommand: handleSearchCommand, inputInjectionRef: inputInjectionRef }))),\n        !confirmationOptions && searchMode && (React.createElement(Box, { borderStyle: \"single\", borderColor: \"cyan\", paddingX: 1, marginTop: 1 },\n            React.createElement(Text, { color: \"cyan\", bold: true }, \"\\uD83D\\uDD0D Search Mode Active\"),\n            React.createElement(Text, { dimColor: true },\n                \" \",\n                \"\\u2022 Use \\u2191/\\u2193 to navigate results \\u2022 Enter to expand \\u2022 Ctrl+S to copy \\u2022 Esc to close\")))));\n    // Get terminal height for fixed viewport (prevent stacking on scroll)\n    const { stdout: mainStdout } = useStdout();\n    const terminalHeight = mainStdout?.rows || 24;\n    // Get execution viewer settings\n    const executionViewerSettings = useMemo(() => {\n        try {\n            const manager = getSettingsManager();\n            return manager.getExecutionViewerSettings();\n        }\n        catch {\n            return {\n                enabled: true,\n                defaultMode: 'hidden',\n                autoShow: true,\n                splitRatio: 0.6,\n                layout: 'horizontal',\n            };\n        }\n    }, []);\n    // Determine final content based on search mode and execution viewer\n    const finalContent = useMemo(() => {\n        if (searchMode) {\n            // Search mode takes precedence - use existing search split layout\n            return searchFullscreen ? (React.createElement(SearchResults, { query: searchQuery, results: searchResults, onClose: handleCloseSearch, onPasteToInput: handlePasteToInput, onToggleFullscreen: handleToggleFullscreen, fullscreen: true })) : (React.createElement(SplitLayout, { left: chatViewContent, right: React.createElement(SearchResults, { query: searchQuery, results: searchResults, onClose: handleCloseSearch, onPasteToInput: handlePasteToInput, onToggleFullscreen: handleToggleFullscreen, fullscreen: false }), splitRatio: 0.5 }));\n        }\n        // Normal mode - wrap with LayoutManager if execution viewer is enabled\n        if (executionViewerSettings.enabled) {\n            return (React.createElement(LayoutManager, { conversation: chatViewContent, executionViewer: React.createElement(ExecutionViewer, { mode: \"split\" }), config: {\n                    defaultMode: executionViewerSettings.defaultMode,\n                    autoShow: executionViewerSettings.autoShow,\n                    autoHide: executionViewerSettings.autoHide,\n                    autoHideDelay: executionViewerSettings.autoHideDelay,\n                    splitRatio: executionViewerSettings.splitRatio,\n                    layout: executionViewerSettings.layout,\n                } }));\n        }\n        // Execution viewer disabled - show conversation only\n        return chatViewContent;\n    }, [\n        searchMode,\n        searchFullscreen,\n        searchQuery,\n        searchResults,\n        handleCloseSearch,\n        handlePasteToInput,\n        handleToggleFullscreen,\n        chatViewContent,\n        executionViewerSettings,\n    ]);\n    return (React.createElement(Box, { flexDirection: \"column\", paddingX: 2, height: searchMode ? terminalHeight : undefined, overflow: searchMode ? \"hidden\" : undefined }, finalContent));\n}\n// Main component that handles API key input or chat interface\nexport default function ChatInterface({ agent, initialMessage, startupConfig, }) {\n    const [currentAgent, setCurrentAgent] = useState(agent || null);\n    const [sessionName, setSessionName] = useState(undefined);\n    const handleApiKeySet = (newAgent, initialSessionName) => {\n        setCurrentAgent(newAgent);\n        setSessionName(initialSessionName);\n    };\n    if (!currentAgent) {\n        return (React.createElement(ApiKeyInput, { onApiKeySet: handleApiKeySet, startupConfig: startupConfig, initialMessage: initialMessage }));\n    }\n    return (React.createElement(ChatInterfaceWithAgent, { agent: currentAgent, initialMessage: initialMessage, initialSessionName: sessionName }));\n}\n//# sourceMappingURL=chat-interface.js.map"
  },
  "dist/ui/components/input-controller.js": {
    "path": "dist/ui/components/input-controller.js",
    "hash": "ef43316112f50cd86646a663f0ee349310293a1b0f8f2c9527b5a11fbb5e0d8b",
    "size": 3625,
    "timestamp": 1764704879305,
    "content": "import React from \"react\";\nimport { Box, Text } from \"ink\";\nimport { useInputHandler } from \"../../hooks/use-input-handler.js\";\nimport { ChatInput } from \"./chat-input.js\";\nimport { CommandSuggestions } from \"./command-suggestions.js\";\nimport { ModelSelection } from \"./model-selection.js\";\nimport { MCPStatus } from \"./mcp-status.js\";\n// This component encapsulates input state and handlers to avoid rerendering the parent on every keystroke\n// Memoized to prevent unnecessary re-renders when chat history updates\nconst InputControllerComponent = (props) => {\n    const { agent, chatHistory, setChatHistory, setCommittedHistory, setActiveMessages, isSwitchingRef, setIsProcessing, setIsStreaming, setStreamingContent, setStreamingTools, setStreamingToolResults, setTokenCount, setProcessingTime, processingStartTime, isProcessing, isStreaming, isConfirmationActive, searchMode, onSearchCommand, inputInjectionRef, } = props;\n    const { input, cursorPosition, showCommandSuggestions, selectedCommandIndex, showModelSelection, selectedModelIndex, commandSuggestions, availableModels, autoEditEnabled, } = useInputHandler({\n        agent,\n        chatHistory,\n        setChatHistory,\n        setCommittedHistory,\n        setActiveMessages,\n        isSwitchingRef,\n        setIsProcessing,\n        setIsStreaming,\n        setStreamingContent,\n        setStreamingTools,\n        setStreamingToolResults,\n        setTokenCount,\n        setProcessingTime,\n        processingStartTime,\n        isProcessing,\n        isStreaming,\n        isConfirmationActive,\n        searchMode,\n        onSearchCommand,\n        inputInjectionRef,\n    });\n    return (React.createElement(React.Fragment, null,\n        React.createElement(ChatInput, { input: input, cursorPosition: cursorPosition, isProcessing: isProcessing, isStreaming: isStreaming }),\n        React.createElement(Box, { flexDirection: \"row\", marginTop: 1 },\n            React.createElement(Box, { marginRight: 2 },\n                React.createElement(Text, { color: \"cyan\" },\n                    autoEditEnabled ? \"‚ñ∂\" : \"‚è∏\",\n                    \" auto-edit:\",\n                    \" \",\n                    autoEditEnabled ? \"on\" : \"off\"),\n                React.createElement(Text, { color: \"gray\", dimColor: true },\n                    \" \",\n                    \"(shift + tab)\")),\n            React.createElement(Box, { marginRight: 2 },\n                React.createElement(Text, { color: \"yellow\" },\n                    \"\\u224B \",\n                    agent.getCurrentModel())),\n            React.createElement(MCPStatus, null)),\n        React.createElement(CommandSuggestions, { suggestions: commandSuggestions, input: input, selectedIndex: selectedCommandIndex, isVisible: showCommandSuggestions }),\n        React.createElement(ModelSelection, { models: availableModels, selectedIndex: selectedModelIndex, isVisible: showModelSelection, currentModel: agent.getCurrentModel() })));\n};\n// Export memoized version that only re-renders when necessary props change\nexport const InputController = React.memo(InputControllerComponent, (prevProps, nextProps) => {\n    // Only re-render if these critical props change\n    // chatHistory changes should NOT trigger re-render (only used for input processing, not display)\n    return (prevProps.isProcessing === nextProps.isProcessing &&\n        prevProps.isStreaming === nextProps.isStreaming &&\n        prevProps.isConfirmationActive === nextProps.isConfirmationActive &&\n        prevProps.agent === nextProps.agent &&\n        prevProps.chatHistory.length === nextProps.chatHistory.length);\n});\n//# sourceMappingURL=input-controller.js.map"
  },
  "dist/ui/components/api-key-input.js": {
    "path": "dist/ui/components/api-key-input.js",
    "hash": "5c363007bb14f2303da491e562b9ef9b8cfa4ff8602189a2cdfd27c9b68df10d",
    "size": 27120,
    "timestamp": 1764704879305,
    "content": "import React, { useState, useCallback } from \"react\";\nimport { Box, Text, useInput, useApp } from \"ink\";\nimport { GrokAgent } from \"../../agent/grok-agent.js\";\nimport { getSettingsManager } from \"../../utils/settings-manager.js\";\nimport { providerManager } from \"../../utils/provider-manager.js\";\nimport { getAllModelsFlat, fuzzyMatch, formatModelMenu } from \"./api-key-input-helpers.js\";\nimport { CommandSuggestions } from \"./command-suggestions.js\";\n// Available commands during initialization phase\nconst INIT_COMMANDS = [\n    { command: \"/models\", description: \"List available models (‚Üë/‚Üì to navigate)\" },\n    { command: \"/apikey\", description: \"Set API key: /apikey <provider> <key>\" },\n    { command: \"/model-default\", description: \"Set global default model\" },\n    { command: \"/session_name\", description: \"Set initial session name\" },\n    { command: \"/help\", description: \"Show help message\" },\n    { command: \"/exit\", description: \"Quit application\" },\n];\n/**\n * Filter commands based on user input\n * Returns matching commands or all commands if input is just \"/\"\n */\nfunction filterCommands(input) {\n    const trimmed = input.trim();\n    // Show all commands if user types just \"/\"\n    if (trimmed === \"/\") {\n        return INIT_COMMANDS;\n    }\n    // Filter commands that start with the input\n    if (trimmed.startsWith(\"/\")) {\n        const query = trimmed.toLowerCase();\n        return INIT_COMMANDS.filter(cmd => cmd.command.toLowerCase().startsWith(query));\n    }\n    return [];\n}\n/**\n * Format command suggestions for display\n */\nfunction formatCommandSuggestions(commands) {\n    if (commands.length === 0)\n        return \"\";\n    const header = commands.length === INIT_COMMANDS.length\n        ? \"üìã **Available commands:**\\n\\n\"\n        : \"üí° **Did you mean:**\\n\\n\";\n    const list = commands\n        .map(cmd => `‚Ä¢ \\`${cmd.command}\\` - ${cmd.description}`)\n        .join(\"\\n\");\n    return header + list;\n}\n/**\n * Configuration interface shown when no agent is available.\n * Allows users to configure model and API key interactively.\n */\nexport default function ApiKeyInput({ onApiKeySet, startupConfig, initialMessage }) {\n    const [messages, setMessages] = useState(() => {\n        // Show initial configuration message\n        const configMessage = initialMessage ||\n            \"‚öôÔ∏è  **Configuration Required**\\n\\n\" +\n                \"No model is configured.\\n\\n\" +\n                \"**Quick Start:**\\n\" +\n                \"‚Ä¢ Type `/` to see all available commands\\n\" +\n                \"‚Ä¢ Type `/mod` to filter commands (e.g., /models, /model-default)\\n\" +\n                \"‚Ä¢ Use arrow keys (‚Üë/‚Üì) to navigate model menu\\n\\n\" +\n                \"**Example:**\\n\" +\n                \"```\\n\" +\n                \"/apikey openai sk-proj-...\\n\" +\n                \"/models deep\\n\" +\n                \"/model-default gpt-4o\\n\" +\n                \"```\\n\\n\" +\n                \"üí° **Tip:** Start by typing `/` to discover all commands!\";\n        return [{ type: 'system', content: configMessage }];\n    });\n    const [input, setInput] = useState('');\n    const [isProcessing, setIsProcessing] = useState(false);\n    // New states for interactive model menu (Option D - Hybrid)\n    const [showModelMenu, setShowModelMenu] = useState(false);\n    const [selectedModelIndex, setSelectedModelIndex] = useState(0);\n    const [modelList, setModelList] = useState([]);\n    // Store initial session name (if user sets it before configuration completes)\n    const [pendingSessionName, setPendingSessionName] = useState(undefined);\n    // Command suggestions (real-time autocomplete)\n    const [showCommandSuggestions, setShowCommandSuggestions] = useState(false);\n    const [selectedCommandIndex, setSelectedCommandIndex] = useState(0);\n    const { exit } = useApp();\n    const handleSubmit = useCallback(async () => {\n        if (!input.trim() || isProcessing)\n            return;\n        const userInput = input.trim();\n        // Handle command suggestions when user types just \"/\"\n        if (userInput === \"/\") {\n            const suggestions = formatCommandSuggestions(INIT_COMMANDS);\n            setMessages(prev => [...prev,\n                { type: 'user', content: userInput },\n                { type: 'system', content: suggestions }\n            ]);\n            setInput('');\n            return;\n        }\n        // Handle partial command matching for suggestions\n        if (userInput.startsWith(\"/\") && !userInput.includes(\" \")) {\n            const matchedCommands = filterCommands(userInput);\n            // If we have matches but it's not an exact command, show suggestions\n            const isExactCommand = INIT_COMMANDS.some(cmd => cmd.command === userInput);\n            if (matchedCommands.length > 0 && !isExactCommand && matchedCommands.length < INIT_COMMANDS.length) {\n                const suggestions = formatCommandSuggestions(matchedCommands);\n                setMessages(prev => [...prev,\n                    { type: 'user', content: userInput },\n                    { type: 'system', content: suggestions }\n                ]);\n                setInput('');\n                return;\n            }\n        }\n        setInput(''); // Clear input immediately\n        // Add user message\n        setMessages(prev => [...prev, { type: 'user', content: userInput }]);\n        setIsProcessing(true);\n        try {\n            // Handle /models command (Option D: Hybrid with fuzzy matching + interactive menu)\n            if (userInput === '/models' || userInput.startsWith('/models ')) {\n                const parts = userInput.split(/\\s+/);\n                const query = parts.slice(1).join(' '); // Get search query if any\n                const allModels = getAllModelsFlat();\n                const matchedModels = query ? fuzzyMatch(query, allModels) : allModels;\n                if (matchedModels.length === 0) {\n                    // No matches found\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: `‚ùå No models found matching \"${query}\"\\n\\nUse /models to see all available models.`\n                        }]);\n                }\n                else if (matchedModels.length === 1 && query) {\n                    // Exactly 1 match with a query - suggest it\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: `‚úÖ Found: **${matchedModels[0]}**\\n\\nUse this command to set it as default:\\n\\`/model-default ${matchedModels[0]}\\``\n                        }]);\n                }\n                else {\n                    // Multiple matches or no query - show interactive menu\n                    setModelList(matchedModels);\n                    setSelectedModelIndex(0);\n                    setShowModelMenu(true);\n                    const menuContent = formatModelMenu(matchedModels, 0);\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: menuContent\n                        }]);\n                }\n            }\n            // Handle /apikey command\n            else if (userInput.startsWith('/apikey ')) {\n                const parts = userInput.split(/\\s+/);\n                if (parts.length < 3) {\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: \"‚ùå Usage: `/apikey <provider> <your-api-key>`\\n\\nExample: `/apikey openai sk-proj-...`\"\n                        }]);\n                }\n                else {\n                    const provider = parts[1].toLowerCase();\n                    const apiKey = parts.slice(2).join(' '); // In case key has spaces\n                    const providerConfig = providerManager.getProvider(provider);\n                    if (!providerConfig) {\n                        const available = Object.keys(providerManager.getAllProviders()).join(', ');\n                        setMessages(prev => [...prev, {\n                                type: 'system',\n                                content: `‚ùå Unknown provider: ${provider}\\n\\nAvailable providers: ${available}`\n                            }]);\n                    }\n                    else {\n                        // Save API key using settings manager\n                        const manager = getSettingsManager();\n                        const apiKeys = manager.getApiKeys() || {};\n                        apiKeys[provider] = apiKey;\n                        manager.updateUserSetting('apiKeys', apiKeys);\n                        // Check if we have a default model for this provider\n                        const currentModel = startupConfig?.model || manager.getCurrentModel();\n                        const modelProvider = providerManager.detectProvider(currentModel);\n                        if (modelProvider === provider) {\n                            // We can initialize the agent now!\n                            const baseURL = providerConfig.baseURL;\n                            const agent = new GrokAgent(apiKey, baseURL, currentModel);\n                            setMessages(prev => [...prev, {\n                                    type: 'system',\n                                    content: `‚úÖ API key saved for ${provider}\\nüöÄ Initializing agent with ${currentModel}...`\n                                }]);\n                            // Small delay to show the message\n                            setTimeout(() => {\n                                onApiKeySet(agent, pendingSessionName);\n                            }, 500);\n                        }\n                        else {\n                            // API key saved, but need to select a model\n                            setMessages(prev => [...prev, {\n                                    type: 'system',\n                                    content: `‚úÖ API key saved for ${provider}\\n\\n` +\n                                        `**Next step:** Set a default model\\n` +\n                                        `/model-default ${providerConfig.models[0]}\\n\\n` +\n                                        `Or use /models to see all available models.`\n                                }]);\n                        }\n                    }\n                }\n            }\n            // Handle /model-default command (Option D: with fuzzy matching)\n            else if (userInput.startsWith('/model-default ')) {\n                const parts = userInput.split(/\\s+/);\n                if (parts.length < 2) {\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: \"‚ùå Usage: `/model-default <model-name>`\\n\\nExample: `/model-default gpt-4o`\\n\\n**Tip:** Use `/models <query>` to find models\"\n                        }]);\n                }\n                else {\n                    const modelQuery = parts.slice(1).join(' ');\n                    // Try fuzzy matching first\n                    const allModels = getAllModelsFlat();\n                    const matches = fuzzyMatch(modelQuery, allModels);\n                    if (matches.length === 0) {\n                        // No matches\n                        setMessages(prev => [...prev, {\n                                type: 'system',\n                                content: `‚ùå No models found matching \"${modelQuery}\"\\n\\nUse /models to see all available models.`\n                            }]);\n                    }\n                    else if (matches.length === 1) {\n                        // Exactly 1 match - use it\n                        const model = matches[0];\n                        const provider = providerManager.detectProvider(model);\n                        if (!provider) {\n                            setMessages(prev => [...prev, {\n                                    type: 'system',\n                                    content: `‚ùå Unknown provider for model: ${model}`\n                                }]);\n                        }\n                        else {\n                            // Save default model\n                            const manager = getSettingsManager();\n                            manager.updateUserSetting('defaultModel', model);\n                            // Check if we have an API key for this provider\n                            const apiKey = manager.getApiKeyForProvider(provider);\n                            if (apiKey) {\n                                // We can initialize the agent now!\n                                const providerConfig = providerManager.getProviderForModel(model);\n                                const baseURL = providerConfig?.baseURL || 'https://api.x.ai/v1';\n                                const agent = new GrokAgent(apiKey, baseURL, model);\n                                setMessages(prev => [...prev, {\n                                        type: 'system',\n                                        content: `‚úÖ Default model set to **${model}**\\nüöÄ Initializing agent...`\n                                    }]);\n                                // Small delay to show the message\n                                setTimeout(() => {\n                                    onApiKeySet(agent, pendingSessionName);\n                                }, 500);\n                            }\n                            else {\n                                // Model saved, but need API key\n                                setMessages(prev => [...prev, {\n                                        type: 'system',\n                                        content: `‚úÖ Default model set to **${model}**\\n\\n` +\n                                            `**Next step:** Add your ${provider} API key\\n` +\n                                            `/apikey ${provider} <your-key>`\n                                    }]);\n                            }\n                        }\n                    }\n                    else {\n                        // Multiple matches - show suggestions\n                        const suggestions = matches.slice(0, 5).map(m => `  ‚Ä¢ ${m}`).join('\\n');\n                        setMessages(prev => [...prev, {\n                                type: 'system',\n                                content: `‚ùì Multiple models match \"${modelQuery}\":\\n\\n${suggestions}\\n\\n` +\n                                    `Please be more specific or use /models to navigate interactively.`\n                            }]);\n                    }\n                }\n            }\n            // Handle /help command\n            else if (userInput === '/help') {\n                const helpMsg = \"üìñ **Configuration Help**\\n\\n\" +\n                    \"**Available commands:**\\n\" +\n                    \"‚Ä¢ `/models` - List all available models\\n\" +\n                    \"‚Ä¢ `/apikey <provider> <key>` - Set API key for a provider\\n\" +\n                    \"‚Ä¢ `/model-default <model>` - Set global default model\\n\" +\n                    \"‚Ä¢ `/session_name <name>` - Set initial session name\\n\" +\n                    \"‚Ä¢ `/help` - Show this help message\\n\" +\n                    \"‚Ä¢ `/exit` - Quit application\\n\\n\" +\n                    \"**Quick start:**\\n\" +\n                    \"1. Run `/models` to see available models\\n\" +\n                    \"2. Run `/apikey <provider> <your-key>` to add your API key\\n\" +\n                    \"3. Run `/model-default <model>` to set your preferred model\\n\";\n                setMessages(prev => [...prev, { type: 'system', content: helpMsg }]);\n            }\n            // Handle /session_name command (set initial session name before session creation)\n            else if (userInput.startsWith('/session_name ')) {\n                const parts = userInput.split(/\\s+/);\n                const sessionName = parts.slice(1).join(' ').trim();\n                if (!sessionName) {\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: `‚ùå Please provide a session name.\\n\\nUsage: /session_name <name>`\n                        }]);\n                }\n                else {\n                    setPendingSessionName(sessionName);\n                    setMessages(prev => [...prev, {\n                            type: 'system',\n                            content: `‚úÖ Session name set to: **${sessionName}**\\n\\nThis name will be used when the session is created.`\n                        }]);\n                }\n            }\n            // Handle exit (support both /exit and legacy exit/quit)\n            else if (userInput === '/exit' || userInput === 'exit' || userInput === 'quit') {\n                exit();\n            }\n            // Unknown command\n            else {\n                setMessages(prev => [...prev, {\n                        type: 'system',\n                        content: `‚ùì Unknown command. Type /help for available commands.`\n                    }]);\n            }\n        }\n        catch (error) {\n            setMessages(prev => [...prev, {\n                    type: 'system',\n                    content: `‚ùå Error: ${error.message}`\n                }]);\n        }\n        finally {\n            setIsProcessing(false);\n        }\n    }, [input, isProcessing, onApiKeySet, startupConfig, exit]);\n    // Handle keyboard input (Option D: with interactive menu navigation + command suggestions)\n    useInput((inputChar, key) => {\n        if (isProcessing)\n            return;\n        // ============================================\n        // MODE 1: Command Suggestions Navigation (Real-time autocomplete)\n        // ============================================\n        if (showCommandSuggestions) {\n            // Navigate up in suggestions\n            if (key.upArrow) {\n                setSelectedCommandIndex(prev => {\n                    const filtered = filterCommands(input);\n                    return Math.max(0, prev - 1);\n                });\n                return;\n            }\n            // Navigate down in suggestions\n            if (key.downArrow) {\n                setSelectedCommandIndex(prev => {\n                    const filtered = filterCommands(input);\n                    return Math.min(filtered.length - 1, prev + 1);\n                });\n                return;\n            }\n            // Select command with Tab or Enter\n            if (key.tab || key.return) {\n                const filtered = filterCommands(input);\n                if (filtered.length > 0 && selectedCommandIndex < filtered.length) {\n                    const selectedCommand = filtered[selectedCommandIndex];\n                    setInput(selectedCommand.command + ' ');\n                    setShowCommandSuggestions(false);\n                    setSelectedCommandIndex(0);\n                }\n                return;\n            }\n            // Cancel suggestions with Escape\n            if (key.escape) {\n                setShowCommandSuggestions(false);\n                setSelectedCommandIndex(0);\n                return;\n            }\n        }\n        // ============================================\n        // MODE 2: Interactive Model Menu Navigation\n        // ============================================\n        if (showModelMenu) {\n            // Navigate up\n            if (key.upArrow) {\n                setSelectedModelIndex(prev => {\n                    const newIdx = Math.max(0, prev - 1);\n                    // Update menu display with new selection\n                    const menuContent = formatModelMenu(modelList, newIdx);\n                    setMessages(prevMsgs => {\n                        const newMsgs = [...prevMsgs];\n                        // Replace last message (the menu) with updated version\n                        if (newMsgs.length > 0 && newMsgs[newMsgs.length - 1].type === 'system') {\n                            newMsgs[newMsgs.length - 1] = { type: 'system', content: menuContent };\n                        }\n                        return newMsgs;\n                    });\n                    return newIdx;\n                });\n                return;\n            }\n            // Navigate down\n            if (key.downArrow) {\n                setSelectedModelIndex(prev => {\n                    const newIdx = Math.min(modelList.length - 1, prev + 1);\n                    // Update menu display with new selection\n                    const menuContent = formatModelMenu(modelList, newIdx);\n                    setMessages(prevMsgs => {\n                        const newMsgs = [...prevMsgs];\n                        // Replace last message (the menu) with updated version\n                        if (newMsgs.length > 0 && newMsgs[newMsgs.length - 1].type === 'system') {\n                            newMsgs[newMsgs.length - 1] = { type: 'system', content: menuContent };\n                        }\n                        return newMsgs;\n                    });\n                    return newIdx;\n                });\n                return;\n            }\n            // Select model with Enter\n            if (key.return) {\n                const selectedModel = modelList[selectedModelIndex];\n                setShowModelMenu(false);\n                // Auto-fill /model-default command and submit\n                setInput(`/model-default ${selectedModel}`);\n                setMessages(prev => [...prev, { type: 'user', content: `/model-default ${selectedModel}` }]);\n                // Trigger handleSubmit with the selected model\n                setTimeout(() => {\n                    // Call handleSubmit logic directly\n                    setIsProcessing(true);\n                    const provider = providerManager.detectProvider(selectedModel);\n                    if (!provider) {\n                        setMessages(prev => [...prev, {\n                                type: 'system',\n                                content: `‚ùå Unknown provider for model: ${selectedModel}`\n                            }]);\n                        setIsProcessing(false);\n                    }\n                    else {\n                        // Save default model\n                        const manager = getSettingsManager();\n                        manager.updateUserSetting('defaultModel', selectedModel);\n                        // Check if we have an API key for this provider\n                        const apiKey = manager.getApiKeyForProvider(provider);\n                        if (apiKey) {\n                            // We can initialize the agent now!\n                            const providerConfig = providerManager.getProviderForModel(selectedModel);\n                            const baseURL = providerConfig?.baseURL || 'https://api.x.ai/v1';\n                            const agent = new GrokAgent(apiKey, baseURL, selectedModel);\n                            setMessages(prev => [...prev, {\n                                    type: 'system',\n                                    content: `‚úÖ Default model set to **${selectedModel}**\\nüöÄ Initializing agent...`\n                                }]);\n                            // Small delay to show the message\n                            setTimeout(() => {\n                                onApiKeySet(agent, pendingSessionName);\n                            }, 500);\n                        }\n                        else {\n                            // Model saved, but need API key\n                            setMessages(prev => [...prev, {\n                                    type: 'system',\n                                    content: `‚úÖ Default model set to **${selectedModel}**\\n\\n` +\n                                        `**Next step:** Add your ${provider} API key\\n` +\n                                        `/apikey ${provider} <your-key>`\n                                }]);\n                            setIsProcessing(false);\n                        }\n                    }\n                    setInput(''); // Clear input\n                }, 10);\n                return;\n            }\n            // Cancel menu with Escape\n            if (key.escape) {\n                setShowModelMenu(false);\n                setMessages(prev => [...prev, { type: 'system', content: '‚ùå Model selection cancelled.' }]);\n                return;\n            }\n            // Block other inputs when menu is active\n            return;\n        }\n        // ============================================\n        // MODE 3: Normal Input Mode (with real-time command suggestions)\n        // ============================================\n        if (key.return) {\n            handleSubmit();\n            return;\n        }\n        if (key.ctrl && inputChar === 'c') {\n            exit();\n            return;\n        }\n        if (key.backspace || key.delete) {\n            setInput(prev => {\n                const newInput = prev.slice(0, -1);\n                // Update command suggestions in real-time\n                if (newInput.startsWith('/') && !newInput.includes(' ')) {\n                    const filtered = filterCommands(newInput);\n                    setShowCommandSuggestions(filtered.length > 0);\n                    setSelectedCommandIndex(0);\n                }\n                else {\n                    setShowCommandSuggestions(false);\n                }\n                return newInput;\n            });\n            return;\n        }\n        if (inputChar && !key.ctrl && !key.meta) {\n            setInput(prev => {\n                const newInput = prev + inputChar;\n                // Show command suggestions when typing \"/\" or a partial command\n                if (newInput.startsWith('/') && !newInput.includes(' ')) {\n                    const filtered = filterCommands(newInput);\n                    setShowCommandSuggestions(filtered.length > 0);\n                    setSelectedCommandIndex(0);\n                }\n                else {\n                    setShowCommandSuggestions(false);\n                }\n                return newInput;\n            });\n        }\n    }, { isActive: !isProcessing });\n    return (React.createElement(Box, { flexDirection: \"column\", paddingX: 1 },\n        React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 }, messages.map((msg, idx) => (React.createElement(Box, { key: idx, flexDirection: \"column\", marginBottom: 1 }, msg.type === 'system' ? (React.createElement(Text, { color: \"cyan\" }, msg.content)) : (React.createElement(Box, null,\n            React.createElement(Text, { color: \"green\" }, \"\\u276F \"),\n            React.createElement(Text, { color: \"white\" }, msg.content))))))),\n        !isProcessing && (React.createElement(Box, null,\n            React.createElement(Text, { color: \"green\" }, \"\\u276F \"),\n            React.createElement(Text, { color: \"white\" }, input),\n            React.createElement(Text, { color: \"cyan\" }, \"\\u2588\"))),\n        React.createElement(CommandSuggestions, { suggestions: INIT_COMMANDS, input: input, selectedIndex: selectedCommandIndex, isVisible: showCommandSuggestions }),\n        isProcessing && (React.createElement(Box, null,\n            React.createElement(Text, { color: \"yellow\" }, \"\\u23F3 Processing...\")))));\n}\n//# sourceMappingURL=api-key-input.js.map"
  },
  "dist/ui/components/layout-manager.js": {
    "path": "dist/ui/components/layout-manager.js",
    "hash": "c375597a0852d5986baa52cf8b95c68a9ab658c2b94e2c7b3bef67d721522601",
    "size": 10587,
    "timestamp": 1764704879305,
    "content": "/**\n * Layout Manager Component\n *\n * Manages the 3-mode layout system:\n * - HIDDEN: Full-width conversation (no execution viewer)\n * - SPLIT: Side-by-side conversation + execution viewer (60/40)\n * - FULLSCREEN: Full-width execution viewer\n *\n * Handles automatic transitions, keyboard shortcuts, and mode persistence.\n */\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { executionManager } from '../../execution/index.js';\n// ============================================================================\n// DEFAULT CONFIG\n// ============================================================================\nconst DEFAULT_CONFIG = {\n    defaultMode: 'hidden',\n    autoShow: true,\n    autoHide: false,\n    autoHideDelay: 5000,\n    splitRatio: 0.6,\n    layout: 'horizontal'\n};\n// ============================================================================\n// LAYOUT MANAGER COMPONENT\n// ============================================================================\nexport const LayoutManager = ({ conversation, executionViewer, config: userConfig, onModeChange }) => {\n    const config = { ...DEFAULT_CONFIG, ...userConfig };\n    const [mode, setMode] = useState(config.defaultMode);\n    const [hasActiveExecution, setHasActiveExecution] = useState(false);\n    const [autoHideTimeout, setAutoHideTimeout] = useState(null);\n    /**\n     * Change mode and notify\n     */\n    const changeMode = useCallback((newMode) => {\n        setMode(newMode);\n        onModeChange?.(newMode);\n    }, [onModeChange]);\n    /**\n     * Schedule auto-hide\n     */\n    const scheduleAutoHide = useCallback(() => {\n        if (!config.autoHide)\n            return;\n        // Clear existing timeout\n        if (autoHideTimeout) {\n            clearTimeout(autoHideTimeout);\n        }\n        // Schedule new timeout\n        const timeout = setTimeout(() => {\n            if (!hasActiveExecution && mode === 'split') {\n                changeMode('hidden');\n            }\n        }, config.autoHideDelay);\n        setAutoHideTimeout(timeout);\n    }, [config.autoHide, config.autoHideDelay, hasActiveExecution, mode, autoHideTimeout, changeMode]);\n    /**\n     * Cancel auto-hide\n     */\n    const cancelAutoHide = useCallback(() => {\n        if (autoHideTimeout) {\n            clearTimeout(autoHideTimeout);\n            setAutoHideTimeout(null);\n        }\n    }, [autoHideTimeout]);\n    /**\n     * Listen to execution lifecycle\n     */\n    useEffect(() => {\n        const unsubscribeStart = executionManager.onExecutionStart(() => {\n            setHasActiveExecution(true);\n            cancelAutoHide();\n            // Auto-show viewer when execution starts\n            if (config.autoShow && mode === 'hidden') {\n                changeMode('split');\n            }\n        });\n        const unsubscribeEnd = executionManager.onExecutionEnd(() => {\n            // Check if there are still active executions\n            const stillActive = executionManager.hasActiveExecutions();\n            setHasActiveExecution(stillActive);\n            // Schedule auto-hide if configured\n            if (!stillActive) {\n                scheduleAutoHide();\n            }\n        });\n        return () => {\n            unsubscribeStart();\n            unsubscribeEnd();\n            if (autoHideTimeout) {\n                clearTimeout(autoHideTimeout);\n            }\n        };\n    }, [config.autoShow, mode, changeMode, cancelAutoHide, scheduleAutoHide, autoHideTimeout]);\n    /**\n     * Keyboard shortcuts\n     */\n    useInput((input, key) => {\n        // Ctrl+E: Toggle viewer (hidden <-> split)\n        if (key.ctrl && input === 'e') {\n            if (mode === 'hidden') {\n                changeMode('split');\n                cancelAutoHide();\n            }\n            else if (mode === 'split') {\n                changeMode('hidden');\n                cancelAutoHide();\n            }\n            // If fullscreen, do nothing (must Esc first)\n        }\n        // Ctrl+F: Fullscreen viewer (from split only)\n        if (key.ctrl && input === 'f') {\n            if (mode === 'split') {\n                changeMode('fullscreen');\n                cancelAutoHide();\n            }\n        }\n        // Esc: Exit fullscreen (back to split)\n        if (key.escape) {\n            if (mode === 'fullscreen') {\n                changeMode('split');\n            }\n        }\n        // Ctrl+Shift+E: Force hide (even during execution)\n        if (key.ctrl && key.shift && input === 'e') {\n            changeMode('hidden');\n            cancelAutoHide();\n        }\n    });\n    /**\n     * Render layout based on mode\n     */\n    return (React.createElement(Box, { flexDirection: \"column\", width: \"100%\", height: \"100%\" },\n        React.createElement(Box, { flexGrow: 1, flexDirection: \"column\" },\n            mode === 'hidden' && (React.createElement(ConversationOnly, null, conversation)),\n            mode === 'split' && (React.createElement(SplitView, { conversation: conversation, viewer: executionViewer, splitRatio: config.splitRatio, layout: config.layout })),\n            mode === 'fullscreen' && (React.createElement(FullscreenViewer, null, executionViewer))),\n        React.createElement(KeyboardHints, { mode: mode, hasExecution: hasActiveExecution })));\n};\n// ============================================================================\n// CONVERSATION ONLY VIEW\n// ============================================================================\nconst ConversationOnly = ({ children }) => {\n    return (React.createElement(Box, { flexDirection: \"column\", width: \"100%\", height: \"100%\" }, children));\n};\nconst SplitView = ({ conversation, viewer, splitRatio, layout }) => {\n    const [focused, setFocused] = useState('conversation');\n    useInput((input, key) => {\n        // Tab: Switch focus between panels\n        if (key.tab) {\n            setFocused(f => f === 'conversation' ? 'viewer' : 'conversation');\n        }\n    });\n    if (layout === 'vertical') {\n        // Vertical split (conversation top, viewer bottom)\n        return (React.createElement(Box, { flexDirection: \"column\", width: \"100%\", height: \"100%\" },\n            React.createElement(Box, { flexDirection: \"column\", borderStyle: \"single\", borderColor: focused === 'conversation' ? 'cyan' : 'gray', paddingX: 1, height: `${Math.floor(splitRatio * 100)}%` },\n                React.createElement(Box, { marginBottom: 1 },\n                    React.createElement(Text, { bold: true, color: \"cyan\" }, \"\\uD83D\\uDCAC Conversation\"),\n                    focused === 'conversation' && React.createElement(Text, { dimColor: true }, \" (focused)\")),\n                React.createElement(Box, { flexGrow: 1, flexDirection: \"column\", overflow: \"hidden\" }, conversation)),\n            React.createElement(Box, { flexDirection: \"column\", borderStyle: \"single\", borderColor: focused === 'viewer' ? 'green' : 'gray', paddingX: 1, height: `${Math.floor((1 - splitRatio) * 100)}%` },\n                React.createElement(Box, { marginBottom: 1 },\n                    React.createElement(Text, { bold: true, color: \"green\" }, \"\\uD83D\\uDD27 Execution Viewer\"),\n                    focused === 'viewer' && React.createElement(Text, { dimColor: true }, \" (focused)\")),\n                React.createElement(Box, { flexGrow: 1, flexDirection: \"column\", overflow: \"hidden\" }, viewer))));\n    }\n    // Horizontal split (conversation left, viewer right) - DEFAULT\n    return (React.createElement(Box, { width: \"100%\", height: \"100%\" },\n        React.createElement(Box, { width: `${Math.floor(splitRatio * 100)}%`, flexDirection: \"column\", borderStyle: \"single\", borderColor: focused === 'conversation' ? 'cyan' : 'gray', paddingX: 1 },\n            React.createElement(Box, { marginBottom: 1 },\n                React.createElement(Text, { bold: true, color: \"cyan\" }, \"\\uD83D\\uDCAC Conversation\"),\n                focused === 'conversation' && React.createElement(Text, { dimColor: true }, \" (focused)\")),\n            React.createElement(Box, { flexGrow: 1, flexDirection: \"column\", overflow: \"hidden\" }, conversation)),\n        React.createElement(Box, { width: `${Math.floor((1 - splitRatio) * 100)}%`, flexDirection: \"column\", borderStyle: \"single\", borderColor: focused === 'viewer' ? 'green' : 'gray', paddingX: 1 },\n            React.createElement(Box, { marginBottom: 1 },\n                React.createElement(Text, { bold: true, color: \"green\" }, \"\\uD83D\\uDD27 Execution Viewer\"),\n                focused === 'viewer' && React.createElement(Text, { dimColor: true }, \" (focused)\")),\n            React.createElement(Box, { flexGrow: 1, flexDirection: \"column\", overflow: \"hidden\" }, viewer))));\n};\n// ============================================================================\n// FULLSCREEN VIEWER\n// ============================================================================\nconst FullscreenViewer = ({ children }) => {\n    return (React.createElement(Box, { flexDirection: \"column\", width: \"100%\", height: \"100%\", borderStyle: \"double\", borderColor: \"green\", paddingX: 1 },\n        React.createElement(Box, { marginBottom: 1 },\n            React.createElement(Text, { bold: true, color: \"green\" }, \"\\uD83D\\uDD27 Execution Viewer\"),\n            React.createElement(Text, { dimColor: true }, \" (fullscreen)\")),\n        React.createElement(Box, { flexGrow: 1, flexDirection: \"column\" }, children)));\n};\nconst KeyboardHints = ({ mode, hasExecution }) => {\n    const hints = {\n        hidden: [\n            { key: 'Ctrl+E', action: 'Show viewer' },\n            ...(hasExecution ? [{ key: '‚óè', action: 'Execution active' }] : [])\n        ],\n        split: [\n            { key: 'Ctrl+E', action: 'Hide viewer' },\n            { key: 'Ctrl+F', action: 'Fullscreen' },\n            { key: 'Tab', action: 'Switch focus' },\n            { key: 'Ctrl+C', action: 'Copy output' },\n            { key: 'Ctrl+D', action: 'Toggle details' }\n        ],\n        fullscreen: [\n            { key: 'Esc', action: 'Exit fullscreen' },\n            { key: 'Ctrl+E', action: 'Hide viewer' },\n            { key: 'Ctrl+C', action: 'Copy' },\n            { key: 'Ctrl+S', action: 'Save' }\n        ]\n    };\n    return (React.createElement(Box, { borderStyle: \"single\", borderColor: \"gray\", paddingX: 1, justifyContent: \"space-between\", flexShrink: 0 }, hints[mode].map((hint, i) => (React.createElement(Box, { key: i, marginRight: 2 },\n        React.createElement(Text, { color: \"cyan\", bold: true }, hint.key),\n        React.createElement(Text, { dimColor: true },\n            \" \",\n            hint.action))))));\n};\n//# sourceMappingURL=layout-manager.js.map"
  },
  "dist/ui/components/search/split-layout.js": {
    "path": "dist/ui/components/search/split-layout.js",
    "hash": "af9d13edb5284d099e0500aa1e828e52bb14e4124d5733afc40a29540cb96be5",
    "size": 1062,
    "timestamp": 1764704879305,
    "content": "import React from 'react';\nimport { Box, useStdout } from 'ink';\n/**\n * Split screen layout component\n */\nexport const SplitLayout = ({ left, right, splitRatio = 0.5, showBorder = true, }) => {\n    const { stdout } = useStdout();\n    const totalWidth = stdout?.columns || 80;\n    const totalHeight = (stdout?.rows || 24) - 6; // Reserve space for margins\n    const leftWidth = Math.floor(totalWidth * splitRatio);\n    const rightWidth = totalWidth - leftWidth - (showBorder ? 1 : 0); // Account for border\n    return (React.createElement(Box, { flexDirection: \"row\", width: totalWidth, height: totalHeight, overflow: \"hidden\" },\n        React.createElement(Box, { width: leftWidth, height: \"100%\", flexDirection: \"column\", borderStyle: showBorder ? 'single' : undefined, borderRight: showBorder, paddingRight: showBorder ? 1 : 0, overflow: \"hidden\" }, left),\n        React.createElement(Box, { width: rightWidth, height: \"100%\", flexDirection: \"column\", paddingLeft: showBorder ? 1 : 0, overflow: \"hidden\" }, right)));\n};\n//# sourceMappingURL=split-layout.js.map"
  },
  "dist/ui/components/search/highlighted-text.js": {
    "path": "dist/ui/components/search/highlighted-text.js",
    "hash": "57aed0fe86dff295e40f03bc66a3c928699923e542734ab0b7a44bceacd1ef67",
    "size": 1155,
    "timestamp": 1764704879305,
    "content": "import React from 'react';\nimport { Text } from 'ink';\n/**\n * Component to highlight search pattern in text\n */\nexport const HighlightedText = ({ text, pattern, highlightColor = 'black', highlightBg = 'yellow', }) => {\n    if (!pattern) {\n        return React.createElement(Text, null, text);\n    }\n    // Escape regex special characters\n    const escapedPattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    try {\n        const regex = new RegExp(`(${escapedPattern})`, 'gi');\n        const parts = text.split(regex);\n        return (React.createElement(Text, null, parts.map((part, i) => {\n            // Check if this part matches the pattern\n            const isMatch = new RegExp(`^${escapedPattern}$`, 'i').test(part);\n            if (isMatch) {\n                return (React.createElement(Text, { key: i, backgroundColor: highlightBg, color: highlightColor, bold: true }, part));\n            }\n            return React.createElement(Text, { key: i }, part);\n        })));\n    }\n    catch (error) {\n        // Fallback if regex fails\n        return React.createElement(Text, null, text);\n    }\n};\n//# sourceMappingURL=highlighted-text.js.map"
  },
  "dist/ui/components/search/search-results.js": {
    "path": "dist/ui/components/search/search-results.js",
    "hash": "3e8736197b2e6377a105edce5e1c52a92abe707a38facb58166fef2258bac2f8",
    "size": 10077,
    "timestamp": 1764704879305,
    "content": "import React, { useState, useCallback, useMemo } from 'react';\nimport { Box, Text, useInput, useStdout } from 'ink';\nimport { SearchResultItem } from './search-result-item.js';\nimport { ExpandedView } from './expanded-view.js';\nimport { clipboardManager } from '../../../utils/clipboard-manager.js';\n/**\n * Main search results component with list and expanded modes\n */\nexport const SearchResults = ({ query, results, onClose, onPasteToInput, onToggleFullscreen, fullscreen = false, }) => {\n    const { stdout } = useStdout();\n    const [viewMode, setViewMode] = useState('list');\n    const [selectedIndex, setSelectedIndex] = useState(0);\n    const [expandedScrollOffset, setExpandedScrollOffset] = useState(0);\n    const [notification, setNotification] = useState(null);\n    // Calculate fixed height based on terminal height\n    const terminalHeight = stdout?.rows || 24;\n    // In fullscreen mode: more results visible (full terminal width)\n    // In split mode: fewer results (half terminal width)\n    const maxVisibleResults = fullscreen\n        ? Math.floor(terminalHeight - 8) // Fullscreen: one result per line (more visible)\n        : Math.min(8, Math.floor((terminalHeight - 10) / 4)); // Split: compact view\n    const expandedMaxHeight = terminalHeight - 8;\n    // Show notification with auto-dismiss\n    const showNotification = useCallback((message, duration = 3000) => {\n        setNotification(message);\n        setTimeout(() => setNotification(null), duration);\n    }, []);\n    // Copy current result (compact mode)\n    const handleCopyCompact = useCallback(async () => {\n        const result = results[selectedIndex];\n        try {\n            const charCount = await clipboardManager.copySingleMessage(result.message, {\n                sessionDate: result.session.sessionDate,\n                workdir: result.session.workdir,\n                provider: result.session.provider,\n                model: result.session.model,\n            }, { includeMetadata: true, format: 'markdown' });\n            showNotification(`‚úÖ Copied to clipboard (${charCount} characters)`);\n        }\n        catch (error) {\n            showNotification(`‚ùå Failed to copy: ${error}`, 5000);\n        }\n    }, [results, selectedIndex, showNotification]);\n    // Copy full message (expanded mode)\n    const handleCopyFull = useCallback(async () => {\n        const result = results[selectedIndex];\n        try {\n            const charCount = await clipboardManager.copySingleMessage(result.message, {\n                sessionDate: result.session.sessionDate,\n                workdir: result.session.workdir,\n                provider: result.session.provider,\n                model: result.session.model,\n            }, { includeMetadata: true, format: 'markdown' });\n            showNotification(`‚úÖ Full message copied (${charCount} characters)`);\n        }\n        catch (error) {\n            showNotification(`‚ùå Failed to copy: ${error}`, 5000);\n        }\n    }, [results, selectedIndex, showNotification]);\n    // Paste clipboard content to input\n    const handlePasteToInput = useCallback(async () => {\n        try {\n            const content = await clipboardManager.readClipboard();\n            if (content && onPasteToInput) {\n                onPasteToInput(content);\n                showNotification(`üìã Pasted ${content.length} characters to input`);\n            }\n            else {\n                showNotification('‚ö†Ô∏è Clipboard is empty', 2000);\n            }\n        }\n        catch (error) {\n            showNotification(`‚ùå Failed to read clipboard: ${error}`, 5000);\n        }\n    }, [onPasteToInput, showNotification]);\n    // Keyboard navigation\n    useInput((input, key) => {\n        if (viewMode === 'list') {\n            // List mode navigation\n            if (key.upArrow) {\n                setSelectedIndex(Math.max(0, selectedIndex - 1));\n            }\n            else if (key.downArrow) {\n                setSelectedIndex(Math.min(results.length - 1, selectedIndex + 1));\n            }\n            else if (key.return) {\n                // Expand selected result\n                setViewMode('expanded');\n                setExpandedScrollOffset(0);\n            }\n            else if (input === 'f' && onToggleFullscreen) {\n                // Toggle fullscreen mode\n                onToggleFullscreen();\n            }\n            else if (key.ctrl && input === 's') {\n                handleCopyCompact();\n            }\n            else if (key.ctrl && input === 'p') {\n                handlePasteToInput();\n            }\n            else if (key.escape) {\n                onClose();\n            }\n        }\n        else if (viewMode === 'expanded') {\n            // Expanded mode navigation\n            if (key.upArrow) {\n                setExpandedScrollOffset(Math.max(0, expandedScrollOffset - 1));\n            }\n            else if (key.downArrow) {\n                setExpandedScrollOffset(expandedScrollOffset + 1);\n            }\n            else if (key.pageDown) {\n                setExpandedScrollOffset(expandedScrollOffset + 10);\n            }\n            else if (key.pageUp) {\n                setExpandedScrollOffset(Math.max(0, expandedScrollOffset - 10));\n            }\n            else if (input === 'n') {\n                // Next result\n                if (selectedIndex < results.length - 1) {\n                    setSelectedIndex(selectedIndex + 1);\n                    setExpandedScrollOffset(0);\n                }\n            }\n            else if (input === 'p') {\n                // Previous result\n                if (selectedIndex > 0) {\n                    setSelectedIndex(selectedIndex - 1);\n                    setExpandedScrollOffset(0);\n                }\n            }\n            else if (key.ctrl && input === 's') {\n                handleCopyFull();\n            }\n            else if (key.ctrl && input === 'p') {\n                handlePasteToInput();\n            }\n            else if (key.escape) {\n                setViewMode('list');\n                setExpandedScrollOffset(0);\n            }\n        }\n    });\n    // No results\n    if (results.length === 0) {\n        return (React.createElement(Box, { flexDirection: \"column\", borderStyle: \"single\", borderColor: \"yellow\", paddingX: 2, paddingY: 1 },\n            React.createElement(Text, { color: \"yellow\" },\n                \"\\uD83D\\uDD0D No results found for \\\"\",\n                query,\n                \"\\\"\"),\n            React.createElement(Box, { marginTop: 1 },\n                React.createElement(Text, { dimColor: true }, \"Try a different search term or check your spelling.\")),\n            React.createElement(Box, { marginTop: 1 },\n                React.createElement(Text, { dimColor: true }, \"Press Esc to close\"))));\n    }\n    // Memoize visible results to prevent unnecessary recalculations\n    const visibleResultsData = useMemo(() => {\n        const halfWindow = Math.floor(maxVisibleResults / 2);\n        let windowStart = Math.max(0, selectedIndex - halfWindow);\n        const windowEnd = Math.min(results.length, windowStart + maxVisibleResults);\n        if (windowEnd === results.length) {\n            windowStart = Math.max(0, results.length - maxVisibleResults);\n        }\n        return {\n            windowStart,\n            windowEnd,\n            visibleResults: results.slice(windowStart, windowEnd),\n        };\n    }, [results, selectedIndex, maxVisibleResults]);\n    return (React.createElement(Box, { flexDirection: \"column\", height: terminalHeight - 4 },\n        viewMode === 'list' ? (React.createElement(Box, { flexDirection: \"column\", height: \"100%\" },\n            React.createElement(Box, { borderStyle: \"single\", borderBottom: true, paddingX: 1 },\n                React.createElement(Text, { bold: true, color: \"cyan\" },\n                    \"\\uD83D\\uDD0D Search: \\\"\",\n                    query,\n                    \"\\\"\"),\n                fullscreen && (React.createElement(Text, { color: \"yellow\", dimColor: true }, \" [FULLSCREEN]\"))),\n            React.createElement(Box, null,\n                React.createElement(Text, null,\n                    \"\\uD83D\\uDCCA \",\n                    results.length,\n                    \" result\",\n                    results.length > 1 ? 's' : '',\n                    \" found\")),\n            React.createElement(Box, { flexDirection: \"column\", flexGrow: 1, overflow: \"hidden\" }, visibleResultsData.visibleResults.map((result, localIndex) => {\n                const globalIndex = visibleResultsData.windowStart + localIndex;\n                return (React.createElement(SearchResultItem, { key: `result-${result.message.id}-${globalIndex}`, result: result, query: query, isSelected: globalIndex === selectedIndex, index: globalIndex + 1, total: results.length, compact: true }));\n            })),\n            React.createElement(Box, { flexDirection: \"column\", flexShrink: 0 },\n                results.length > maxVisibleResults && (React.createElement(Box, null,\n                    React.createElement(Text, { dimColor: true },\n                        \"Showing \",\n                        Math.min(maxVisibleResults, results.length),\n                        \" of \",\n                        results.length,\n                        \" results\",\n                        selectedIndex >= 0 && ` ‚Ä¢ Currently at #${selectedIndex + 1}`))),\n                React.createElement(Box, { borderStyle: \"single\", borderTop: true, paddingX: 1 },\n                    React.createElement(Text, { dimColor: true }, \"\\u2191/\\u2193 Navigate \\u2022 Enter Expand \\u2022 f Fullscreen \\u2022 ^S Copy \\u2022 Esc Close\"))))) : (\n        // Expanded view\n        React.createElement(ExpandedView, { result: results[selectedIndex], query: query, scrollOffset: expandedScrollOffset, maxHeight: expandedMaxHeight, currentIndex: selectedIndex + 1, totalResults: results.length })),\n        notification && (React.createElement(Box, { marginTop: 1, borderStyle: \"round\", borderColor: \"green\", paddingX: 2, paddingY: 0 },\n            React.createElement(Text, { color: \"green\" }, notification)))));\n};\n//# sourceMappingURL=search-results.js.map"
  },
  "dist/ui/components/search/expanded-view.js": {
    "path": "dist/ui/components/search/expanded-view.js",
    "hash": "681edf736dc3633048b8343cb11e1ff345be587b06f49bc5a127201ec80ad2ca",
    "size": 5084,
    "timestamp": 1764704879305,
    "content": "import React, { useMemo } from 'react';\nimport { Box, Text } from 'ink';\nimport { HighlightedText } from './highlighted-text.js';\n/**\n * Expanded view of a single search result (scrollable)\n */\nexport const ExpandedView = ({ result, query, scrollOffset, maxHeight, currentIndex, totalResults, }) => {\n    const { message, session, contextBefore, contextAfter } = result;\n    // Split content into lines for scrolling\n    const contentLines = useMemo(() => {\n        const lines = [];\n        // Session header\n        lines.push({ type: 'header', text: `Session #${session.id} - ${session.sessionDate}` });\n        lines.push({ type: 'header', text: `Working Directory: ${session.workdir}` });\n        lines.push({ type: 'header', text: `Provider: ${session.provider} (${session.model})` });\n        lines.push({ type: 'separator', text: '‚îÄ'.repeat(60) });\n        // Context before (if exists)\n        if (contextBefore) {\n            const icon = contextBefore.role === 'user' ? 'üë§' : 'ü§ñ';\n            const role = contextBefore.role === 'user' ? 'User' : 'Assistant';\n            lines.push({ type: 'content', text: `${icon} ${role} (context):`, role: contextBefore.role });\n            const beforeLines = contextBefore.content.split('\\n');\n            beforeLines.forEach(line => {\n                lines.push({ type: 'content', text: line, role: contextBefore.role });\n            });\n            lines.push({ type: 'separator', text: '' });\n        }\n        // Main message\n        const icon = message.role === 'user' ? 'üë§' : 'ü§ñ';\n        const role = message.role === 'user' ? 'User' : 'Assistant';\n        lines.push({ type: 'content', text: `${icon} ${role}:`, role: message.role });\n        const messageLines = message.content.split('\\n');\n        messageLines.forEach(line => {\n            lines.push({ type: 'content', text: line, role: message.role });\n        });\n        // Context after (if exists)\n        if (contextAfter) {\n            lines.push({ type: 'separator', text: '' });\n            const icon = contextAfter.role === 'user' ? 'üë§' : 'ü§ñ';\n            const role = contextAfter.role === 'user' ? 'User' : 'Assistant';\n            lines.push({ type: 'content', text: `${icon} ${role} (context):`, role: contextAfter.role });\n            const afterLines = contextAfter.content.split('\\n');\n            afterLines.forEach(line => {\n                lines.push({ type: 'content', text: line, role: contextAfter.role });\n            });\n        }\n        return lines;\n    }, [message, session, contextBefore, contextAfter]);\n    // Calculate visible lines\n    const visibleLines = contentLines.slice(scrollOffset, scrollOffset + maxHeight - 4); // Reserve space for header/footer\n    const scrollPercentage = Math.round((scrollOffset / Math.max(1, contentLines.length - maxHeight)) * 100);\n    const canScrollUp = scrollOffset > 0;\n    const canScrollDown = scrollOffset + maxHeight < contentLines.length;\n    return (React.createElement(Box, { flexDirection: \"column\", height: maxHeight },\n        React.createElement(Box, { borderStyle: \"single\", borderBottom: true, paddingX: 1 },\n            React.createElement(Text, { bold: true, color: \"cyan\" },\n                \"\\uD83D\\uDD0D Result [\",\n                currentIndex,\n                \"/\",\n                totalResults,\n                \"] - \\\"\",\n                query,\n                \"\\\"\")),\n        React.createElement(Box, { flexDirection: \"column\", flexGrow: 1, paddingX: 1, paddingY: 1 }, visibleLines.map((line, i) => {\n            const hasMatch = line.text.toLowerCase().includes(query.toLowerCase());\n            if (line.type === 'header') {\n                return (React.createElement(Box, { key: i },\n                    React.createElement(Text, { bold: true, color: \"cyan\" }, line.text)));\n            }\n            if (line.type === 'separator') {\n                return (React.createElement(Box, { key: i },\n                    React.createElement(Text, { dimColor: true }, line.text)));\n            }\n            return (React.createElement(Box, { key: i },\n                React.createElement(HighlightedText, { text: line.text, pattern: query })));\n        })),\n        React.createElement(Box, { borderStyle: \"single\", borderTop: true, paddingX: 1, flexDirection: \"column\" },\n            React.createElement(Box, { justifyContent: \"space-between\" },\n                React.createElement(Text, { dimColor: true },\n                    canScrollDown ? '‚¨á' : ' ',\n                    \" Scroll: \",\n                    scrollPercentage,\n                    \"% \",\n                    canScrollUp ? '‚¨Ü' : ' '),\n                React.createElement(Text, { dimColor: true },\n                    contentLines.length,\n                    \" lines (showing \",\n                    visibleLines.length,\n                    \")\")),\n            React.createElement(Box, { marginTop: 0 },\n                React.createElement(Text, { dimColor: true }, \"\\u2191/\\u2193 Scroll \\u2022 PgUp/PgDn Page \\u2022 n/p Next/Prev \\u2022 ^S Copy \\u2022 Esc Back\")))));\n};\n//# sourceMappingURL=expanded-view.js.map"
  },
  "dist/ui/components/search/search-result-item.js": {
    "path": "dist/ui/components/search/search-result-item.js",
    "hash": "670136acdce9298da746e614930be03c4d56352d82ed55882510f71edf95eed0",
    "size": 2517,
    "timestamp": 1764704879305,
    "content": "import React from 'react';\nimport { Box, Text } from 'ink';\nimport { HighlightedText } from './highlighted-text.js';\n/**\n * Single search result item (compact view)\n */\nconst SearchResultItemComponent = ({ result, query, isSelected, index, total, compact = true, }) => {\n    const { message, session } = result;\n    // Truncate content for compact view\n    const truncateContent = (text, maxLength = 120) => {\n        if (text.length <= maxLength)\n            return text;\n        return text.substring(0, maxLength) + '...';\n    };\n    const roleIcon = message.role === 'user' ? 'üë§' : 'ü§ñ';\n    const borderStyle = isSelected ? 'double' : 'single';\n    const borderColor = isSelected ? 'cyan' : 'gray';\n    return (React.createElement(Box, { flexDirection: \"column\", borderStyle: borderStyle, borderColor: borderColor, paddingX: 1, marginBottom: 1 },\n        React.createElement(Box, null,\n            React.createElement(Text, { bold: true, color: isSelected ? 'cyan' : 'white' },\n                \"[\",\n                index,\n                \"/\",\n                total,\n                \"] Session #\",\n                session.id,\n                \" - \",\n                session.sessionDate)),\n        React.createElement(Box, { marginTop: 0, flexDirection: \"column\" },\n            React.createElement(Box, null,\n                React.createElement(Text, { dimColor: true },\n                    roleIcon,\n                    \" \"),\n                compact ? (React.createElement(Text, null,\n                    React.createElement(HighlightedText, { text: truncateContent(message.content), pattern: query }))) : (React.createElement(HighlightedText, { text: message.content, pattern: query })))),\n        !compact && (React.createElement(Box, { marginTop: 1 },\n            React.createElement(Text, { dimColor: true },\n                session.provider,\n                \" (\",\n                session.model,\n                \") \\u2022 \",\n                result.matchCount,\n                \" matches\")))));\n};\n// Memoize to prevent re-renders when only selection changes\nexport const SearchResultItem = React.memo(SearchResultItemComponent, (prevProps, nextProps) => {\n    // Only re-render if the item's selection state changed or content changed\n    return (prevProps.isSelected === nextProps.isSelected &&\n        prevProps.result.message.id === nextProps.result.message.id &&\n        prevProps.query === nextProps.query &&\n        prevProps.index === nextProps.index);\n});\n//# sourceMappingURL=search-result-item.js.map"
  },
  "dist/ui/components/search/index.js": {
    "path": "dist/ui/components/search/index.js",
    "hash": "60a4d7a0968d3c4dd9b07906cc30e82b2072598a8e715d2acb70e491c2e4f85c",
    "size": 303,
    "timestamp": 1764704879305,
    "content": "export { SplitLayout } from './split-layout.js';\nexport { SearchResults } from './search-results.js';\nexport { SearchResultItem } from './search-result-item.js';\nexport { ExpandedView } from './expanded-view.js';\nexport { HighlightedText } from './highlighted-text.js';\n//# sourceMappingURL=index.js.map"
  },
  "dist/ui/components/chat-input.js": {
    "path": "dist/ui/components/chat-input.js",
    "hash": "27619a2522946a5d85a59cf91f4993dc90065104ff7dd36f5e582a48aa23951a",
    "size": 6750,
    "timestamp": 1764704879306,
    "content": "import React, { useMemo } from \"react\";\nimport { Box, Text } from \"ink\";\nimport { pasteManager } from \"../../utils/paste-manager.js\";\nimport { imagePathManager } from \"../../utils/image-path-detector.js\";\nexport const ChatInput = React.memo(function ChatInput({ input, cursorPosition, isProcessing, isStreaming, }) {\n    const beforeCursor = input.slice(0, cursorPosition);\n    const afterCursor = input.slice(cursorPosition);\n    // Function to render text with styled placeholders (cyan for text, magenta for images)\n    const renderWithPlaceholders = useMemo(() => {\n        return (text) => {\n            const pendingPastes = pasteManager.getPendingPastes();\n            const attachedImages = imagePathManager.getAttachedImages();\n            if (pendingPastes.length === 0 && attachedImages.length === 0) {\n                return text;\n            }\n            // Build a combined list of all placeholders with their types\n            const placeholders = [\n                ...pendingPastes.map(p => ({ text: p.placeholder, type: 'paste' })),\n                ...attachedImages.map(img => ({ text: img.placeholder, type: 'image' })),\n            ];\n            // Sort by position in text for correct rendering\n            const segments = [];\n            let remaining = text;\n            let changed = true;\n            while (changed && remaining) {\n                changed = false;\n                let earliestIndex = Infinity;\n                let earliestPlaceholder = null;\n                // Find the earliest placeholder in remaining text\n                for (const placeholder of placeholders) {\n                    const index = remaining.indexOf(placeholder.text);\n                    if (index !== -1 && index < earliestIndex) {\n                        earliestIndex = index;\n                        earliestPlaceholder = placeholder;\n                        changed = true;\n                    }\n                }\n                if (earliestPlaceholder) {\n                    // Add text before placeholder\n                    if (earliestIndex > 0) {\n                        segments.push({ text: remaining.slice(0, earliestIndex), type: 'text' });\n                    }\n                    // Add placeholder\n                    segments.push({ text: earliestPlaceholder.text, type: earliestPlaceholder.type });\n                    // Continue with remaining text\n                    remaining = remaining.slice(earliestIndex + earliestPlaceholder.text.length);\n                }\n            }\n            // Add any remaining text\n            if (remaining) {\n                segments.push({ text: remaining, type: 'text' });\n            }\n            // Render segments with appropriate colors\n            return segments.map((segment, idx) => {\n                if (segment.type === 'paste') {\n                    return React.createElement(Text, { key: idx, color: \"cyan\" }, segment.text);\n                }\n                else if (segment.type === 'image') {\n                    return React.createElement(Text, { key: idx, color: \"magenta\" }, segment.text);\n                }\n                else {\n                    return React.createElement(Text, { key: idx }, segment.text);\n                }\n            });\n        };\n    }, []);\n    // Handle multiline input display\n    const lines = input.split(\"\\n\");\n    const isMultiline = lines.length > 1;\n    // Calculate cursor position across lines\n    let currentLineIndex = 0;\n    let currentCharIndex = 0;\n    let totalChars = 0;\n    for (let i = 0; i < lines.length; i++) {\n        if (totalChars + lines[i].length >= cursorPosition) {\n            currentLineIndex = i;\n            currentCharIndex = cursorPosition - totalChars;\n            break;\n        }\n        totalChars += lines[i].length + 1; // +1 for newline\n    }\n    const showCursor = !isProcessing && !isStreaming;\n    const borderColor = isProcessing || isStreaming ? \"yellow\" : \"blue\";\n    const promptColor = \"cyan\";\n    // Display placeholder when input is empty\n    const placeholderText = \"Ask me anything...\";\n    const isPlaceholder = !input;\n    if (isMultiline) {\n        return (React.createElement(Box, { borderStyle: \"round\", borderColor: borderColor, paddingY: 0, marginTop: 1 }, lines.map((line, index) => {\n            const isCurrentLine = index === currentLineIndex;\n            const promptChar = index === 0 ? \"‚ùØ\" : \"‚îÇ\";\n            if (isCurrentLine) {\n                const beforeCursorInLine = line.slice(0, currentCharIndex);\n                const cursorChar = line.slice(currentCharIndex, currentCharIndex + 1) || \" \";\n                const afterCursorInLine = line.slice(currentCharIndex + 1);\n                return (React.createElement(Box, { key: index },\n                    React.createElement(Text, { color: promptColor },\n                        promptChar,\n                        \" \"),\n                    React.createElement(Text, null,\n                        renderWithPlaceholders(beforeCursorInLine),\n                        showCursor && (React.createElement(Text, { backgroundColor: \"white\", color: \"black\" }, cursorChar)),\n                        !showCursor && cursorChar !== \" \" && cursorChar,\n                        renderWithPlaceholders(afterCursorInLine))));\n            }\n            else {\n                return (React.createElement(Box, { key: index },\n                    React.createElement(Text, { color: promptColor },\n                        promptChar,\n                        \" \"),\n                    React.createElement(Text, null, renderWithPlaceholders(line))));\n            }\n        })));\n    }\n    // Single line input box\n    const cursorChar = input.slice(cursorPosition, cursorPosition + 1) || \" \";\n    const afterCursorText = input.slice(cursorPosition + 1);\n    return (React.createElement(Box, { borderStyle: \"round\", borderColor: borderColor, paddingX: 1, paddingY: 0, marginTop: 1, flexDirection: \"column\" },\n        React.createElement(Box, { flexDirection: \"row\", flexWrap: \"wrap\" },\n            React.createElement(Text, { color: promptColor }, \"\\u276F \"),\n            isPlaceholder ? (React.createElement(React.Fragment, null,\n                React.createElement(Text, { color: \"gray\", dimColor: true }, placeholderText),\n                showCursor && (React.createElement(Text, { backgroundColor: \"white\", color: \"black\" }, \" \")))) : (React.createElement(Text, { wrap: \"wrap\" },\n                renderWithPlaceholders(beforeCursor),\n                showCursor && (React.createElement(Text, { backgroundColor: \"white\", color: \"black\" }, cursorChar)),\n                !showCursor && cursorChar !== \" \" && cursorChar,\n                renderWithPlaceholders(afterCursorText))))));\n});\n//# sourceMappingURL=chat-input.js.map"
  },
  "dist/ui/components/chat-history.js": {
    "path": "dist/ui/components/chat-history.js",
    "hash": "96688b850dfa9a92b9f430ad7cd8fde18813cdc7bbc03017006d3cb2208538a7",
    "size": 9400,
    "timestamp": 1764704879306,
    "content": "import React, { useMemo } from \"react\";\nimport { Box, Text } from \"ink\";\nimport { DiffRenderer } from \"./diff-renderer.js\";\nimport { MarkdownRenderer } from \"../utils/markdown-renderer.js\";\n// Memoized ChatEntry component to prevent unnecessary re-renders\nconst MemoizedChatEntry = React.memo(({ entry, index }) => {\n    const renderDiff = (diffContent, filename) => {\n        return (React.createElement(DiffRenderer, { diffContent: diffContent, filename: filename, terminalWidth: 80 }));\n    };\n    const renderFileContent = (content) => {\n        const lines = content.split(\"\\n\");\n        // Calculate minimum indentation like DiffRenderer does\n        let baseIndentation = Infinity;\n        for (const line of lines) {\n            if (line.trim() === \"\")\n                continue;\n            const firstCharIndex = line.search(/\\S/);\n            const currentIndent = firstCharIndex === -1 ? 0 : firstCharIndex;\n            baseIndentation = Math.min(baseIndentation, currentIndent);\n        }\n        if (!isFinite(baseIndentation)) {\n            baseIndentation = 0;\n        }\n        return lines.map((line, index) => {\n            const displayContent = line.substring(baseIndentation);\n            return (React.createElement(Text, { key: index, color: \"gray\" }, displayContent));\n        });\n    };\n    switch (entry.type) {\n        case \"user\":\n            return (React.createElement(Box, { key: index, flexDirection: \"column\" },\n                React.createElement(Box, null,\n                    React.createElement(Text, { color: \"gray\" },\n                        \">\",\n                        \" \",\n                        entry.content))));\n        case \"assistant\":\n            return (React.createElement(Box, { key: index, flexDirection: \"column\" },\n                React.createElement(Box, { flexDirection: \"row\", alignItems: \"flex-start\" },\n                    React.createElement(Text, { color: \"white\" }, \"\\u23FA \"),\n                    React.createElement(Box, { flexDirection: \"column\", flexGrow: 1 },\n                        entry.toolCalls ? (\n                        // If there are tool calls, just show plain text\n                        React.createElement(Text, { color: \"white\" }, entry.content.trim())) : (\n                        // If no tool calls, render as markdown\n                        React.createElement(MarkdownRenderer, { content: entry.content.trim() })),\n                        entry.isStreaming && React.createElement(Text, { color: \"cyan\" }, \"\\u2588\")))));\n        case \"tool_call\":\n        case \"tool_result\":\n            const getToolActionName = (toolName) => {\n                // Handle MCP tools with mcp__servername__toolname format\n                if (toolName.startsWith(\"mcp__\")) {\n                    const parts = toolName.split(\"__\");\n                    if (parts.length >= 3) {\n                        const serverName = parts[1];\n                        const actualToolName = parts.slice(2).join(\"__\");\n                        return `${serverName.charAt(0).toUpperCase() + serverName.slice(1)}(${actualToolName.replace(/_/g, \" \")})`;\n                    }\n                }\n                switch (toolName) {\n                    case \"view_file\":\n                        return \"Read\";\n                    case \"str_replace_editor\":\n                        return \"Update\";\n                    case \"create_file\":\n                        return \"Create\";\n                    case \"bash\":\n                        return \"Bash\";\n                    case \"search\":\n                        return \"Search\";\n                    case \"create_todo_list\":\n                        return \"Created Todo\";\n                    case \"update_todo_list\":\n                        return \"Updated Todo\";\n                    default:\n                        return \"Tool\";\n                }\n            };\n            const toolName = entry.toolCall?.function?.name || \"unknown\";\n            const actionName = getToolActionName(toolName);\n            const getFilePath = (toolCall) => {\n                if (toolCall?.function?.arguments) {\n                    try {\n                        const args = JSON.parse(toolCall.function.arguments);\n                        if (toolCall.function.name === \"search\") {\n                            return args.query;\n                        }\n                        return args.path || args.file_path || args.command || \"\";\n                    }\n                    catch {\n                        return \"\";\n                    }\n                }\n                return \"\";\n            };\n            const filePath = getFilePath(entry.toolCall);\n            const isExecuting = entry.type === \"tool_call\" || !entry.toolResult;\n            // Format JSON content for better readability\n            const formatToolContent = (content, toolName) => {\n                if (toolName.startsWith(\"mcp__\")) {\n                    try {\n                        // Try to parse as JSON and format it\n                        const parsed = JSON.parse(content);\n                        if (Array.isArray(parsed)) {\n                            // For arrays, show a summary instead of full JSON\n                            return `Found ${parsed.length} items`;\n                        }\n                        else if (typeof parsed === 'object') {\n                            // For objects, show a formatted version\n                            return JSON.stringify(parsed, null, 2);\n                        }\n                    }\n                    catch {\n                        // If not JSON, return as is\n                        return content;\n                    }\n                }\n                return content;\n            };\n            const shouldShowDiff = entry.toolCall?.function?.name === \"str_replace_editor\" &&\n                entry.toolResult?.success &&\n                entry.content.includes(\"Updated\") &&\n                entry.content.includes(\"---\") &&\n                entry.content.includes(\"+++\");\n            const shouldShowFileContent = (entry.toolCall?.function?.name === \"view_file\" ||\n                entry.toolCall?.function?.name === \"create_file\") &&\n                entry.toolResult?.success &&\n                !shouldShowDiff;\n            return (React.createElement(Box, { key: index, flexDirection: \"column\", marginTop: 1 },\n                React.createElement(Box, null,\n                    React.createElement(Text, { color: \"magenta\" }, \"\\u23FA\"),\n                    React.createElement(Text, { color: \"white\" },\n                        \" \",\n                        filePath ? `${actionName}(${filePath})` : actionName)),\n                React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" }, isExecuting ? (React.createElement(Text, { color: \"cyan\" }, \"\\u23BF Executing...\")) : shouldShowFileContent ? (React.createElement(Box, { flexDirection: \"column\" },\n                    React.createElement(Text, { color: \"gray\" }, \"\\u23BF File contents:\"),\n                    React.createElement(Box, { marginLeft: 2, flexDirection: \"column\" }, renderFileContent(entry.content)))) : shouldShowDiff ? (\n                // For diff results, show only the summary line, not the raw content\n                React.createElement(Text, { color: \"gray\" },\n                    \"\\u23BF \",\n                    entry.content.split(\"\\n\")[0])) : (React.createElement(Text, { color: \"gray\" },\n                    \"\\u23BF \",\n                    formatToolContent(entry.content, toolName)))),\n                shouldShowDiff && !isExecuting && (React.createElement(Box, { marginLeft: 4, flexDirection: \"column\" }, renderDiff(entry.content, filePath)))));\n        default:\n            return null;\n    }\n});\nMemoizedChatEntry.displayName = \"MemoizedChatEntry\";\n// Lightweight archived entry renderer to print finalized entries once\nexport const MemoizedArchived = React.memo(({ entry }) => {\n    return React.createElement(MemoizedChatEntry, { entry: entry, index: 0 });\n});\nconst ChatHistoryComponent = ({ entries, isConfirmationActive = false, }) => {\n    // Filter out tool_call entries with \"Executing...\" when confirmation is active\n    const filteredEntries = useMemo(() => {\n        if (!isConfirmationActive)\n            return entries;\n        return entries.filter((entry) => !(entry.type === \"tool_call\" && entry.content === \"Executing...\"));\n    }, [entries, isConfirmationActive]);\n    return (React.createElement(Box, { flexDirection: \"column\" }, filteredEntries.map((entry, index) => (React.createElement(MemoizedChatEntry, { key: `${entry.timestamp.getTime()}-${index}`, entry: entry, index: index })))));\n};\nexport const ChatHistory = React.memo(ChatHistoryComponent, (prevProps, nextProps) => {\n    // Custom comparison to prevent unnecessary re-renders\n    // Only re-render if entries actually changed\n    if (prevProps.entries.length !== nextProps.entries.length)\n        return false;\n    if (prevProps.isConfirmationActive !== nextProps.isConfirmationActive)\n        return false;\n    // Check if the last entry is the same (most common case)\n    const prevLast = prevProps.entries[prevProps.entries.length - 1];\n    const nextLast = nextProps.entries[nextProps.entries.length - 1];\n    if (prevLast?.timestamp !== nextLast?.timestamp)\n        return false;\n    return true; // Props are equal, skip re-render\n});\n//# sourceMappingURL=chat-history.js.map"
  },
  "dist/ui/components/api-key-input-helpers.js": {
    "path": "dist/ui/components/api-key-input-helpers.js",
    "hash": "d694bccdbbc2aa05d27c8a90b632ab767f4538038a405c202fc2525d7240a1aa",
    "size": 2624,
    "timestamp": 1764704879306,
    "content": "/**\n * Helper functions for ApiKeyInput component\n * Isolated to prevent regressions in main component\n */\nimport { providerManager } from \"../../utils/provider-manager.js\";\n/**\n * Get all models from all providers as flat sorted array\n * @returns Array of model names sorted alphabetically\n */\nexport function getAllModelsFlat() {\n    const providers = providerManager.getAllProviders();\n    const models = [];\n    for (const provider of Object.values(providers)) {\n        models.push(...provider.models);\n    }\n    // Sort alphabetically for consistent display\n    return models.sort((a, b) => a.localeCompare(b));\n}\n/**\n * Fuzzy match query against list of models\n * @param query - User's search query (case-insensitive)\n * @param models - List of model names to search\n * @returns Array of matching model names\n */\nexport function fuzzyMatch(query, models) {\n    if (!query || query.trim() === '') {\n        return models;\n    }\n    const q = query.toLowerCase().trim();\n    // Exact match first\n    const exactMatch = models.find(m => m.toLowerCase() === q);\n    if (exactMatch) {\n        return [exactMatch];\n    }\n    // Starts with query\n    const startsWithMatches = models.filter(m => m.toLowerCase().startsWith(q));\n    // Contains query\n    const containsMatches = models.filter(m => m.toLowerCase().includes(q) && !m.toLowerCase().startsWith(q));\n    return [...startsWithMatches, ...containsMatches];\n}\n/**\n * Get models grouped by provider for display\n * @returns Object with provider names as keys and model arrays as values\n */\nexport function getModelsByProvider() {\n    const providers = providerManager.getAllProviders();\n    const result = {};\n    for (const [providerName, provider] of Object.entries(providers)) {\n        result[providerName] = [...provider.models];\n    }\n    return result;\n}\n/**\n * Format model list for display in interactive menu\n * @param models - Array of model names\n * @param selectedIndex - Currently selected index (for highlighting)\n * @returns Formatted string for display\n */\nexport function formatModelMenu(models, selectedIndex) {\n    if (models.length === 0) {\n        return \"‚ùå No models found\";\n    }\n    let output = \"üìã **Select a Model** (‚Üë/‚Üì to navigate, Enter to select, Esc to cancel)\\n\\n\";\n    models.forEach((model, idx) => {\n        const isSelected = idx === selectedIndex;\n        const marker = isSelected ? \"‚ñ∂ \" : \"  \";\n        const color = isSelected ? \"üîπ \" : \"  \";\n        output += `${marker}${color}${model}\\n`;\n    });\n    output += `\\nüí° ${models.length} models available`;\n    return output;\n}\n//# sourceMappingURL=api-key-input-helpers.js.map"
  },
  "dist/ui/utils/colors.js": {
    "path": "dist/ui/utils/colors.js",
    "hash": "a200defab4a8b7f2a2730be4ec1c3f1165454b1917149eddaa0753ad95cc28bf",
    "size": 291,
    "timestamp": 1764704879306,
    "content": "/**\n * Color constants for the CLI interface\n */\nexport const Colors = {\n    AccentYellow: 'yellow',\n    Gray: 'gray',\n    Red: 'red',\n    Green: 'green',\n    Blue: 'blue',\n    Cyan: 'cyan',\n    Magenta: 'magenta',\n    White: 'white',\n    Black: 'black'\n};\n//# sourceMappingURL=colors.js.map"
  },
  "dist/ui/utils/markdown-renderer.js": {
    "path": "dist/ui/utils/markdown-renderer.js",
    "hash": "1448f038019e6d2630535f0f80da0be79d059c52f55f0e8a6f0471be4bb8c2c7",
    "size": 718,
    "timestamp": 1764704879306,
    "content": "import React, { useMemo } from 'react';\nimport { Text } from 'ink';\nimport { marked } from 'marked';\nimport TerminalRenderer from 'marked-terminal';\n// Configure marked to use the terminal renderer with default settings\nmarked.setOptions({\n    renderer: new TerminalRenderer()\n});\nexport const MarkdownRenderer = React.memo(function MarkdownRenderer({ content }) {\n    const rendered = useMemo(() => {\n        try {\n            const result = marked.parse(content);\n            return typeof result === 'string' ? result : content;\n        }\n        catch {\n            return content;\n        }\n    }, [content]);\n    return React.createElement(Text, null, rendered);\n});\n//# sourceMappingURL=markdown-renderer.js.map"
  },
  "dist/ui/utils/code-colorizer.js": {
    "path": "dist/ui/utils/code-colorizer.js",
    "hash": "395eb29636248a94f999a2e2908fb08336a38bb80c3444b4351b7accab449123",
    "size": 459,
    "timestamp": 1764704879306,
    "content": "import React from 'react';\nimport { Text, Box } from 'ink';\nexport const colorizeCode = (content, language, availableTerminalHeight, terminalWidth) => {\n    // Simple plain text rendering - could be enhanced with syntax highlighting later\n    return (React.createElement(Box, { flexDirection: \"column\" }, content.split('\\n').map((line, index) => (React.createElement(Text, { key: index, wrap: \"wrap\" }, line)))));\n};\n//# sourceMappingURL=code-colorizer.js.map"
  },
  "dist/ui/utils/wrap-cache.js": {
    "path": "dist/ui/utils/wrap-cache.js",
    "hash": "b7694c51962e730a597d80971535e45b7d147da51a42afc9e573a05728bf8806",
    "size": 3516,
    "timestamp": 1764704879306,
    "content": "/**\n * Wrapping cache inspired by Codex's RefCell<WrapCache>\n * Prevents recalculating text wrapping on every render\n */\nclass WrapCache {\n    cache = new Map();\n    maxEntries = 100;\n    maxAge = 60000; // 60 seconds\n    /**\n     * Get wrapped lines from cache or calculate and cache\n     */\n    getWrappedLines(text, width) {\n        const key = this.makeKey(text, width);\n        // Check cache\n        const cached = this.cache.get(key);\n        if (cached && cached.timestamp > Date.now() - this.maxAge) {\n            return cached.lines;\n        }\n        // Calculate and cache\n        const lines = this.wrapText(text, width);\n        this.cache.set(key, {\n            width,\n            text,\n            lines,\n            timestamp: Date.now(),\n        });\n        // Cleanup old entries\n        if (this.cache.size > this.maxEntries) {\n            this.cleanupOldEntries();\n        }\n        return lines;\n    }\n    /**\n     * Invalidate cache for specific text\n     */\n    invalidate(text) {\n        if (text) {\n            // Remove all entries for this text\n            for (const [key, entry] of this.cache.entries()) {\n                if (entry.text === text) {\n                    this.cache.delete(key);\n                }\n            }\n        }\n        else {\n            // Clear entire cache\n            this.cache.clear();\n        }\n    }\n    makeKey(text, width) {\n        // Use hash for long texts to keep keys manageable\n        if (text.length > 100) {\n            const hash = this.simpleHash(text);\n            return `${hash}-${width}`;\n        }\n        return `${text}-${width}`;\n    }\n    simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash.toString(36);\n    }\n    wrapText(text, width) {\n        if (width <= 0)\n            return [text];\n        const lines = [];\n        const paragraphs = text.split('\\n');\n        for (const paragraph of paragraphs) {\n            if (paragraph.length <= width) {\n                lines.push(paragraph);\n            }\n            else {\n                // Simple word wrapping\n                const words = paragraph.split(' ');\n                let currentLine = '';\n                for (const word of words) {\n                    if (currentLine.length + word.length + 1 <= width) {\n                        currentLine += (currentLine ? ' ' : '') + word;\n                    }\n                    else {\n                        if (currentLine)\n                            lines.push(currentLine);\n                        currentLine = word;\n                    }\n                }\n                if (currentLine)\n                    lines.push(currentLine);\n            }\n        }\n        return lines;\n    }\n    cleanupOldEntries() {\n        const now = Date.now();\n        const entries = Array.from(this.cache.entries());\n        // Sort by timestamp, oldest first\n        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n        // Remove oldest 20%\n        const toRemove = Math.floor(entries.length * 0.2);\n        for (let i = 0; i < toRemove; i++) {\n            this.cache.delete(entries[i][0]);\n        }\n    }\n}\n// Singleton instance\nconst wrapCacheInstance = new WrapCache();\nexport function useWrapCache() {\n    return wrapCacheInstance;\n}\nexport default WrapCache;\n//# sourceMappingURL=wrap-cache.js.map"
  },
  "dist/ui/app.js": {
    "path": "dist/ui/app.js",
    "hash": "39d06a5eff2aad7a6f003430aab757929770d8725f7db7d6ce8574b92ff297af",
    "size": 4956,
    "timestamp": 1764704879306,
    "content": "import React, { useState, useEffect } from 'react';\nimport { Box, Text, useInput } from 'ink';\nimport { ConfirmationService } from '../utils/confirmation-service.js';\nimport ConfirmationDialog from './components/confirmation-dialog.js';\nexport default function App({ agent }) {\n    const [input, setInput] = useState('');\n    const [history, setHistory] = useState([]);\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [confirmationOptions, setConfirmationOptions] = useState(null);\n    // Removed useApp().exit - using process.exit(0) instead for better terminal handling\n    const confirmationService = ConfirmationService.getInstance();\n    useEffect(() => {\n        const handleConfirmationRequest = (options) => {\n            setConfirmationOptions(options);\n        };\n        confirmationService.on('confirmation-requested', handleConfirmationRequest);\n        return () => {\n            confirmationService.off('confirmation-requested', handleConfirmationRequest);\n        };\n    }, [confirmationService]);\n    // Reset confirmation service session on app start\n    useEffect(() => {\n        confirmationService.resetSession();\n    }, []);\n    useInput(async (inputChar, key) => {\n        // If confirmation dialog is open, don't handle normal input\n        if (confirmationOptions) {\n            return;\n        }\n        if (key.ctrl && inputChar === 'c') {\n            process.exit(0);\n            return;\n        }\n        if (key.return) {\n            if (input.trim() === 'exit' || input.trim() === 'quit') {\n                process.exit(0);\n                return;\n            }\n            if (input.trim()) {\n                setIsProcessing(true);\n                const result = await agent.processCommand(input.trim());\n                setHistory(prev => [...prev, { command: input.trim(), result }]);\n                setInput('');\n                setIsProcessing(false);\n            }\n            return;\n        }\n        if (key.backspace || key.delete) {\n            setInput(prev => prev.slice(0, -1));\n            return;\n        }\n        if (inputChar && !key.ctrl && !key.meta) {\n            setInput(prev => prev + inputChar);\n        }\n    });\n    const renderResult = (result) => {\n        if (result.success) {\n            return (React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 },\n                React.createElement(Text, { color: \"green\" }, \"\\u2713 Success\"),\n                result.output && (React.createElement(Box, { marginLeft: 2 },\n                    React.createElement(Text, null, result.output)))));\n        }\n        else {\n            return (React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 },\n                React.createElement(Text, { color: \"red\" }, \"\\u2717 Error\"),\n                result.error && (React.createElement(Box, { marginLeft: 2 },\n                    React.createElement(Text, { color: \"red\" }, result.error)))));\n        }\n    };\n    const handleConfirmation = (dontAskAgain) => {\n        confirmationService.confirmOperation(true, dontAskAgain);\n        setConfirmationOptions(null);\n    };\n    const handleRejection = (feedback) => {\n        confirmationService.rejectOperation(feedback);\n        setConfirmationOptions(null);\n    };\n    if (confirmationOptions) {\n        return (React.createElement(ConfirmationDialog, { operation: confirmationOptions.operation, filename: confirmationOptions.filename, showVSCodeOpen: confirmationOptions.showVSCodeOpen, onConfirm: handleConfirmation, onReject: handleRejection }));\n    }\n    return (React.createElement(Box, { flexDirection: \"column\", padding: 1 },\n        React.createElement(Box, { marginBottom: 1 },\n            React.createElement(Text, { bold: true, color: \"cyan\" }, \"\\uD83D\\uDD27 Grok CLI - Text Editor Agent\")),\n        React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 },\n            React.createElement(Text, { dimColor: true }, \"Available commands: view, str_replace, create, insert, undo_edit, bash, help\"),\n            React.createElement(Text, { dimColor: true }, \"Type 'help' for detailed usage, 'exit' or Ctrl+C to quit\")),\n        React.createElement(Box, { flexDirection: \"column\", marginBottom: 1 }, history.slice(-10).map((entry, index) => (React.createElement(Box, { key: index, flexDirection: \"column\", marginBottom: 1 },\n            React.createElement(Box, null,\n                React.createElement(Text, { color: \"blue\" }, \"$ \"),\n                React.createElement(Text, null, entry.command)),\n            renderResult(entry.result))))),\n        React.createElement(Box, null,\n            React.createElement(Text, { color: \"blue\" }, \"$ \"),\n            React.createElement(Text, null,\n                input,\n                !isProcessing && React.createElement(Text, { color: \"white\" }, \"\\u2588\")),\n            isProcessing && React.createElement(Text, { color: \"yellow\" }, \" (processing...)\"))));\n}\n//# sourceMappingURL=app.js.map"
  },
  "dist/grok/client.js": {
    "path": "dist/grok/client.js",
    "hash": "6f6e772c3a594595dede41d1a49ad96a0f60022fe17bc6f79274f6b96cc7bbdd",
    "size": 19978,
    "timestamp": 1764704879306,
    "content": "import OpenAI from \"openai\";\nimport { debugLog } from \"../utils/debug-logger.js\";\nexport class GrokClient {\n    client;\n    currentModel; // ‚úÖ NO HARDCODED DEFAULT\n    defaultMaxTokens;\n    apiKey; // ‚úÖ Store for later access\n    baseURL; // ‚úÖ Store baseURL to detect provider\n    constructor(apiKey, model, baseURL) {\n        this.apiKey = apiKey; // ‚úÖ Store\n        this.baseURL = baseURL || process.env.GROK_BASE_URL || \"https://api.x.ai/v1\";\n        console.log(`üèóÔ∏è  GrokClient constructor: model=${model}, baseURL=${this.baseURL}, apiKey=${apiKey.slice(0, 10)}...`);\n        this.client = new OpenAI({\n            apiKey,\n            baseURL: this.baseURL,\n            timeout: 360000,\n        });\n        const envMax = Number(process.env.GROK_MAX_TOKENS);\n        this.defaultMaxTokens = Number.isFinite(envMax) && envMax > 0 ? envMax : 1536;\n        this.currentModel = model; // ‚úÖ Use provided model (required)\n        console.log(`‚úÖ GrokClient initialized with baseURL=${this.baseURL}`);\n    }\n    /**\n     * Detect current provider from baseURL\n     */\n    getProvider() {\n        if (this.baseURL.includes('x.ai'))\n            return 'grok';\n        if (this.baseURL.includes('openai.com'))\n            return 'openai';\n        if (this.baseURL.includes('anthropic.com'))\n            return 'claude';\n        if (this.baseURL.includes('mistral.ai'))\n            return 'mistral';\n        if (this.baseURL.includes('deepseek.com'))\n            return 'deepseek';\n        return 'grok'; // Default\n    }\n    /**\n     * Check if current provider is Grok\n     */\n    isGrokProvider() {\n        return this.baseURL.includes('x.ai');\n    }\n    /**\n     * Check if current model is a reasoning model (o1, o3, gpt-5)\n     * These models require max_completion_tokens and no temperature\n     */\n    isReasoningModel(model) {\n        const modelName = (model || this.currentModel).toLowerCase();\n        return modelName.startsWith('o1') ||\n            modelName.startsWith('o3') ||\n            modelName.startsWith('gpt-5');\n    }\n    /**\n     * Format tools for specific provider\n     */\n    formatToolsForProvider(tools) {\n        const provider = this.getProvider();\n        if (provider === 'mistral') {\n            // ‚úÖ Mistral format: Standard OpenAI-compatible with full type support\n            // According to https://docs.mistral.ai/agents/tools/function_calling\n            // Mistral supports: string, number, boolean, object, array\n            return tools.map(tool => ({\n                type: \"function\",\n                function: {\n                    name: tool.function.name,\n                    description: tool.function.description,\n                    parameters: {\n                        type: \"object\",\n                        properties: tool.function.parameters.properties, // ‚úÖ Keep original types\n                        required: tool.function.parameters.required || [],\n                    }\n                }\n            }));\n        }\n        if (provider === 'claude') {\n            // Claude uses a different format (tools with input_schema)\n            return tools.map(tool => ({\n                name: tool.function.name,\n                description: tool.function.description,\n                input_schema: {\n                    type: \"object\",\n                    properties: tool.function.parameters.properties,\n                    required: tool.function.parameters.required || [],\n                }\n            }));\n        }\n        // Grok, OpenAI, DeepSeek use standard OpenAI format\n        return tools;\n    }\n    /**\n     * Clean messages for provider compatibility\n     */\n    cleanMessagesForProvider(messages) {\n        const provider = this.getProvider();\n        // ‚úÖ FIRST: Remove invalid assistant messages (empty content + no tool_calls)\n        // This causes 400 errors with all providers (OpenAI, Mistral, etc.)\n        messages = messages.filter(msg => {\n            if (msg.role === 'assistant') {\n                // Check if has content (handle both string and array types)\n                const hasContent = msg.content &&\n                    (typeof msg.content === 'string'\n                        ? msg.content.trim().length > 0\n                        : msg.content.length > 0);\n                const hasToolCalls = msg.tool_calls && msg.tool_calls.length > 0;\n                // Keep only if has content OR tool_calls\n                if (!hasContent && !hasToolCalls) {\n                    debugLog.log(`üóëÔ∏è  Removing invalid assistant message (no content, no tool_calls)`);\n                    return false;\n                }\n            }\n            return true;\n        });\n        if (provider === 'mistral') {\n            // ‚úÖ Mistral-specific cleaning (strict message structure rules)\n            // According to https://docs.mistral.ai/agents/tools/function_calling\n            // Mistral requires:\n            // 1. No consecutive assistant messages (must have user between)\n            // 2. Tool calls must have 'type': 'function'\n            // 3. Proper alternation of user/assistant\n            const cleaned = [];\n            let lastRole = null;\n            for (let i = 0; i < messages.length; i++) {\n                const msg = messages[i];\n                // Keep system messages as-is (only at start)\n                if (msg.role === 'system') {\n                    cleaned.push(msg);\n                    lastRole = 'system';\n                    continue;\n                }\n                // ‚úÖ Handle assistant messages\n                if (msg.role === 'assistant') {\n                    // Strip tool_calls if present (Mistral doesn't need them in history)\n                    if (msg.tool_calls) {\n                        debugLog.log(`üîÑ Mistral: Stripping tool_calls from assistant message`);\n                        // If last was also assistant, inject separator user message\n                        if (lastRole === 'assistant') {\n                            debugLog.log(`‚ö†Ô∏è  Mistral: Consecutive assistant messages detected, adding separator`);\n                            cleaned.push({\n                                role: 'user',\n                                content: '[Continue]',\n                            });\n                        }\n                        // Push assistant WITHOUT tool_calls (was the working solution from bc275d3)\n                        cleaned.push({\n                            role: 'assistant',\n                            content: msg.content || '[Using tools...]',\n                        });\n                        lastRole = 'assistant';\n                        continue;\n                    }\n                    // Assistant without tool_calls: keep if has content\n                    if (msg.content && (typeof msg.content === 'string' ? msg.content.trim() : true)) {\n                        // If last was also assistant, inject separator\n                        if (lastRole === 'assistant') {\n                            debugLog.log(`‚ö†Ô∏è  Mistral: Consecutive assistant messages detected, adding separator`);\n                            cleaned.push({\n                                role: 'user',\n                                content: '[Continue]',\n                            });\n                        }\n                        cleaned.push(msg);\n                        lastRole = 'assistant';\n                        continue;\n                    }\n                    // Skip empty assistant messages (already filtered but double-check)\n                    debugLog.log(`üóëÔ∏è  Mistral: Skipping empty assistant message`);\n                    continue;\n                }\n                // ‚úÖ Handle tool messages - Convert ALL to user messages for Mistral\n                if (msg.role === 'tool') {\n                    // ‚úÖ Mistral doesn't support role:\"tool\" even with 'name' field\n                    // Convert ALL tool messages to user messages (not just orphans!)\n                    // This was the working solution from commit bc275d3 (22 Nov)\n                    debugLog.log(`üîÑ Mistral: Converting tool message to user (content length: ${msg.content.length})`);\n                    cleaned.push({\n                        role: 'user',\n                        content: `[Tool Result]\\n${msg.content}`,\n                    });\n                    lastRole = 'user';\n                    continue;\n                }\n                // ‚úÖ Handle user messages (always keep)\n                if (msg.role === 'user') {\n                    cleaned.push(msg);\n                    lastRole = 'user';\n                    continue;\n                }\n                // Other messages: keep as-is\n                cleaned.push(msg);\n                lastRole = msg.role;\n            }\n            debugLog.log(`‚úÖ Mistral cleaning: ${messages.length} ‚Üí ${cleaned.length} messages`);\n            return cleaned;\n        }\n        // For OpenAI, Grok, DeepSeek: Ensure tool_calls have 'type' field + convert orphaned tool messages\n        if (provider === 'openai' || provider === 'grok' || provider === 'deepseek') {\n            const cleaned = [];\n            for (let i = 0; i < messages.length; i++) {\n                const msg = messages[i];\n                // If it's a tool message, check if previous message has tool_calls\n                if (msg.role === 'tool') {\n                    // Find previous non-tool message\n                    let prevAssistant = null;\n                    for (let j = i - 1; j >= 0; j--) {\n                        if (messages[j].role === 'assistant') {\n                            prevAssistant = messages[j];\n                            break;\n                        }\n                    }\n                    // If tool has valid parent: keep as-is\n                    if (prevAssistant && prevAssistant.tool_calls) {\n                        cleaned.push(msg);\n                    }\n                    else {\n                        // Orphaned tool: convert to user to preserve content\n                        // Better than losing valuable context!\n                        cleaned.push({\n                            role: 'user',\n                            content: `[Tool Result - Previous Context]\\n${msg.content}`,\n                        });\n                    }\n                    continue;\n                }\n                // Fix assistant messages with tool_calls (add missing 'type' field)\n                if (msg.role === 'assistant' && msg.tool_calls) {\n                    const toolCalls = msg.tool_calls.map((tc) => ({\n                        id: tc.id,\n                        type: tc.type || 'function', // ‚úÖ Add missing 'type' field\n                        function: tc.function,\n                    }));\n                    cleaned.push({\n                        ...msg,\n                        tool_calls: toolCalls,\n                    });\n                    continue;\n                }\n                // Other messages: keep as-is\n                cleaned.push(msg);\n            }\n            return cleaned;\n        }\n        // Other providers (Claude): return as-is\n        return messages;\n    }\n    /**\n     * Truncate messages to fit context window\n     */\n    truncateMessages(messages, maxMessages = 50) {\n        if (messages.length <= maxMessages) {\n            return messages;\n        }\n        // Keep system message + last N messages\n        const systemMessages = messages.filter(m => m.role === 'system');\n        const otherMessages = messages.filter(m => m.role !== 'system');\n        const recentMessages = otherMessages.slice(-maxMessages);\n        debugLog.log(`‚ö†Ô∏è  Truncated messages: ${messages.length} ‚Üí ${systemMessages.length + recentMessages.length}`);\n        return [...systemMessages, ...recentMessages];\n    }\n    /**\n     * Additional pruning by rough character budget (provider-sensitive)\n     */\n    pruneByCharBudget(messages, provider) {\n        if (provider !== 'mistral')\n            return messages;\n        const BUDGET = 18000; // rough char budget (~6-8k tokens depending on content)\n        // Always keep first system message if present\n        const systemMsg = messages.find(m => m.role === 'system');\n        const rest = messages.filter(m => m !== systemMsg);\n        let acc = [];\n        let used = systemMsg ? JSON.stringify(systemMsg).length : 0;\n        for (let i = rest.length - 1; i >= 0; i--) {\n            const m = rest[i];\n            const sz = JSON.stringify(m).length;\n            if (used + sz > BUDGET)\n                break;\n            acc.push(m);\n            used += sz;\n        }\n        acc.reverse();\n        return systemMsg ? [systemMsg, ...acc] : acc;\n    }\n    /**\n     * Build request payload specific to provider\n     */\n    buildRequestPayload(modelToUse, messages, tools, searchOptions) {\n        const provider = this.getProvider();\n        const isReasoning = this.isReasoningModel(modelToUse);\n        // ‚úÖ Truncate messages for context window (especially for Mistral)\n        const truncatedMessages = this.truncateMessages(messages, 50);\n        const prunedByBudget = this.pruneByCharBudget(truncatedMessages, provider);\n        // ‚úÖ Clean messages for provider compatibility (currently no-op)\n        const cleanedMessages = this.cleanMessagesForProvider(prunedByBudget);\n        const requestPayload = {\n            model: modelToUse,\n            messages: cleanedMessages,\n        };\n        // Add tools if provided (formatted for provider)\n        if (tools && tools.length > 0) {\n            const formattedTools = this.formatToolsForProvider(tools);\n            if (provider === 'claude') {\n                requestPayload.tools = formattedTools;\n                // Claude doesn't use tool_choice in the same way\n            }\n            else if (provider === 'mistral') {\n                // Mistral: tools without tool_choice\n                requestPayload.tools = formattedTools;\n            }\n            else {\n                requestPayload.tools = formattedTools;\n                requestPayload.tool_choice = \"auto\";\n            }\n        }\n        // Add provider-specific parameters\n        if (provider === 'claude') {\n            // Claude uses max_tokens (not max_completion_tokens)\n            requestPayload.max_tokens = this.defaultMaxTokens;\n            // Claude doesn't use temperature in tool calls\n            if (!tools || tools.length === 0) {\n                requestPayload.temperature = 0.7;\n            }\n        }\n        else if (isReasoning) {\n            // Reasoning models (o1, o3, gpt-5): max_completion_tokens, no temperature\n            requestPayload.max_completion_tokens = this.defaultMaxTokens;\n        }\n        else {\n            // Standard models: temperature + max_tokens\n            requestPayload.temperature = 0.7;\n            requestPayload.max_tokens = this.defaultMaxTokens;\n        }\n        // Grok-specific: search_parameters\n        if (provider === 'grok' && searchOptions?.search_parameters) {\n            requestPayload.search_parameters = searchOptions.search_parameters;\n        }\n        return requestPayload;\n    }\n    setModel(model) {\n        this.currentModel = model;\n    }\n    getCurrentModel() {\n        return this.currentModel;\n    }\n    // ‚úÖ NEW: Get API key for session switching\n    getApiKey() {\n        return this.apiKey;\n    }\n    async chat(messages, tools, model, searchOptions) {\n        const modelToUse = model || this.currentModel;\n        const provider = this.getProvider();\n        debugLog.log(`\\nüì° GrokClient.chat() - provider: ${provider}, baseURL: ${this.baseURL}, model: ${modelToUse}`);\n        // ‚úÖ Build provider-specific request payload\n        const requestPayload = this.buildRequestPayload(modelToUse, messages, tools, searchOptions);\n        debugLog.log(`üì§ Request payload:`, {\n            provider,\n            baseURL: this.baseURL,\n            model: requestPayload.model,\n            toolsCount: requestPayload.tools?.length || 0,\n            messagesCount: requestPayload.messages?.length || 0,\n            hasTemperature: 'temperature' in requestPayload,\n            hasMaxTokens: 'max_tokens' in requestPayload,\n            hasMaxCompletionTokens: 'max_completion_tokens' in requestPayload,\n            temperature: requestPayload.temperature,\n            max_tokens: requestPayload.max_tokens,\n            tool_choice: requestPayload.tool_choice,\n        });\n        try {\n            const response = await this.client.chat.completions.create(requestPayload);\n            debugLog.log(`‚úÖ API Response OK - model: ${response.model}`);\n            return response;\n        }\n        catch (error) {\n            debugLog.error(`‚ùå API Error:`, {\n                provider,\n                message: error.message,\n                status: error.status,\n                code: error.code,\n                type: error.type,\n                requestHadTools: requestPayload.tools?.length || 0,\n                requestHadMessages: requestPayload.messages?.length || 0,\n                baseURL: this.baseURL,\n                model: modelToUse,\n            });\n            throw new Error(`Grok API error: ${error.message}`);\n        }\n    }\n    async *chatStream(messages, tools, model, searchOptions) {\n        const modelToUse = model || this.currentModel;\n        const provider = this.getProvider();\n        debugLog.log(`\\nüåä GrokClient.chatStream() - provider: ${provider}, baseURL: ${this.baseURL}, model: ${modelToUse}`);\n        // ‚úÖ Build provider-specific request payload\n        const requestPayload = this.buildRequestPayload(modelToUse, messages, tools, searchOptions);\n        requestPayload.stream = true; // Enable streaming\n        debugLog.log(`üì§ Stream Request payload:`, {\n            provider,\n            baseURL: this.baseURL,\n            model: requestPayload.model,\n            toolsCount: requestPayload.tools?.length || 0,\n            messagesCount: requestPayload.messages?.length || 0,\n            hasTemperature: 'temperature' in requestPayload,\n            hasMaxTokens: 'max_tokens' in requestPayload,\n            temperature: requestPayload.temperature,\n            max_tokens: requestPayload.max_tokens,\n            tool_choice: requestPayload.tool_choice,\n            stream: true,\n        });\n        // ‚úÖ Log ACTUAL payload being sent (for debugging Mistral issue)\n        debugLog.log(`üìã ACTUAL REQUEST PAYLOAD (complete):`, JSON.stringify({\n            model: requestPayload.model,\n            messages: requestPayload.messages,\n            tools: requestPayload.tools,\n            tool_choice: requestPayload.tool_choice,\n            temperature: requestPayload.temperature,\n            max_tokens: requestPayload.max_tokens,\n            stream: requestPayload.stream,\n        }, null, 2));\n        try {\n            const stream = (await this.client.chat.completions.create(requestPayload));\n            debugLog.log(`‚úÖ Stream started successfully`);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n            debugLog.log(`‚úÖ Stream completed`);\n        }\n        catch (error) {\n            debugLog.error(`‚ùå Stream Error:`, {\n                provider,\n                message: error.message,\n                status: error.status,\n                code: error.code,\n                type: error.type,\n                requestHadTools: requestPayload.tools?.length || 0,\n                requestHadMessages: requestPayload.messages?.length || 0,\n                baseURL: this.baseURL,\n                model: modelToUse,\n            });\n            throw new Error(`Grok API error: ${error.message}`);\n        }\n    }\n    async search(query, searchParameters) {\n        const searchMessage = {\n            role: \"user\",\n            content: query,\n        };\n        const searchOptions = {\n            search_parameters: searchParameters || { mode: \"on\" },\n        };\n        return this.chat([searchMessage], [], undefined, searchOptions);\n    }\n}\n//# sourceMappingURL=client.js.map"
  },
  "dist/grok/tools.js": {
    "path": "dist/grok/tools.js",
    "hash": "ced5777dc850a6e3b48ba33c5c0733c2fbba3590bf1a9bcd64d821334f410669",
    "size": 38652,
    "timestamp": 1764704879306,
    "content": "import { MCPManager } from \"../mcp/client.js\";\nimport { loadMCPConfig } from \"../mcp/config.js\";\nconst BASE_GROK_TOOLS = [\n    {\n        type: \"function\",\n        function: {\n            name: \"view_file\",\n            description: \"View contents of a file or list directory contents\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    path: {\n                        type: \"string\",\n                        description: \"Path to file or directory to view\",\n                    },\n                    start_line: {\n                        type: \"number\",\n                        description: \"Starting line number for partial file view (optional)\",\n                    },\n                    end_line: {\n                        type: \"number\",\n                        description: \"Ending line number for partial file view (optional)\",\n                    },\n                },\n                required: [\"path\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"apply_patch\",\n            description: \"Apply a unified diff (git-style) patch to the workspace. Use this for multi-file edits.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    patch: {\n                        type: \"string\",\n                        description: \"Unified diff content. Include ---/+++ and @@ hunks.\",\n                    },\n                    dry_run: {\n                        type: \"boolean\",\n                        description: \"If true, validate without writing changes.\",\n                    },\n                },\n                required: [\"patch\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"create_file\",\n            description: \"Create a new file with specified content\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    path: {\n                        type: \"string\",\n                        description: \"Path where the file should be created\",\n                    },\n                    content: {\n                        type: \"string\",\n                        description: \"Content to write to the file\",\n                    },\n                },\n                required: [\"path\", \"content\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"str_replace_editor\",\n            description: \"Replace specific text in a file. Use this for single line edits only\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    path: {\n                        type: \"string\",\n                        description: \"Path to the file to edit\",\n                    },\n                    old_str: {\n                        type: \"string\",\n                        description: \"Text to replace (must match exactly, or will use fuzzy matching for multi-line strings)\",\n                    },\n                    new_str: {\n                        type: \"string\",\n                        description: \"Text to replace with\",\n                    },\n                    replace_all: {\n                        type: \"boolean\",\n                        description: \"Replace all occurrences (default: false, only replaces first occurrence)\",\n                    },\n                },\n                required: [\"path\", \"old_str\", \"new_str\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"bash\",\n            description: \"Execute a bash command\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    command: {\n                        type: \"string\",\n                        description: \"The bash command to execute\",\n                    },\n                },\n                required: [\"command\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"search\",\n            description: \"Unified search tool for finding text content or files (similar to Cursor's search)\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    query: {\n                        type: \"string\",\n                        description: \"Text to search for or file name/path pattern\",\n                    },\n                    search_type: {\n                        type: \"string\",\n                        enum: [\"text\", \"files\", \"both\"],\n                        description: \"Type of search: 'text' for content search, 'files' for file names, 'both' for both (default: 'both')\",\n                    },\n                    include_pattern: {\n                        type: \"string\",\n                        description: \"Glob pattern for files to include (e.g. '*.ts', '*.js')\",\n                    },\n                    exclude_pattern: {\n                        type: \"string\",\n                        description: \"Glob pattern for files to exclude (e.g. '*.log', 'node_modules')\",\n                    },\n                    case_sensitive: {\n                        type: \"boolean\",\n                        description: \"Whether search should be case sensitive (default: false)\",\n                    },\n                    whole_word: {\n                        type: \"boolean\",\n                        description: \"Whether to match whole words only (default: false)\",\n                    },\n                    regex: {\n                        type: \"boolean\",\n                        description: \"Whether query is a regex pattern (default: false)\",\n                    },\n                    max_results: {\n                        type: \"number\",\n                        description: \"Maximum number of results to return (default: 50)\",\n                    },\n                    file_types: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        description: \"File types to search (e.g. ['js', 'ts', 'py'])\",\n                    },\n                    include_hidden: {\n                        type: \"boolean\",\n                        description: \"Whether to include hidden files (default: false)\",\n                    },\n                },\n                required: [\"query\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"create_todo_list\",\n            description: \"Create a new todo list for planning and tracking tasks\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    todos: {\n                        type: \"array\",\n                        description: \"Array of todo items\",\n                        items: {\n                            type: \"object\",\n                            properties: {\n                                id: {\n                                    type: \"string\",\n                                    description: \"Unique identifier for the todo item\",\n                                },\n                                content: {\n                                    type: \"string\",\n                                    description: \"Description of the todo item\",\n                                },\n                                status: {\n                                    type: \"string\",\n                                    enum: [\"pending\", \"in_progress\", \"completed\"],\n                                    description: \"Current status of the todo item\",\n                                },\n                                priority: {\n                                    type: \"string\",\n                                    enum: [\"high\", \"medium\", \"low\"],\n                                    description: \"Priority level of the todo item\",\n                                },\n                            },\n                            required: [\"id\", \"content\", \"status\", \"priority\"],\n                        },\n                    },\n                },\n                required: [\"todos\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"update_todo_list\",\n            description: \"Update existing todos in the todo list\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    updates: {\n                        type: \"array\",\n                        description: \"Array of todo updates\",\n                        items: {\n                            type: \"object\",\n                            properties: {\n                                id: {\n                                    type: \"string\",\n                                    description: \"ID of the todo item to update\",\n                                },\n                                status: {\n                                    type: \"string\",\n                                    enum: [\"pending\", \"in_progress\", \"completed\"],\n                                    description: \"New status for the todo item\",\n                                },\n                                content: {\n                                    type: \"string\",\n                                    description: \"New content for the todo item\",\n                                },\n                                priority: {\n                                    type: \"string\",\n                                    enum: [\"high\", \"medium\", \"low\"],\n                                    description: \"New priority for the todo item\",\n                                },\n                            },\n                            required: [\"id\"],\n                        },\n                    },\n                },\n                required: [\"updates\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"get_my_identity\",\n            description: \"Get factual information about your own model identity, provider, and configuration. Use this if you need to verify who you are, especially after noticing inconsistencies in conversation history.\",\n            parameters: {\n                type: \"object\",\n                properties: {},\n                required: [],\n            },\n        },\n    },\n    // ============================================\n    // SESSION MANAGEMENT TOOLS (Git-like)\n    // ============================================\n    {\n        type: \"function\",\n        function: {\n            name: \"session_list\",\n            description: \"List all conversation sessions with details (ID, directory, model, message count, dates). Use this to see available sessions before switching or for conversation management.\",\n            parameters: {\n                type: \"object\",\n                properties: {},\n                required: [],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"session_switch\",\n            description: \"Switch to a different conversation session. Changes working directory and loads conversation history. **CRITICAL: ALWAYS ask user permission before calling.** Explain what will happen and get explicit approval.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    session_id: {\n                        type: \"number\",\n                        description: \"ID of the session to switch to (use session_list to see available sessions)\",\n                    },\n                },\n                required: [\"session_id\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"session_new\",\n            description: `‚ö†Ô∏è CRITICAL: Before using this tool, ASK USER to clarify their intent!\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nTWO TOOLS AVAILABLE FOR SESSION/STATE CREATION - Ask user to choose:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üìÅ session_new (THIS TOOL) - Simple Session Creation             ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Starting fresh conversation in new directory                   ‚îÇ\n‚îÇ ‚Ä¢ Git repository cloning (CURRENT HEAD state)                    ‚îÇ\n‚îÇ ‚Ä¢ File copying (CURRENT files, excluding .git/node_modules)      ‚îÇ\n‚îÇ ‚Ä¢ Importing conversation history by date range                   ‚îÇ\n‚îÇ ‚Ä¢ Simple event sourcing initialization (via from-rewind mode)    ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ INITIALIZATION MODES (init_mode parameter):                      ‚îÇ\n‚îÇ ‚Ä¢ 'empty': Empty directory (default)                             ‚îÇ\n‚îÇ ‚Ä¢ 'clone-git': Clone current Git repo at HEAD                    ‚îÇ\n‚îÇ ‚Ä¢ 'copy-files': Copy current files (excludes .git, node_modules) ‚îÇ\n‚îÇ ‚Ä¢ 'from-rewind': Initialize from event sourcing timestamp        ‚îÇ\n‚îÇ   ‚îî‚îÄ> Requires: rewind_timestamp (ISO 8601)                      ‚îÇ\n‚îÇ   ‚îî‚îÄ> Optional: rewind_git_mode ('none'/'metadata'/'full')      ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ CONVERSATION IMPORT OPTIONS:                                     ‚îÇ\n‚îÇ ‚Ä¢ import_history: Import conversation history (boolean)          ‚îÇ\n‚îÇ ‚Ä¢ from_session_id: Source session ID (default: current)          ‚îÇ\n‚îÇ ‚Ä¢ date_range_start: Filter start date (ISO 8601 / YYYY-MM-DD)   ‚îÇ\n‚îÇ ‚Ä¢ date_range_end: Filter end date (ISO 8601 / YYYY-MM-DD)       ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ MODEL/PROVIDER OPTIONS:                                          ‚îÇ\n‚îÇ ‚Ä¢ model: Model to use (e.g., 'grok-2-1212', 'claude-sonnet-4')  ‚îÇ\n‚îÇ ‚Ä¢ provider: Provider (e.g., 'xai', 'anthropic')                  ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ LIMITATIONS:                                                      ‚îÇ\n‚îÇ ‚Ä¢ 'from-rewind' has limited options vs rewind_to tool            ‚îÇ\n‚îÇ ‚Ä¢ No autoCheckout, compareWith options                           ‚îÇ\n‚îÇ ‚Ä¢ For advanced rewind: use rewind_to tool instead                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚è∞ rewind_to - TIME MACHINE (Event Sourcing Alternative)          ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Recovering EXACT state at specific past timestamp              ‚îÇ\n‚îÇ ‚Ä¢ Event sourcing replay from timeline.db                         ‚îÇ\n‚îÇ ‚Ä¢ Full Git repository reconstruction (ANY commit, not just HEAD) ‚îÇ\n‚îÇ ‚Ä¢ Advanced options: compare dirs, auto-checkout, git modes       ‚îÇ\n‚îÇ ‚Ä¢ Automatically create session in rewinded state                 ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ POWERFUL FEATURES:                                                ‚îÇ\n‚îÇ ‚Ä¢ gitMode: 'none', 'metadata', or 'full' Git reconstruction      ‚îÇ\n‚îÇ ‚Ä¢ autoCheckout: Automatically cd to rewinded directory           ‚îÇ\n‚îÇ ‚Ä¢ compareWith: Generate diff report with another directory       ‚îÇ\n‚îÇ ‚Ä¢ createSession: Auto-create session in past state               ‚îÇ\n‚îÇ ‚Ä¢ Merkle DAG: Reconstruct exact file contents from blobs         ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ REQUIREMENTS:                                                     ‚îÇ\n‚îÇ ‚Ä¢ Exact timestamp (use timeline_query to find available times)   ‚îÇ\n‚îÇ ‚Ä¢ Timeline.db with event history                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nüî¥ MANDATORY: ASK USER BEFORE PROCEEDING:\n\n\"I can help you create a new session. There are TWO approaches available:\n\n1Ô∏è‚É£ **Simple Session Creation** (session_new - CURRENT state):\n   ‚úì Clone current Git repository (HEAD) - init_mode='clone-git'\n   ‚úì Copy current files to new directory - init_mode='copy-files'\n   ‚úì Start with empty directory - init_mode='empty' (default)\n   ‚úì Import conversation history by date range\n   ‚úì Basic event sourcing init - init_mode='from-rewind'\n   \n   Available Options:\n   ‚Ä¢ init_mode: 'empty', 'clone-git', 'copy-files', 'from-rewind'\n   ‚Ä¢ rewind_timestamp: For 'from-rewind' mode (ISO 8601)\n   ‚Ä¢ rewind_git_mode: Git mode for rewind ('none'/'metadata'/'full')\n   ‚Ä¢ import_history, from_session_id, date_range_start/end\n   ‚Ä¢ model, provider\n   \n   Limitations:\n   ‚úó from-rewind has fewer options than rewind_to\n   ‚úó No autoCheckout, compareWith features\n\n2Ô∏è‚É£ **Time Machine Recovery** (rewind_to - PAST state):\n   ‚úì Recover EXACT state from any past timestamp\n   ‚úì Event sourcing replay from timeline.db\n   ‚úì Full Git reconstruction at specific commit\n   ‚úì Advanced options (compare, auto-checkout, git modes)\n   ‚úì Can create session automatically in past state\n   ‚úó Requires exact timestamp\n   ‚úó More complex operation\n\nYour request: [describe what you understood]\n\nWhich approach do you need?\n‚Ä¢ Work with CURRENT state ‚Üí I'll use session_new\n‚Ä¢ Recover a PAST state at specific time ‚Üí I'll use rewind_to\n\nPlease confirm your choice so I can proceed correctly.\"\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nPROCEED WITH session_new ONLY AFTER USER CONFIRMS \"current state\" approach.`,\n            parameters: {\n                type: \"object\",\n                properties: {\n                    directory: {\n                        type: \"string\",\n                        description: \"Target directory for new session (absolute or relative path). Will be created if doesn't exist.\",\n                    },\n                    init_mode: {\n                        type: \"string\",\n                        enum: [\"empty\", \"clone-git\", \"copy-files\", \"from-rewind\"],\n                        description: `Directory initialization mode (default: 'empty'):\n‚Ä¢ 'empty': Create empty directory\n‚Ä¢ 'clone-git': Clone current Git repository (HEAD state) to target directory\n‚Ä¢ 'copy-files': Copy current files (excluding .git, node_modules, hidden files) to target directory\n‚Ä¢ 'from-rewind': Initialize from event sourcing rewind at specific timestamp (requires rewind_timestamp)\n\n‚ö†Ô∏è For 'from-rewind': Consider using rewind_to tool instead for full control over gitMode, autoCheckout, compareWith options.`,\n                    },\n                    rewind_timestamp: {\n                        type: \"string\",\n                        description: \"Timestamp for 'from-rewind' init mode (ISO 8601: 2025-11-28T15:00:00Z). Only used when init_mode='from-rewind'. Reconstructs directory state via event sourcing.\",\n                    },\n                    rewind_git_mode: {\n                        type: \"string\",\n                        enum: [\"none\", \"metadata\", \"full\"],\n                        description: \"Git mode for 'from-rewind' (default: 'full'). Only used when init_mode='from-rewind'. See rewind_to tool for detailed gitMode documentation.\",\n                    },\n                    import_history: {\n                        type: \"boolean\",\n                        description: \"Whether to import conversation history from source session (default: false)\",\n                    },\n                    from_session_id: {\n                        type: \"number\",\n                        description: \"Session ID to import conversation history from (default: current session). Used when import_history=true.\",\n                    },\n                    date_range_start: {\n                        type: \"string\",\n                        description: \"Start date for conversation history filtering (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY). Used when import_history=true.\",\n                    },\n                    date_range_end: {\n                        type: \"string\",\n                        description: \"End date for conversation history filtering (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY). Used when import_history=true.\",\n                    },\n                    model: {\n                        type: \"string\",\n                        description: \"Model to use in new session (optional, e.g., 'grok-2-1212', 'claude-sonnet-4')\",\n                    },\n                    provider: {\n                        type: \"string\",\n                        description: \"Provider to use in new session (optional, e.g., 'xai', 'anthropic')\",\n                    },\n                },\n                required: [\"directory\"],\n            },\n        },\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"session_rewind\",\n            description: \"Perform Git rewind: synchronize conversation history AND code state to a specific date range. Creates new session in target directory with filtered conversation messages and Git repository at corresponding commit. **CRITICAL: This is the most powerful operation - ALWAYS explain the plan in detail and get explicit user permission before calling.** This modifies filesystem and Git state.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    target_directory: {\n                        type: \"string\",\n                        description: \"Directory for rewound session (will be created, must not exist)\",\n                    },\n                    date_range_start: {\n                        type: \"string\",\n                        description: \"Start date for rewind (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY)\",\n                    },\n                    date_range_end: {\n                        type: \"string\",\n                        description: \"End date for rewind (ISO 8601, YYYY-MM-DD, or DD/MM/YYYY)\",\n                    },\n                    from_session_id: {\n                        type: \"number\",\n                        description: \"Session to rewind from (default: current session)\",\n                    },\n                    preserve_git_history: {\n                        type: \"boolean\",\n                        description: \"If true, clone full Git history. If false, use git archive (lightweight). Default: false\",\n                    },\n                },\n                required: [\"target_directory\", \"date_range_start\", \"date_range_end\"],\n            },\n        },\n    },\n];\n// Morph Fast Apply tool (conditional)\nconst MORPH_EDIT_TOOL = {\n    type: \"function\",\n    function: {\n        name: \"edit_file\",\n        description: \"Use this tool to make an edit to an existing file.\\n\\nThis will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.\\nWhen writing the edit, you should specify each edit in sequence, with the special comment // ... existing code ... to represent unchanged code in between edited lines.\\n\\nFor example:\\n\\n// ... existing code ...\\nFIRST_EDIT\\n// ... existing code ...\\nSECOND_EDIT\\n// ... existing code ...\\nTHIRD_EDIT\\n// ... existing code ...\\n\\nYou should still bias towards repeating as few lines of the original file as possible to convey the change.\\nBut, each edit should contain sufficient context of unchanged lines around the code you're editing to resolve ambiguity.\\nDO NOT omit spans of pre-existing code (or comments) without using the // ... existing code ... comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.\\nIf you plan on deleting a section, you must provide context before and after to delete it. If the initial code is ```code \\\\n Block 1 \\\\n Block 2 \\\\n Block 3 \\\\n code```, and you want to remove Block 2, you would output ```// ... existing code ... \\\\n Block 1 \\\\n  Block 3 \\\\n // ... existing code ...```.\\nMake sure it is clear what the edit should be, and where it should be applied.\\nMake edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.\",\n        parameters: {\n            type: \"object\",\n            properties: {\n                target_file: {\n                    type: \"string\",\n                    description: \"The target file to modify.\"\n                },\n                instructions: {\n                    type: \"string\",\n                    description: \"A single sentence instruction describing what you are going to do for the sketched edit. This is used to assist the less intelligent model in applying the edit. Use the first person to describe what you are going to do. Use it to disambiguate uncertainty in the edit.\"\n                },\n                code_edit: {\n                    type: \"string\",\n                    description: \"Specify ONLY the precise lines of code that you wish to edit. NEVER specify or write out unchanged code. Instead, represent all unchanged code using the comment of the language you're editing in - example: // ... existing code ...\"\n                }\n            },\n            required: [\"target_file\", \"instructions\", \"code_edit\"]\n        }\n    }\n};\n// Function to build tools array conditionally\nfunction buildGrokTools() {\n    const tools = [...BASE_GROK_TOOLS];\n    // Add Morph Fast Apply tool if API key is available\n    if (process.env.MORPH_API_KEY) {\n        tools.splice(3, 0, MORPH_EDIT_TOOL); // Insert after str_replace_editor\n    }\n    // Add timeline tools\n    tools.push({\n        type: \"function\",\n        function: {\n            name: \"timeline_query\",\n            description: \"Query timeline event log to understand what happened (file modifications, git operations, conversations, tool calls, rewinds).\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    startTime: { type: \"string\", description: \"Start timestamp (ISO string or relative, e.g. '2025-11-28T00:00:00Z' or '2 hours ago')\" },\n                    endTime: { type: \"string\", description: \"End timestamp (ISO string)\" },\n                    categories: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            enum: [\"SESSION\", \"LLM\", \"TOOL\", \"FILE\", \"GIT\", \"REWIND\"],\n                        },\n                        description: \"High-level event categories to filter.\",\n                    },\n                    eventTypes: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        description: \"Specific event types (e.g. FILE_MODIFIED, GIT_COMMIT, REWIND_COMPLETED).\",\n                    },\n                    actor: {\n                        type: \"string\",\n                        description: \"Filter by actor (e.g. 'user', 'system', 'git:username').\",\n                    },\n                    sessionId: {\n                        type: \"number\",\n                        description: \"Filter by session ID.\",\n                    },\n                    aggregateId: {\n                        type: \"string\",\n                        description: \"Filter by aggregate ID (e.g. file path).\",\n                    },\n                    limit: {\n                        type: \"number\",\n                        description: \"Max results (default: 100, max: 1000).\",\n                    },\n                    searchText: {\n                        type: \"string\",\n                        description: \"Search text in event payloads (useful to find specific errors or operations).\",\n                    },\n                    order: {\n                        type: \"string\",\n                        enum: [\"asc\", \"desc\"],\n                        description: \"Sort order: 'asc' (oldest first) or 'desc' (newest first, default).\",\n                    },\n                    statsOnly: {\n                        type: \"boolean\",\n                        description: \"Return only aggregated statistics instead of full event list.\",\n                    },\n                },\n                required: [],\n            },\n        },\n    }, {\n        type: \"function\",\n        function: {\n            name: \"rewind_to\",\n            description: `‚ö†Ô∏è CRITICAL: Before using this tool, ASK USER to clarify their intent AND get explicit permission!\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nTWO TOOLS AVAILABLE FOR SESSION/STATE CREATION - Ask user to choose:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚è∞ rewind_to (THIS TOOL) - TIME MACHINE via Event Sourcing        ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Recovering EXACT state at specific past timestamp              ‚îÇ\n‚îÇ ‚Ä¢ Event sourcing replay from timeline.db Merkle DAG              ‚îÇ\n‚îÇ ‚Ä¢ Full Git repository reconstruction at ANY commit               ‚îÇ\n‚îÇ ‚Ä¢ Advanced operations with multiple options                      ‚îÇ\n‚îÇ ‚Ä¢ Creating session automatically in rewinded past state          ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ POWERFUL FEATURES:                                                ‚îÇ\n‚îÇ ‚Ä¢ gitMode: 'none' | 'metadata' | 'full'                          ‚îÇ\n‚îÇ   - none: No Git information                                     ‚îÇ\n‚îÇ   - metadata: git_state.json with commit/branch info             ‚îÇ\n‚îÇ   - full: Complete .git repository at target commit              ‚îÇ\n‚îÇ ‚Ä¢ autoCheckout: Auto cd to rewinded directory after rewind       ‚îÇ\n‚îÇ ‚Ä¢ compareWith: Generate detailed diff report vs another dir      ‚îÇ\n‚îÇ ‚Ä¢ createSession: Auto-create grokinou session in rewinded state  ‚îÇ\n‚îÇ ‚Ä¢ includeFiles: Reconstruct file contents from Merkle DAG blobs  ‚îÇ\n‚îÇ ‚Ä¢ includeConversations: Import conversation history              ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ HOW IT WORKS (Event Sourcing):                                    ‚îÇ\n‚îÇ 1. Query timeline.db for all events before targetTimestamp       ‚îÇ\n‚îÇ 2. Find nearest snapshot (if exists) for optimization            ‚îÇ\n‚îÇ 3. Replay events from snapshot ‚Üí target time                     ‚îÇ\n‚îÇ 4. Reconstruct files from Merkle DAG blob storage                ‚îÇ\n‚îÇ 5. Materialize Git repository at exact commit (if gitMode‚â†none)  ‚îÇ\n‚îÇ 6. Create session in rewinded directory (if createSession=true)  ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ REQUIREMENTS:                                                     ‚îÇ\n‚îÇ ‚Ä¢ Exact timestamp (ISO 8601: 2025-11-28T14:30:00Z)               ‚îÇ\n‚îÇ ‚Ä¢ Use timeline_query first to find available timestamps          ‚îÇ\n‚îÇ ‚Ä¢ Timeline.db must have event history for target period          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ üìÅ session_new - Simple Session Creation (Alternative)           ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ BEST FOR:                                                         ‚îÇ\n‚îÇ ‚Ä¢ Working with CURRENT state (not past)                          ‚îÇ\n‚îÇ ‚Ä¢ Simple Git clone (HEAD state only)                             ‚îÇ\n‚îÇ ‚Ä¢ File copying (current files)                                   ‚îÇ\n‚îÇ ‚Ä¢ Basic session creation                                         ‚îÇ\n‚îÇ                                                                   ‚îÇ\n‚îÇ LIMITATIONS:                                                      ‚îÇ\n‚îÇ ‚Ä¢ No event sourcing / time travel                                ‚îÇ\n‚îÇ ‚Ä¢ Works only with current state                                  ‚îÇ\n‚îÇ ‚Ä¢ No advanced rewind options                                     ‚îÇ\n‚îÇ ‚Ä¢ Cannot recover past timestamps                                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nüî¥ MANDATORY: ASK USER BEFORE PROCEEDING:\n\n\"I can help you with time-based operations. There are TWO approaches:\n\n1Ô∏è‚É£ **Time Machine** (rewind_to - PAST state):\n   ‚úì Recover EXACT state from specific timestamp\n   ‚úì Event sourcing replay from timeline.db\n   ‚úì Full Git reconstruction at any commit\n   ‚úì Advanced options:\n     - gitMode: none/metadata/full\n     - autoCheckout: Auto cd after rewind\n     - compareWith: Diff with another directory\n     - createSession: Auto-create session\n   ‚úì Merkle DAG for file reconstruction\n   ‚úó Requires exact timestamp\n   ‚úó More complex operation\n\n2Ô∏è‚É£ **Simple Session** (session_new - CURRENT state):\n   ‚úì Clone current Git repository (HEAD)\n   ‚úì Copy current files\n   ‚úì Simpler operation\n   ‚úó No time travel / event sourcing\n   ‚úó Current state only\n\nYour request: [describe what you understood]\n\nQuestions to clarify:\n‚Ä¢ Do you need a PAST state at specific timestamp? ‚Üí rewind_to\n‚Ä¢ Do you need CURRENT state in new directory? ‚Üí session_new\n\nIf using rewind_to, you MUST provide:\n1. Exact timestamp (use timeline_query to find available times)\n   Example: timeline_query with startTime/endTime to see events\n2. Confirmation of options:\n   - gitMode? (none/metadata/full)\n   - autoCheckout? (true/false)\n   - createSession? (true/false)\n   - compareWith? (optional directory path)\n\n**This is a powerful operation that reconstructs exact past state.**\n**I need your explicit permission to proceed.**\n\nPlease confirm:\n‚Ä¢ Exact timestamp you want to rewind to\n‚Ä¢ Which options you want (gitMode, autoCheckout, etc.)\n‚Ä¢ Permission to execute the rewind\"\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nPROCEED WITH rewind_to ONLY AFTER:\n1. User confirms they need PAST state (not current)\n2. User provides exact timestamp\n3. User gives explicit permission\n4. User confirms desired options (gitMode, autoCheckout, compareWith, createSession)`,\n            parameters: {\n                type: \"object\",\n                properties: {\n                    targetTimestamp: { type: \"string\", description: \"Target timestamp (ISO format: 2025-11-28T12:00:00Z)\" },\n                    outputDir: { type: \"string\", description: \"Output directory (default: auto-generated ~/grokinou_rewind_TIMESTAMP)\" },\n                    includeFiles: { type: \"boolean\", description: \"Include file contents reconstruction from Merkle DAG (default: true)\" },\n                    includeConversations: { type: \"boolean\", description: \"Include conversation history import (default: true)\" },\n                    gitMode: {\n                        type: \"string\",\n                        enum: [\"none\", \"metadata\", \"full\"],\n                        description: \"Git mode: 'none'=no git, 'metadata'=git_state.json only, 'full'=complete .git repo (default: metadata)\"\n                    },\n                    createSession: { type: \"boolean\", description: \"Create a new grokinou session in rewinded directory (default: false)\" },\n                    autoCheckout: { type: \"boolean\", description: \"Automatically change working directory (process.cwd) to rewinded directory (default: false)\" },\n                    compareWith: { type: \"string\", description: \"Compare rewinded state with another directory - generates detailed diff report (optional)\" },\n                    reason: { type: \"string\", description: \"Human-readable reason for rewind (for logging and audit trail)\" },\n                },\n                required: [\"targetTimestamp\"],\n            },\n        },\n    }, {\n        type: \"function\",\n        function: {\n            name: \"list_time_points\",\n            description: \"List available snapshots and recent events for rewinding\",\n            parameters: {\n                type: \"object\",\n                properties: {},\n                required: []\n            },\n        },\n    });\n    return tools;\n}\n// Export dynamic tools array\nexport const GROK_TOOLS = buildGrokTools();\n// Global MCP manager instance\nlet mcpManager = null;\nexport function getMCPManager() {\n    if (!mcpManager) {\n        mcpManager = new MCPManager();\n    }\n    return mcpManager;\n}\nexport async function initializeMCPServers() {\n    const manager = getMCPManager();\n    const config = loadMCPConfig();\n    // Store original stderr.write\n    const originalStderrWrite = process.stderr.write;\n    // Temporarily suppress stderr to hide verbose MCP connection logs\n    process.stderr.write = function (chunk, encoding, callback) {\n        // Filter out mcp-remote verbose logs\n        const chunkStr = chunk.toString();\n        if (chunkStr.includes('[') && (chunkStr.includes('Using existing client port') ||\n            chunkStr.includes('Connecting to remote server') ||\n            chunkStr.includes('Using transport strategy') ||\n            chunkStr.includes('Connected to remote server') ||\n            chunkStr.includes('Local STDIO server running') ||\n            chunkStr.includes('Proxy established successfully') ||\n            chunkStr.includes('Local‚ÜíRemote') ||\n            chunkStr.includes('Remote‚ÜíLocal'))) {\n            // Suppress these verbose logs\n            if (callback)\n                callback();\n            return true;\n        }\n        // Allow other stderr output\n        return originalStderrWrite.call(this, chunk, encoding, callback);\n    };\n    try {\n        for (const serverConfig of config.servers) {\n            try {\n                await manager.addServer(serverConfig);\n            }\n            catch (error) {\n                console.warn(`Failed to initialize MCP server ${serverConfig.name}:`, error);\n            }\n        }\n    }\n    finally {\n        // Restore original stderr.write\n        process.stderr.write = originalStderrWrite;\n    }\n}\nexport function convertMCPToolToGrokTool(mcpTool) {\n    return {\n        type: \"function\",\n        function: {\n            name: mcpTool.name,\n            description: mcpTool.description,\n            parameters: mcpTool.inputSchema || {\n                type: \"object\",\n                properties: {},\n                required: []\n            }\n        }\n    };\n}\nexport function addMCPToolsToGrokTools(baseTools) {\n    if (!mcpManager) {\n        return baseTools;\n    }\n    const mcpTools = mcpManager.getTools();\n    const grokMCPTools = mcpTools.map(convertMCPToolToGrokTool);\n    return [...baseTools, ...grokMCPTools];\n}\nexport async function getAllGrokTools() {\n    const manager = getMCPManager();\n    // Try to initialize servers if not already done, but don't block\n    manager.ensureServersInitialized().catch(() => {\n        // Ignore initialization errors to avoid blocking\n    });\n    return addMCPToolsToGrokTools(GROK_TOOLS);\n}\n//# sourceMappingURL=tools.js.map"
  },
  "dist/db/migrations/002-add-session-search-fields.js": {
    "path": "dist/db/migrations/002-add-session-search-fields.js",
    "hash": "5cc94873aa15f57ce194869a5baa17e95d6abb16e88418c094b7379d6af6c6d2",
    "size": 3812,
    "timestamp": 1764704879306,
    "content": "/**\n * Migration 002: Add Native Search Fields to Sessions\n *\n * Adds fields that are automatically populated by the application\n * for enhanced search and filtering capabilities.\n *\n * NO USER-DEFINED FIELDS - Only native, application-managed fields.\n */\nexport function up(db) {\n    console.log('üîÑ Running migration 002: Adding native search fields...');\n    // Add session_name (replaces/supplements title)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN session_name TEXT;\n  `);\n    // Add created_at if not exists (some versions might not have it)\n    // Check if column already exists\n    const columns = db.prepare(`PRAGMA table_info(sessions)`).all();\n    const hasCreatedAt = columns.some(col => col.name === 'created_at');\n    if (!hasCreatedAt) {\n        db.exec(`\n      ALTER TABLE sessions ADD COLUMN created_at DATETIME;\n    `);\n        // Backfill created_at from started_at\n        db.exec(`\n      UPDATE sessions SET created_at = started_at WHERE created_at IS NULL;\n    `);\n    }\n    // Add message_count (denormalized for performance)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN message_count INTEGER DEFAULT 0;\n  `);\n    // Add total_tokens (usage tracking)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN total_tokens INTEGER DEFAULT 0;\n  `);\n    // Add first_message_preview (for quick display)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN first_message_preview TEXT;\n  `);\n    // Add last_message_preview (for quick display)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN last_message_preview TEXT;\n  `);\n    // Add project_context (auto-detected: git branch, package.json, etc.)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN project_context TEXT;\n  `);\n    // Add is_favorite (user can star important sessions)\n    db.exec(`\n    ALTER TABLE sessions ADD COLUMN is_favorite INTEGER DEFAULT 0;\n  `);\n    // Create indexes for search performance\n    db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_sessions_name ON sessions(session_name);\n    CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions(created_at);\n    CREATE INDEX IF NOT EXISTS idx_sessions_favorite ON sessions(is_favorite);\n    CREATE INDEX IF NOT EXISTS idx_sessions_message_count ON sessions(message_count);\n  `);\n    // Backfill message_count for existing sessions\n    db.exec(`\n    UPDATE sessions \n    SET message_count = (\n      SELECT COUNT(*) FROM messages WHERE session_id = sessions.id\n    )\n    WHERE message_count = 0;\n  `);\n    // Backfill first/last message previews for existing sessions\n    db.exec(`\n    UPDATE sessions \n    SET first_message_preview = (\n      SELECT substr(content, 1, 100) \n      FROM messages \n      WHERE session_id = sessions.id AND role = 'user'\n      ORDER BY id ASC\n      LIMIT 1\n    ),\n    last_message_preview = (\n      SELECT substr(content, 1, 100) \n      FROM messages \n      WHERE session_id = sessions.id\n      ORDER BY id DESC\n      LIMIT 1\n    )\n    WHERE first_message_preview IS NULL;\n  `);\n    console.log('‚úÖ Migration 002 completed successfully');\n    console.log('   Added 8 native search fields');\n    console.log('   Created 4 performance indexes');\n    console.log('   Backfilled data for existing sessions');\n}\nexport function down(db) {\n    console.log('üîÑ Rolling back migration 002...');\n    // Note: SQLite doesn't support DROP COLUMN easily\n    // We'd need to recreate the table, which is risky\n    // For now, just drop the indexes\n    db.exec(`\n    DROP INDEX IF EXISTS idx_sessions_name;\n    DROP INDEX IF EXISTS idx_sessions_created_at;\n    DROP INDEX IF EXISTS idx_sessions_favorite;\n    DROP INDEX IF EXISTS idx_sessions_message_count;\n  `);\n    console.log('‚ö†Ô∏è  Note: Columns not removed (SQLite limitation)');\n    console.log('   They will remain but be unused');\n}\n//# sourceMappingURL=002-add-session-search-fields.js.map"
  },
  "dist/db/migrations/migrate-jsonl.js": {
    "path": "dist/db/migrations/migrate-jsonl.js",
    "hash": "7c74ce589a6f315c9e523407cb92591104179de0266101488c6d4c1c3518c97d",
    "size": 6208,
    "timestamp": 1764704879306,
    "content": "#!/usr/bin/env node\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { db } from '../database.js';\nimport { SessionRepository } from '../repositories/session-repository.js';\nimport { MessageRepository } from '../repositories/message-repository.js';\n/**\n * Migrate JSONL chat history to SQLite\n */\nexport async function migrateJsonlToSqlite() {\n    console.log('üîÑ Starting JSONL ‚Üí SQLite migration...\\n');\n    const sessionRepo = new SessionRepository(db.getDb());\n    const messageRepo = new MessageRepository(db.getDb());\n    // Find all session.jsonl files in .grok directories\n    const jsonlFiles = findJsonlFiles(process.cwd());\n    if (jsonlFiles.length === 0) {\n        console.log('‚ùå No session.jsonl files found to migrate');\n        return;\n    }\n    console.log(`Found ${jsonlFiles.length} JSONL file(s) to migrate:\\n`);\n    for (const filePath of jsonlFiles) {\n        console.log(`üìÑ Processing: ${filePath}`);\n        try {\n            const workdir = path.dirname(path.dirname(filePath)); // Parent of .grok\n            const content = fs.readFileSync(filePath, 'utf-8');\n            const lines = content.split('\\n').filter(Boolean);\n            if (lines.length === 0) {\n                console.log('   ‚ö†Ô∏è  Empty file, skipping...\\n');\n                continue;\n            }\n            // Parse entries and detect sessions based on gaps\n            const sessions = splitIntoSessions(lines);\n            console.log(`   Found ${sessions.length} session(s) based on time gaps`);\n            for (let i = 0; i < sessions.length; i++) {\n                const entries = sessions[i];\n                // Create session in database\n                const session = sessionRepo.findOrCreate(workdir, 'grok', // Default provider for legacy\n                'unknown');\n                console.log(`   Session ${i + 1}: Created with ID ${session.id}`);\n                // Insert all messages\n                for (const entry of entries) {\n                    try {\n                        messageRepo.save({\n                            session_id: session.id,\n                            type: entry.type,\n                            role: entry.type === 'user' ? 'user' : 'assistant',\n                            content: entry.content,\n                            provider: 'grok',\n                            model: 'unknown',\n                            timestamp: entry.timestamp,\n                            tool_calls: entry.toolCalls,\n                            tool_call_id: entry.toolCall?.id,\n                        });\n                    }\n                    catch (err) {\n                        console.error(`   ‚ö†Ô∏è  Failed to insert message:`, err);\n                    }\n                }\n                console.log(`   ‚úÖ Migrated ${entries.length} messages`);\n                // Close this session as completed\n                sessionRepo.closeSession(session.id);\n            }\n            // Backup original file\n            const backupPath = filePath + '.backup';\n            fs.copyFileSync(filePath, backupPath);\n            console.log(`   üì¶ Backed up to: ${backupPath}`);\n            // Remove original (optional - commented for safety)\n            // fs.unlinkSync(filePath);\n            console.log(`   ‚úÖ Migration complete!\\n`);\n        }\n        catch (error) {\n            console.error(`   ‚ùå Error migrating ${filePath}:`, error.message);\n            console.log('');\n        }\n    }\n    console.log('üéâ Migration finished!');\n    console.log('\\nNext steps:');\n    console.log('1. Verify your data: sqlite3 ~/.grok/conversations.db \"SELECT * FROM sessions;\"');\n    console.log('2. Test your CLI: npm start');\n    console.log('3. If everything works, you can delete .backup files');\n}\n/**\n * Find all session.jsonl files in .grok directories\n */\nfunction findJsonlFiles(rootDir) {\n    const files = [];\n    function search(dir) {\n        try {\n            const items = fs.readdirSync(dir);\n            for (const item of items) {\n                const fullPath = path.join(dir, item);\n                const stat = fs.statSync(fullPath);\n                if (stat.isDirectory()) {\n                    // Look for .grok directories\n                    if (item === '.grok') {\n                        const sessionFile = path.join(fullPath, 'session.jsonl');\n                        if (fs.existsSync(sessionFile)) {\n                            files.push(sessionFile);\n                        }\n                    }\n                    else if (!item.startsWith('.') && !item.includes('node_modules')) {\n                        // Recurse into non-hidden directories\n                        search(fullPath);\n                    }\n                }\n            }\n        }\n        catch (err) {\n            // Ignore permission errors\n        }\n    }\n    search(rootDir);\n    return files;\n}\n/**\n * Split JSONL entries into sessions based on time gaps\n */\nfunction splitIntoSessions(lines) {\n    const sessions = [];\n    let currentSession = [];\n    let lastTimestamp = 0;\n    const ONE_HOUR = 60 * 60 * 1000;\n    for (const line of lines) {\n        try {\n            const entry = JSON.parse(line);\n            const timestamp = new Date(entry.timestamp).getTime();\n            // If gap > 1 hour or \"exit\" detected, start new session\n            if (currentSession.length > 0 &&\n                (timestamp - lastTimestamp > ONE_HOUR ||\n                    entry.content?.toLowerCase().includes('exit'))) {\n                sessions.push(currentSession);\n                currentSession = [];\n            }\n            currentSession.push(entry);\n            lastTimestamp = timestamp;\n        }\n        catch (err) {\n            console.error('   ‚ö†Ô∏è  Failed to parse line:', line.substring(0, 50));\n        }\n    }\n    // Push last session\n    if (currentSession.length > 0) {\n        sessions.push(currentSession);\n    }\n    return sessions;\n}\n// Run migration if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n    migrateJsonlToSqlite()\n        .then(() => process.exit(0))\n        .catch((err) => {\n        console.error('Migration failed:', err);\n        process.exit(1);\n    });\n}\n//# sourceMappingURL=migrate-jsonl.js.map"
  },
  "dist/db/migrations/index.js": {
    "path": "dist/db/migrations/index.js",
    "hash": "66074c4452da733145a94a422772324608050e33456603517e880b8758ce4ef2",
    "size": 3397,
    "timestamp": 1764704879306,
    "content": "import * as migration002 from './002-add-session-search-fields.js';\nconst migrations = [\n    {\n        version: 2,\n        name: 'add-session-search-fields',\n        up: migration002.up,\n        down: migration002.down,\n    },\n    // Future migrations go here\n];\nexport class MigrationManager {\n    db;\n    constructor(db) {\n        this.db = db;\n        this.ensureMigrationsTable();\n    }\n    /**\n     * Create migrations tracking table\n     */\n    ensureMigrationsTable() {\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS schema_migrations (\n        version INTEGER PRIMARY KEY,\n        name TEXT NOT NULL,\n        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n    }\n    /**\n     * Get current schema version\n     */\n    getCurrentVersion() {\n        const result = this.db.prepare(`\n      SELECT MAX(version) as version FROM schema_migrations\n    `).get();\n        return result.version || 0;\n    }\n    /**\n     * Run pending migrations\n     */\n    runPendingMigrations() {\n        const currentVersion = this.getCurrentVersion();\n        const pendingMigrations = migrations.filter(m => m.version > currentVersion);\n        if (pendingMigrations.length === 0) {\n            console.log('‚úÖ Database schema is up to date (version ' + currentVersion + ')');\n            return;\n        }\n        console.log(`üîÑ Running ${pendingMigrations.length} pending migration(s)...`);\n        for (const migration of pendingMigrations) {\n            try {\n                console.log(`\\nüì¶ Migration ${migration.version}: ${migration.name}`);\n                // Run migration in transaction\n                this.db.transaction(() => {\n                    migration.up(this.db);\n                    // Record migration\n                    this.db.prepare(`\n            INSERT INTO schema_migrations (version, name) VALUES (?, ?)\n          `).run(migration.version, migration.name);\n                })();\n                console.log(`‚úÖ Migration ${migration.version} completed`);\n            }\n            catch (error) {\n                console.error(`‚ùå Migration ${migration.version} failed:`, error);\n                throw error;\n            }\n        }\n        console.log(`\\n‚úÖ All migrations completed. Schema version: ${this.getCurrentVersion()}\\n`);\n    }\n    /**\n     * Rollback last migration (use with caution)\n     */\n    rollbackLastMigration() {\n        const currentVersion = this.getCurrentVersion();\n        if (currentVersion === 0) {\n            console.log('‚ÑπÔ∏è  No migrations to rollback');\n            return;\n        }\n        const migration = migrations.find(m => m.version === currentVersion);\n        if (!migration) {\n            console.error(`‚ùå Migration ${currentVersion} not found in code`);\n            return;\n        }\n        console.log(`üîÑ Rolling back migration ${migration.version}: ${migration.name}`);\n        try {\n            this.db.transaction(() => {\n                migration.down(this.db);\n                // Remove migration record\n                this.db.prepare(`\n          DELETE FROM schema_migrations WHERE version = ?\n        `).run(currentVersion);\n            })();\n            console.log(`‚úÖ Rollback completed. Schema version: ${this.getCurrentVersion()}`);\n        }\n        catch (error) {\n            console.error(`‚ùå Rollback failed:`, error);\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"
  },
  "dist/db/types.js": {
    "path": "dist/db/types.js",
    "hash": "6264a70a8f450de631c4f87017cc097c4fdb2b7bbeaa3b285f284e39b3b07f08",
    "size": 62,
    "timestamp": 1764704879306,
    "content": "// Database types\nexport {};\n//# sourceMappingURL=types.js.map"
  },
  "dist/db/repositories/session-repository.js": {
    "path": "dist/db/repositories/session-repository.js",
    "hash": "9330aa82eada66546e83d114d8f3f82c0bfb2cabf2670a2f1ab2082544d583c6",
    "size": 13342,
    "timestamp": 1764704879306,
    "content": "import crypto from 'crypto';\nexport class SessionRepository {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    /**\n     * Generate hash from working directory and provider\n     */\n    generateSessionHash(workdir, provider) {\n        return crypto\n            .createHash('sha256')\n            .update(`${workdir}:${provider}`)\n            .digest('hex')\n            .substring(0, 16);\n    }\n    /**\n     * Find active session by workdir and provider\n     */\n    findActiveSession(workdir, provider) {\n        const stmt = this.db.prepare(`\n      SELECT * FROM sessions \n      WHERE working_dir = ? \n      AND default_provider = ?\n      AND status = 'active'\n      ORDER BY last_activity DESC\n      LIMIT 1\n    `);\n        return stmt.get(workdir, provider);\n    }\n    /**\n     * Find last session by workdir (regardless of provider)\n     * Used for session restoration on startup\n     * Prioritizes sessions with messages (completed sessions with history)\n     */\n    findLastSessionByWorkdir(workdir) {\n        const stmt = this.db.prepare(`\n      SELECT s.*, \n             (SELECT COUNT(*) FROM messages WHERE session_id = s.id) as message_count\n      FROM sessions s\n      WHERE s.working_dir = ? \n      ORDER BY message_count DESC, last_activity DESC\n      LIMIT 1\n    `);\n        return stmt.get(workdir);\n    }\n    /**\n     * Check if session should be reused (activity within last hour)\n     */\n    shouldReuseSession(session) {\n        const lastActivity = new Date(session.last_activity).getTime();\n        const now = Date.now();\n        const oneHour = 60 * 60 * 1000;\n        return now - lastActivity < oneHour;\n    }\n    /**\n     * Find or create session for current workdir and provider\n     */\n    /**\n     * Create a new session (always creates, never reuses)\n     * Use this when you explicitly want a new session in the same directory\n     */\n    create(workdir, provider, model, apiKeyHash) {\n        const sessionHash = this.generateSessionHash(workdir, provider);\n        const stmt = this.db.prepare(`\n      INSERT INTO sessions (\n        working_dir, \n        default_provider, \n        default_model, \n        api_key_hash, \n        session_hash,\n        status,\n        created_at,\n        last_activity\n      )\n      VALUES (?, ?, ?, ?, ?, 'active', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n        const result = stmt.run(workdir, provider, model, apiKeyHash || null, sessionHash);\n        const sessionId = result.lastInsertRowid;\n        const newSession = this.findById(sessionId);\n        if (!newSession) {\n            throw new Error(`Failed to create session`);\n        }\n        return newSession;\n    }\n    findOrCreate(workdir, provider, model, apiKeyHash) {\n        const existingSession = this.findActiveSession(workdir, provider);\n        // Reuse if exists and recent activity\n        if (existingSession && this.shouldReuseSession(existingSession)) {\n            return existingSession;\n        }\n        // Close old session if exists\n        if (existingSession) {\n            this.closeSession(existingSession.id);\n        }\n        // Look for ANY session with this hash (even completed ones)\n        const sessionHash = this.generateSessionHash(workdir, provider);\n        const anySession = this.db.prepare(`\n      SELECT * FROM sessions WHERE session_hash = ?\n    `).get(sessionHash);\n        // If session exists (completed), reactivate it\n        if (anySession) {\n            this.db.prepare(`\n        UPDATE sessions \n        SET status = 'active', \n            last_activity = CURRENT_TIMESTAMP,\n            default_model = ?,\n            api_key_hash = ?\n        WHERE id = ?\n      `).run(model, apiKeyHash || null, anySession.id);\n            return this.findById(anySession.id);\n        }\n        // Create new session (only if hash doesn't exist at all)\n        const stmt = this.db.prepare(`\n      INSERT INTO sessions (\n        working_dir, \n        session_hash, \n        default_provider, \n        default_model,\n        api_key_hash\n      ) VALUES (?, ?, ?, ?, ?)\n    `);\n        const result = stmt.run(workdir, sessionHash, provider, model, apiKeyHash || null);\n        return this.findById(result.lastInsertRowid);\n    }\n    /**\n     * Find session by ID\n     */\n    findById(id) {\n        const stmt = this.db.prepare('SELECT * FROM sessions WHERE id = ?');\n        return stmt.get(id);\n    }\n    /**\n     * Update last activity timestamp\n     */\n    updateLastActivity(sessionId) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions\n      SET last_activity = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `);\n        stmt.run(sessionId);\n    }\n    /**\n     * Update session status\n     */\n    updateStatus(sessionId, status) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions\n      SET status = ?, last_activity = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `);\n        stmt.run(status, sessionId);\n    }\n    /**\n     * Close session (set status to completed)\n     */\n    closeSession(sessionId) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions \n      SET status = 'completed', ended_at = CURRENT_TIMESTAMP \n      WHERE id = ?\n    `);\n        stmt.run(sessionId);\n    }\n    /**\n     * Update session title\n     */\n    updateTitle(sessionId, title) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions SET title = ? WHERE id = ?\n    `);\n        stmt.run(title, sessionId);\n    }\n    /**\n     * Update session provider, model, and reactivate\n     * Used when restoring session with potentially different provider/model\n     */\n    updateSessionProviderAndModel(sessionId, provider, model, apiKeyHash) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions \n      SET status = 'active',\n          default_provider = ?,\n          default_model = ?,\n          api_key_hash = ?,\n          last_activity = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `);\n        stmt.run(provider, model, apiKeyHash || null, sessionId);\n    }\n    /**\n     * Update session name (auto-generated from first message)\n     */\n    updateSessionName(sessionId, sessionName) {\n        const stmt = this.db.prepare(`\n      UPDATE sessions SET session_name = ? WHERE id = ?\n    `);\n        stmt.run(sessionName, sessionId);\n    }\n    /**\n     * Update session statistics in real-time (message_count, total_tokens, previews)\n     * Called after each message to keep denormalized stats fresh\n     * Performance: < 5ms on average, executed in a single transaction\n     *\n     * @param sessionId - Session to update\n     */\n    updateSessionStats(sessionId) {\n        // Update in a single transaction for atomicity\n        const transaction = this.db.transaction(() => {\n            // 1. Update message_count\n            this.db.prepare(`\n        UPDATE sessions \n        SET message_count = (\n          SELECT COUNT(*) FROM messages WHERE session_id = ?\n        )\n        WHERE id = ?\n      `).run(sessionId, sessionId);\n            // 2. Update total_tokens (sum of all token_count in messages)\n            this.db.prepare(`\n        UPDATE sessions \n        SET total_tokens = (\n          SELECT COALESCE(SUM(token_count), 0) FROM messages WHERE session_id = ?\n        )\n        WHERE id = ?\n      `).run(sessionId, sessionId);\n            // 3. Update first_message_preview (first user message)\n            const firstMessage = this.db.prepare(`\n        SELECT content FROM messages \n        WHERE session_id = ? AND role = 'user' AND content != ''\n        ORDER BY id ASC \n        LIMIT 1\n      `).get(sessionId);\n            if (firstMessage) {\n                const preview = firstMessage.content.substring(0, 100).replace(/[\\r\\n]+/g, ' ');\n                this.db.prepare(`\n          UPDATE sessions SET first_message_preview = ? WHERE id = ?\n        `).run(preview, sessionId);\n            }\n            // 4. Update last_message_preview (last user or assistant message)\n            const lastMessage = this.db.prepare(`\n        SELECT content FROM messages \n        WHERE session_id = ? AND (role = 'user' OR role = 'assistant') AND content != ''\n        ORDER BY id DESC \n        LIMIT 1\n      `).get(sessionId);\n            if (lastMessage) {\n                const preview = lastMessage.content.substring(0, 100).replace(/[\\r\\n]+/g, ' ');\n                this.db.prepare(`\n          UPDATE sessions SET last_message_preview = ? WHERE id = ?\n        `).run(preview, sessionId);\n            }\n        });\n        transaction();\n    }\n    /**\n     * Get all sessions with filters\n     */\n    findAll(filters) {\n        let query = 'SELECT * FROM sessions WHERE 1=1';\n        const params = [];\n        if (filters?.status && filters.status.length > 0) {\n            const placeholders = filters.status.map(() => '?').join(',');\n            query += ` AND status IN (${placeholders})`;\n            params.push(...filters.status);\n        }\n        if (filters?.workdir) {\n            query += ' AND working_dir = ?';\n            params.push(filters.workdir);\n        }\n        query += ' ORDER BY last_activity DESC';\n        if (filters?.limit) {\n            query += ' LIMIT ?';\n            params.push(filters.limit);\n        }\n        const stmt = this.db.prepare(query);\n        return stmt.all(...params);\n    }\n    /**\n     * List sessions with enriched metadata for display/search\n     *\n     * @param workdir - Filter by working directory (null = all directories, undefined = current, string = specific)\n     * @param options - Additional filtering options\n     * @returns Array of enriched session list items\n     */\n    listSessions(workdir, options) {\n        let query = `\n      SELECT \n        s.id,\n        s.session_name,\n        s.working_dir,\n        s.default_provider,\n        s.default_model,\n        s.message_count,\n        s.total_tokens,\n        s.status,\n        s.created_at,\n        s.last_activity,\n        s.first_message_preview,\n        s.last_message_preview,\n        s.is_favorite,\n        s.project_context,\n        CAST((julianday('now') - julianday(s.created_at)) AS INTEGER) as age_days\n      FROM sessions s\n      WHERE 1=1\n    `;\n        const params = [];\n        // Filter by working directory (only if explicitly provided as a string)\n        // If workdir is null, list ALL sessions from all directories\n        // If workdir is undefined or empty string, don't filter (list all)\n        if (workdir !== null && workdir !== undefined && workdir !== '') {\n            query += ' AND s.working_dir = ?';\n            params.push(workdir);\n        }\n        // Filter by status\n        if (options?.status && options.status.length > 0) {\n            const placeholders = options.status.map(() => '?').join(',');\n            query += ` AND s.status IN (${placeholders})`;\n            params.push(...options.status);\n        }\n        // Filter favorites only\n        if (options?.favoriteOnly) {\n            query += ' AND s.is_favorite = 1';\n        }\n        // Filter by minimum message count\n        if (options?.minMessages !== undefined && options.minMessages > 0) {\n            query += ' AND s.message_count >= ?';\n            params.push(options.minMessages);\n        }\n        // Sort by\n        const sortBy = options?.sortBy || 'last_activity';\n        const sortOrder = options?.sortOrder || 'DESC';\n        query += ` ORDER BY s.${sortBy} ${sortOrder}`;\n        // Limit results\n        if (options?.limit) {\n            query += ' LIMIT ?';\n            params.push(options.limit);\n        }\n        const stmt = this.db.prepare(query);\n        const results = stmt.all(...params);\n        // Convert to SessionListItem with computed fields\n        return results.map(row => ({\n            id: row.id,\n            session_name: row.session_name,\n            working_dir: row.working_dir,\n            default_provider: row.default_provider,\n            default_model: row.default_model,\n            message_count: row.message_count || 0,\n            total_tokens: row.total_tokens || 0,\n            status: row.status,\n            created_at: row.created_at,\n            last_activity: row.last_activity,\n            first_message_preview: row.first_message_preview,\n            last_message_preview: row.last_message_preview,\n            is_favorite: Boolean(row.is_favorite),\n            project_context: row.project_context,\n            age_days: row.age_days || 0,\n            last_activity_relative: this.formatRelativeTime(row.last_activity),\n        }));\n    }\n    /**\n     * Format timestamp as relative time (e.g., \"2 hours ago\")\n     */\n    formatRelativeTime(timestamp) {\n        const now = Date.now();\n        const then = new Date(timestamp).getTime();\n        const diffMs = now - then;\n        const seconds = Math.floor(diffMs / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const hours = Math.floor(minutes / 60);\n        const days = Math.floor(hours / 24);\n        if (seconds < 60)\n            return 'just now';\n        if (minutes < 60)\n            return `${minutes}m ago`;\n        if (hours < 24)\n            return `${hours}h ago`;\n        if (days < 7)\n            return `${days}d ago`;\n        if (days < 30)\n            return `${Math.floor(days / 7)}w ago`;\n        if (days < 365)\n            return `${Math.floor(days / 30)}mo ago`;\n        return `${Math.floor(days / 365)}y ago`;\n    }\n}\n//# sourceMappingURL=session-repository.js.map"
  },
  "dist/db/repositories/message-repository.js": {
    "path": "dist/db/repositories/message-repository.js",
    "hash": "06b7db2aadaa4c063232a978995ffd2578e1afcada12a75b9329cbeb87351a35",
    "size": 3169,
    "timestamp": 1764704879306,
    "content": "export class MessageRepository {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    /**\n     * Save a new message\n     */\n    save(input) {\n        const stmt = this.db.prepare(`\n      INSERT INTO messages (\n        session_id, \n        type, \n        role, \n        content, \n        content_type,\n        provider, \n        model, \n        api_key_hash,\n        timestamp,\n        token_count, \n        tool_calls, \n        tool_call_id,\n        is_streaming,\n        parent_message_id\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n        const result = stmt.run(input.session_id, input.type, input.role, input.content, input.content_type || 'text', input.provider, input.model, input.api_key_hash || null, input.timestamp || new Date().toISOString(), input.token_count || 0, input.tool_calls ? JSON.stringify(input.tool_calls) : null, input.tool_call_id || null, input.is_streaming ? 1 : 0, input.parent_message_id || null);\n        return this.findById(result.lastInsertRowid);\n    }\n    /**\n     * Find message by ID\n     */\n    findById(id) {\n        const stmt = this.db.prepare('SELECT * FROM messages WHERE id = ?');\n        return stmt.get(id);\n    }\n    /**\n     * Get all messages for a session\n     */\n    getBySession(sessionId) {\n        const stmt = this.db.prepare(`\n      SELECT * FROM messages \n      WHERE session_id = ? \n      ORDER BY timestamp ASC\n    `);\n        return stmt.all(sessionId);\n    }\n    /**\n     * Get recent messages for a session\n     */\n    getRecentMessages(sessionId, limit) {\n        const stmt = this.db.prepare(`\n      SELECT * FROM messages \n      WHERE session_id = ? \n      ORDER BY timestamp DESC \n      LIMIT ?\n    `);\n        const messages = stmt.all(sessionId, limit);\n        return messages.reverse(); // Return in chronological order\n    }\n    /**\n     * Count messages in a session\n     */\n    countBySession(sessionId) {\n        const stmt = this.db.prepare(`\n      SELECT COUNT(*) as count FROM messages WHERE session_id = ?\n    `);\n        const result = stmt.get(sessionId);\n        return result.count;\n    }\n    /**\n     * Get last message timestamp for a session\n     */\n    getLastTimestamp(sessionId) {\n        const stmt = this.db.prepare(`\n      SELECT timestamp FROM messages \n      WHERE session_id = ? \n      ORDER BY timestamp DESC \n      LIMIT 1\n    `);\n        const result = stmt.get(sessionId);\n        return result ? new Date(result.timestamp).getTime() : null;\n    }\n    /**\n     * Delete all messages in a session\n     */\n    deleteBySession(sessionId) {\n        const stmt = this.db.prepare('DELETE FROM messages WHERE session_id = ?');\n        stmt.run(sessionId);\n    }\n    /**\n     * Get messages by provider (for analytics)\n     */\n    getByProvider(provider, limit) {\n        let query = 'SELECT * FROM messages WHERE provider = ? ORDER BY timestamp DESC';\n        if (limit) {\n            query += ' LIMIT ?';\n            const stmt = this.db.prepare(query);\n            return stmt.all(provider, limit);\n        }\n        const stmt = this.db.prepare(query);\n        return stmt.all(provider);\n    }\n}\n//# sourceMappingURL=message-repository.js.map"
  },
  "dist/db/database.js": {
    "path": "dist/db/database.js",
    "hash": "6d46e35a689f99d21124f9739d40428a3f65e625ad64649c7f67a9abb3e8e4da",
    "size": 3890,
    "timestamp": 1764704879306,
    "content": "import Database from 'better-sqlite3';\nimport path from 'path';\nimport os from 'os';\nimport fs from 'fs';\nimport { MigrationManager } from './migrations/index.js';\nconst GROK_DIR = path.join(os.homedir(), '.grok');\nconst DB_PATH = path.join(GROK_DIR, 'conversations.db');\nexport class GrokDatabase {\n    db;\n    static instance;\n    constructor() {\n        // Ensure .grok directory exists\n        if (!fs.existsSync(GROK_DIR)) {\n            fs.mkdirSync(GROK_DIR, { recursive: true });\n        }\n        this.db = new Database(DB_PATH);\n        // Enable WAL mode for better concurrency\n        this.db.pragma('journal_mode = WAL');\n        this.db.pragma('foreign_keys = ON');\n        this.initialize();\n        this.runMigrations();\n    }\n    static getInstance() {\n        if (!GrokDatabase.instance) {\n            GrokDatabase.instance = new GrokDatabase();\n        }\n        return GrokDatabase.instance;\n    }\n    /**\n     * Run pending database migrations\n     */\n    runMigrations() {\n        const migrationManager = new MigrationManager(this.db);\n        migrationManager.runPendingMigrations();\n    }\n    initialize() {\n        // Create sessions table\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS sessions (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        \n        -- Identification\n        working_dir TEXT NOT NULL,\n        session_hash TEXT UNIQUE NOT NULL,\n        \n        -- Provider/Model (default for session)\n        default_provider TEXT NOT NULL DEFAULT 'grok',\n        default_model TEXT NOT NULL,\n        api_key_hash TEXT,\n        \n        -- Timestamps\n        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        ended_at DATETIME,\n        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,\n        \n        -- Status\n        status TEXT DEFAULT 'active' CHECK(status IN ('active', 'completed', 'archived')),\n        \n        -- Metadata\n        title TEXT,\n        tags TEXT,\n        metadata TEXT,\n        user_id TEXT\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_working_dir ON sessions(working_dir);\n      CREATE INDEX IF NOT EXISTS idx_session_hash ON sessions(session_hash);\n      CREATE INDEX IF NOT EXISTS idx_last_activity ON sessions(last_activity);\n      CREATE INDEX IF NOT EXISTS idx_status ON sessions(status);\n    `);\n        // Create messages table\n        this.db.exec(`\n      CREATE TABLE IF NOT EXISTS messages (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        session_id INTEGER NOT NULL,\n        \n        -- Type and Role\n        type TEXT NOT NULL,\n        role TEXT NOT NULL,\n        \n        -- Content\n        content TEXT NOT NULL,\n        content_type TEXT DEFAULT 'text',\n        \n        -- Provider info (per message for API switching)\n        provider TEXT NOT NULL,\n        model TEXT NOT NULL,\n        api_key_hash TEXT,\n        \n        -- Timestamps\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n        \n        -- Metrics\n        token_count INTEGER DEFAULT 0,\n        \n        -- Tool calls (JSON stringified)\n        tool_calls TEXT,\n        tool_call_id TEXT,\n        \n        -- Streaming\n        is_streaming BOOLEAN DEFAULT 0,\n        \n        -- Relations\n        parent_message_id INTEGER,\n        \n        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE,\n        FOREIGN KEY (parent_message_id) REFERENCES messages(id) ON DELETE SET NULL\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_session_timestamp ON messages(session_id, timestamp);\n      CREATE INDEX IF NOT EXISTS idx_provider ON messages(provider);\n      CREATE INDEX IF NOT EXISTS idx_type ON messages(type);\n    `);\n        console.log('‚úÖ SQLite database initialized:', DB_PATH);\n    }\n    getDb() {\n        return this.db;\n    }\n    close() {\n        this.db.close();\n    }\n}\n// Export singleton instance\nexport const db = GrokDatabase.getInstance();\n//# sourceMappingURL=database.js.map"
  },
  "dist/execution/execution-manager.js": {
    "path": "dist/execution/execution-manager.js",
    "hash": "dd327e6f4ae07511276614d0e165b1417db585e50c4016bec9bce176b668f897",
    "size": 8270,
    "timestamp": 1764704879306,
    "content": "/**\n * Execution Manager\n *\n * Manages LLM tool executions with real-time event streaming for the Execution Viewer.\n * Provides COT (Chain of Thought) tracking and command output streaming.\n */\nimport { EventEmitter } from 'events';\nimport { nanoid } from 'nanoid';\n// ============================================================================\n// EXECUTION STREAM\n// ============================================================================\n/**\n * Stream for a single execution\n * Emits events for COT entries, command updates, and completion\n */\nexport class ExecutionStream extends EventEmitter {\n    id;\n    toolName;\n    startTime;\n    currentCommand = null;\n    state;\n    constructor(toolName, id) {\n        super();\n        this.id = id || nanoid(10);\n        this.toolName = toolName;\n        this.startTime = new Date();\n        this.state = {\n            id: this.id,\n            toolName,\n            startTime: this.startTime,\n            status: 'running',\n            cot: [],\n            commands: []\n        };\n    }\n    /**\n     * Get current state snapshot\n     */\n    getState() {\n        return { ...this.state };\n    }\n    /**\n     * Emit a Chain of Thought entry\n     */\n    emitCOT(type, content, duration) {\n        const entry = {\n            timestamp: new Date(),\n            type,\n            content,\n            duration\n        };\n        this.state.cot.push(entry);\n        this.emit('cot', entry);\n        this.emit('update', this.state);\n    }\n    /**\n     * Start a new command execution\n     */\n    startCommand(command) {\n        const cmd = {\n            command,\n            status: 'running',\n            output: [],\n            timestamp: new Date(),\n            startTime: Date.now(),\n            duration: 0\n        };\n        this.currentCommand = cmd;\n        this.state.commands.push(cmd);\n        this.emit('command:start', cmd);\n        this.emit('update', this.state);\n    }\n    /**\n     * Add output line to current command\n     */\n    commandOutput(line) {\n        if (!this.currentCommand) {\n            console.warn('commandOutput called without active command');\n            return;\n        }\n        this.currentCommand.output.push(line);\n        this.emit('command:output', { command: this.currentCommand, line });\n        this.emit('update', this.state);\n    }\n    /**\n     * End current command execution\n     */\n    endCommand(exitCode, error) {\n        if (!this.currentCommand) {\n            console.warn('endCommand called without active command');\n            return;\n        }\n        this.currentCommand.exitCode = exitCode;\n        this.currentCommand.status = exitCode === 0 ? 'success' : 'error';\n        this.currentCommand.error = error;\n        this.currentCommand.duration = Date.now() - this.currentCommand.startTime;\n        this.emit('command:end', this.currentCommand);\n        this.emit('update', this.state);\n        this.currentCommand = null;\n    }\n    /**\n     * Complete the execution successfully\n     */\n    complete(metadata) {\n        this.state.status = 'success';\n        this.state.endTime = new Date();\n        this.state.metadata = metadata;\n        this.emit('complete', this.state);\n        this.emit('update', this.state);\n    }\n    /**\n     * Mark execution as failed\n     */\n    fail(error, metadata) {\n        this.state.status = 'error';\n        this.state.endTime = new Date();\n        this.state.metadata = { ...metadata, error };\n        this.emit('error', this.state);\n        this.emit('update', this.state);\n    }\n    /**\n     * Cancel the execution\n     */\n    cancel() {\n        this.state.status = 'cancelled';\n        this.state.endTime = new Date();\n        this.emit('cancel', this.state);\n        this.emit('update', this.state);\n    }\n    /**\n     * Close the stream and remove all listeners\n     */\n    close() {\n        this.removeAllListeners();\n    }\n}\n// ============================================================================\n// EXECUTION MANAGER\n// ============================================================================\n/**\n * Global manager for all executions\n * Provides centralized access to execution streams\n */\nexport class ExecutionManager extends EventEmitter {\n    executions = new Map();\n    activeExecutions = new Set();\n    executionHistory = [];\n    maxHistorySize = 100;\n    /**\n     * Create a new execution stream\n     */\n    createExecution(toolName, id) {\n        const stream = new ExecutionStream(toolName, id);\n        this.executions.set(stream.id, stream);\n        this.activeExecutions.add(stream.id);\n        // Listen to stream events\n        stream.on('update', (state) => {\n            this.emit('execution:update', state);\n        });\n        stream.on('complete', (state) => {\n            this.activeExecutions.delete(stream.id);\n            this.addToHistory(state);\n            this.emit('execution:complete', state);\n            // Auto-cleanup after 5 minutes\n            setTimeout(() => this.closeExecution(stream.id), 5 * 60 * 1000);\n        });\n        stream.on('error', (state) => {\n            this.activeExecutions.delete(stream.id);\n            this.addToHistory(state);\n            this.emit('execution:error', state);\n        });\n        stream.on('cancel', (state) => {\n            this.activeExecutions.delete(stream.id);\n            this.addToHistory(state);\n            this.emit('execution:cancel', state);\n        });\n        this.emit('execution:start', stream.getState());\n        return stream;\n    }\n    /**\n     * Get an execution stream by ID\n     */\n    getExecution(id) {\n        return this.executions.get(id);\n    }\n    /**\n     * Get all active executions\n     */\n    getActiveExecutions() {\n        return Array.from(this.activeExecutions)\n            .map(id => this.executions.get(id)?.getState())\n            .filter((state) => state !== undefined);\n    }\n    /**\n     * Get execution history\n     */\n    getHistory(limit) {\n        const history = [...this.executionHistory].reverse();\n        return limit ? history.slice(0, limit) : history;\n    }\n    /**\n     * Check if there are active executions\n     */\n    hasActiveExecutions() {\n        return this.activeExecutions.size > 0;\n    }\n    /**\n     * Subscribe to all execution updates\n     */\n    subscribeToAll(callback) {\n        this.on('execution:update', callback);\n        return () => this.off('execution:update', callback);\n    }\n    /**\n     * Subscribe to execution lifecycle events\n     */\n    onExecutionStart(callback) {\n        this.on('execution:start', callback);\n        return () => this.off('execution:start', callback);\n    }\n    onExecutionEnd(callback) {\n        const handler = (state) => callback(state);\n        this.on('execution:complete', handler);\n        this.on('execution:error', handler);\n        this.on('execution:cancel', handler);\n        return () => {\n            this.off('execution:complete', handler);\n            this.off('execution:error', handler);\n            this.off('execution:cancel', handler);\n        };\n    }\n    /**\n     * Close an execution and remove it\n     */\n    closeExecution(id) {\n        const stream = this.executions.get(id);\n        if (stream) {\n            stream.close();\n            this.executions.delete(id);\n            this.activeExecutions.delete(id);\n        }\n    }\n    /**\n     * Clear all executions\n     */\n    clearAll() {\n        this.executions.forEach(stream => stream.close());\n        this.executions.clear();\n        this.activeExecutions.clear();\n    }\n    /**\n     * Add execution to history\n     *\n     * NOTE: Timeline.db persistence is handled by ToolHook in grok-agent.ts\n     * to avoid duplication. ExecutionManager focuses on real-time UI updates.\n     */\n    addToHistory(state) {\n        this.executionHistory.push(state);\n        // Trim history if too large\n        if (this.executionHistory.length > this.maxHistorySize) {\n            this.executionHistory = this.executionHistory.slice(-this.maxHistorySize);\n        }\n    }\n}\n// ============================================================================\n// SINGLETON INSTANCE\n// ============================================================================\nexport const executionManager = new ExecutionManager();\n//# sourceMappingURL=execution-manager.js.map"
  },
  "dist/execution/execution-utils.js": {
    "path": "dist/execution/execution-utils.js",
    "hash": "7ad3effd8f2ee79f5640487246bc68fbb420e025aedf3ec3fd60373e0b4ce598",
    "size": 6017,
    "timestamp": 1764704879306,
    "content": "/**\n * Execution Utilities\n *\n * Helper functions for execution management (copy, save, format)\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Format execution output as readable text\n */\nexport function formatExecutionOutput(execution) {\n    const lines = [];\n    lines.push('‚ïê'.repeat(60));\n    lines.push(`  EXECUTION: ${execution.toolName}`);\n    lines.push('‚ïê'.repeat(60));\n    lines.push('');\n    lines.push(`ID:       ${execution.id}`);\n    lines.push(`Status:   ${execution.status.toUpperCase()}`);\n    lines.push(`Started:  ${execution.startTime.toLocaleString()}`);\n    if (execution.endTime) {\n        const duration = execution.endTime.getTime() - execution.startTime.getTime();\n        lines.push(`Ended:    ${execution.endTime.toLocaleString()}`);\n        lines.push(`Duration: ${(duration / 1000).toFixed(2)}s`);\n    }\n    lines.push('');\n    // Chain of Thought\n    if (execution.cot.length > 0) {\n        lines.push('‚îÄ'.repeat(60));\n        lines.push('  CHAIN OF THOUGHT');\n        lines.push('‚îÄ'.repeat(60));\n        execution.cot.forEach((entry, i) => {\n            const icon = {\n                thinking: 'üí≠',\n                action: '‚ö°',\n                observation: 'üëÅÔ∏è',\n                decision: '‚úÖ'\n            }[entry.type];\n            lines.push(`${i + 1}. [${entry.type.toUpperCase()}] ${icon} ${entry.content}`);\n            if (entry.duration) {\n                lines.push(`   Duration: ${entry.duration}ms`);\n            }\n        });\n        lines.push('');\n    }\n    // Commands\n    if (execution.commands.length > 0) {\n        lines.push('‚îÄ'.repeat(60));\n        lines.push('  COMMANDS');\n        lines.push('‚îÄ'.repeat(60));\n        execution.commands.forEach((cmd, i) => {\n            lines.push('');\n            lines.push(`Command ${i + 1}:`);\n            lines.push(`  $ ${cmd.command}`);\n            lines.push(`  Status: ${cmd.status} ${cmd.status === 'success' ? '‚úÖ' : '‚ùå'}`);\n            if (cmd.exitCode !== undefined) {\n                lines.push(`  Exit code: ${cmd.exitCode}`);\n            }\n            if (cmd.output.length > 0) {\n                lines.push(`  Output (${cmd.output.length} lines):`);\n                cmd.output.forEach(line => {\n                    lines.push(`    ${line}`);\n                });\n            }\n            if (cmd.error) {\n                lines.push(`  Error: ${cmd.error}`);\n            }\n            lines.push(`  Duration: ${cmd.duration}ms`);\n        });\n        lines.push('');\n    }\n    // Metadata\n    if (execution.metadata) {\n        lines.push('‚îÄ'.repeat(60));\n        lines.push('  METADATA');\n        lines.push('‚îÄ'.repeat(60));\n        lines.push(JSON.stringify(execution.metadata, null, 2));\n        lines.push('');\n    }\n    lines.push('‚ïê'.repeat(60));\n    return lines.join('\\n');\n}\n/**\n * Copy execution to clipboard (placeholder - requires clipboard library)\n *\n * NOTE: This is a placeholder. Actual clipboard functionality would require\n * a library like 'clipboardy' or platform-specific commands.\n */\nexport function copyExecutionToClipboard(execution) {\n    const output = formatExecutionOutput(execution);\n    // For now, just log a message\n    // In production, use a clipboard library:\n    // import clipboardy from 'clipboardy';\n    // clipboardy.writeSync(output);\n    console.log('\\nüìã Execution output formatted (clipboard functionality pending):\\n');\n    console.log(output);\n    console.log('\\nüí° To enable clipboard: npm install clipboardy\\n');\n}\n/**\n * Save execution to file\n */\nexport async function saveExecutionToFile(execution, customPath) {\n    // Determine save location\n    const executionsDir = customPath || path.join(process.cwd(), '.grokinou', 'executions');\n    // Create directory if it doesn't exist\n    if (!fs.existsSync(executionsDir)) {\n        fs.mkdirSync(executionsDir, { recursive: true });\n    }\n    // Generate filename\n    const timestamp = execution.startTime.toISOString().replace(/:/g, '-').replace(/\\..+/, '');\n    const sanitizedToolName = execution.toolName.replace(/[^a-z0-9]/gi, '_');\n    const filename = `${timestamp}_${sanitizedToolName}_${execution.id}.txt`;\n    const filepath = path.join(executionsDir, filename);\n    // Format and write\n    const content = formatExecutionOutput(execution);\n    fs.writeFileSync(filepath, content, 'utf-8');\n    return filepath;\n}\n/**\n * Save execution as JSON\n */\nexport async function saveExecutionAsJSON(execution, customPath) {\n    const executionsDir = customPath || path.join(process.cwd(), '.grokinou', 'executions');\n    if (!fs.existsSync(executionsDir)) {\n        fs.mkdirSync(executionsDir, { recursive: true });\n    }\n    const timestamp = execution.startTime.toISOString().replace(/:/g, '-').replace(/\\..+/, '');\n    const sanitizedToolName = execution.toolName.replace(/[^a-z0-9]/gi, '_');\n    const filename = `${timestamp}_${sanitizedToolName}_${execution.id}.json`;\n    const filepath = path.join(executionsDir, filename);\n    // Serialize with proper Date handling\n    const serialized = JSON.stringify(execution, (key, value) => {\n        if (value instanceof Date) {\n            return value.toISOString();\n        }\n        return value;\n    }, 2);\n    fs.writeFileSync(filepath, serialized, 'utf-8');\n    return filepath;\n}\n/**\n * Get summary statistics from execution\n */\nexport function getExecutionStats(execution) {\n    const totalDuration = execution.endTime\n        ? execution.endTime.getTime() - execution.startTime.getTime()\n        : 0;\n    const commandCount = execution.commands.length;\n    const successCount = execution.commands.filter(cmd => cmd.status === 'success').length;\n    const successRate = commandCount > 0 ? (successCount / commandCount) * 100 : 0;\n    const cotSteps = execution.cot.length;\n    const outputLines = execution.commands.reduce((sum, cmd) => sum + cmd.output.length, 0);\n    return {\n        totalDuration,\n        commandCount,\n        successRate,\n        cotSteps,\n        outputLines,\n    };\n}\n//# sourceMappingURL=execution-utils.js.map"
  },
  "dist/execution/index.js": {
    "path": "dist/execution/index.js",
    "hash": "db584a127a1510113b2991a21888871b87e335d6ee1a038480b583256e687d2c",
    "size": 353,
    "timestamp": 1764704879306,
    "content": "/**\n * Execution Module\n *\n * Exports for execution tracking and viewing\n */\nexport { ExecutionManager, ExecutionStream, executionManager } from './execution-manager.js';\nexport { formatExecutionOutput, copyExecutionToClipboard, saveExecutionToFile, saveExecutionAsJSON, getExecutionStats } from './execution-utils.js';\n//# sourceMappingURL=index.js.map"
  },
  "dist/commands/search.js": {
    "path": "dist/commands/search.js",
    "hash": "5879eab47789024c237b514b7f93978da9f359138d0f3aecc90fc45d29f879df",
    "size": 2057,
    "timestamp": 1764704879306,
    "content": "import { searchManager } from '../utils/search-manager.js';\n/**\n * Parse /search command from user input\n *\n * Supported formats:\n * - /search pattern\n * - /search \"exact phrase\"\n * - /search pattern --global\n * - /search pattern --session\n */\nexport function parseSearchCommand(input) {\n    // Basic format: /search <query>\n    const basicMatch = input.match(/^\\/search\\s+(.+)$/);\n    if (!basicMatch)\n        return null;\n    let query = basicMatch[1].trim();\n    let scope = 'global'; // Default to global search\n    // Check for flags\n    if (query.includes('--session')) {\n        scope = 'session';\n        query = query.replace(/--session/g, '').trim();\n    }\n    else if (query.includes('--global')) {\n        scope = 'global';\n        query = query.replace(/--global/g, '').trim();\n    }\n    // Remove quotes if present (for exact phrase)\n    query = query.replace(/^[\"']|[\"']$/g, '');\n    if (!query)\n        return null;\n    return {\n        type: 'search',\n        query,\n        scope,\n    };\n}\n/**\n * Execute search command\n */\nexport function executeSearchCommand(command, currentSessionId) {\n    if (command.scope === 'session' && currentSessionId) {\n        // Search in current session only\n        return searchManager.searchCurrentSession(command.query, currentSessionId, 20);\n    }\n    // Global search across all sessions\n    return searchManager.searchGlobal(command.query, 50);\n}\n/**\n * Format search results count for display\n */\nexport function formatSearchSummary(results, query) {\n    const count = results.length;\n    const totalMatches = results.reduce((sum, r) => sum + r.matchCount, 0);\n    if (count === 0) {\n        return `No results found for \"${query}\"`;\n    }\n    if (count === 1) {\n        return `1 result found for \"${query}\" (${totalMatches} matches)`;\n    }\n    return `${count} results found for \"${query}\" (${totalMatches} total matches)`;\n}\n/**\n * Check if input is a search command\n */\nexport function isSearchCommand(input) {\n    return input.trim().startsWith('/search');\n}\n//# sourceMappingURL=search.js.map"
  },
  "dist/commands/mcp.js": {
    "path": "dist/commands/mcp.js",
    "hash": "da48dcf02771d4b91d32a9aac9168edf9bbd458058fc67ac52618d0520e1f0eb",
    "size": 10311,
    "timestamp": 1764704879307,
    "content": "import { Command } from 'commander';\nimport { addMCPServer, removeMCPServer, loadMCPConfig, PREDEFINED_SERVERS } from '../mcp/config.js';\nimport { getMCPManager } from '../grok/tools.js';\nimport chalk from 'chalk';\nexport function createMCPCommand() {\n    const mcpCommand = new Command('mcp');\n    mcpCommand.description('Manage MCP (Model Context Protocol) servers');\n    // Add server command\n    mcpCommand\n        .command('add <name>')\n        .description('Add an MCP server')\n        .option('-t, --transport <type>', 'Transport type (stdio, http, sse, streamable_http)', 'stdio')\n        .option('-c, --command <command>', 'Command to run the server (for stdio transport)')\n        .option('-a, --args [args...]', 'Arguments for the server command (for stdio transport)', [])\n        .option('-u, --url <url>', 'URL for HTTP/SSE transport')\n        .option('-h, --headers [headers...]', 'HTTP headers (key=value format)', [])\n        .option('-e, --env [env...]', 'Environment variables (key=value format)', [])\n        .action(async (name, options) => {\n        try {\n            // Check if it's a predefined server\n            if (PREDEFINED_SERVERS[name]) {\n                const config = PREDEFINED_SERVERS[name];\n                addMCPServer(config);\n                console.log(chalk.green(`‚úì Added predefined MCP server: ${name}`));\n                // Try to connect immediately\n                const manager = getMCPManager();\n                await manager.addServer(config);\n                console.log(chalk.green(`‚úì Connected to MCP server: ${name}`));\n                const tools = manager.getTools().filter(t => t.serverName === name);\n                console.log(chalk.blue(`  Available tools: ${tools.length}`));\n                return;\n            }\n            // Custom server\n            const transportType = options.transport.toLowerCase();\n            if (transportType === 'stdio') {\n                if (!options.command) {\n                    console.error(chalk.red('Error: --command is required for stdio transport'));\n                    process.exit(1);\n                }\n            }\n            else if (transportType === 'http' || transportType === 'sse' || transportType === 'streamable_http') {\n                if (!options.url) {\n                    console.error(chalk.red(`Error: --url is required for ${transportType} transport`));\n                    process.exit(1);\n                }\n            }\n            else {\n                console.error(chalk.red('Error: Transport type must be stdio, http, sse, or streamable_http'));\n                process.exit(1);\n            }\n            // Parse environment variables\n            const env = {};\n            for (const envVar of options.env || []) {\n                const [key, value] = envVar.split('=', 2);\n                if (key && value) {\n                    env[key] = value;\n                }\n            }\n            // Parse headers\n            const headers = {};\n            for (const header of options.headers || []) {\n                const [key, value] = header.split('=', 2);\n                if (key && value) {\n                    headers[key] = value;\n                }\n            }\n            const config = {\n                name,\n                transport: {\n                    type: transportType,\n                    command: options.command,\n                    args: options.args || [],\n                    url: options.url,\n                    env,\n                    headers: Object.keys(headers).length > 0 ? headers : undefined\n                }\n            };\n            addMCPServer(config);\n            console.log(chalk.green(`‚úì Added MCP server: ${name}`));\n            // Try to connect immediately\n            const manager = getMCPManager();\n            await manager.addServer(config);\n            console.log(chalk.green(`‚úì Connected to MCP server: ${name}`));\n            const tools = manager.getTools().filter(t => t.serverName === name);\n            console.log(chalk.blue(`  Available tools: ${tools.length}`));\n        }\n        catch (error) {\n            console.error(chalk.red(`Error adding MCP server: ${error.message}`));\n            process.exit(1);\n        }\n    });\n    // Add server from JSON command\n    mcpCommand\n        .command('add-json <name> <json>')\n        .description('Add an MCP server from JSON configuration')\n        .action(async (name, jsonConfig) => {\n        try {\n            let config;\n            try {\n                config = JSON.parse(jsonConfig);\n            }\n            catch (error) {\n                console.error(chalk.red('Error: Invalid JSON configuration'));\n                process.exit(1);\n            }\n            const serverConfig = {\n                name,\n                transport: {\n                    type: 'stdio', // default\n                    command: config.command,\n                    args: config.args || [],\n                    env: config.env || {},\n                    url: config.url,\n                    headers: config.headers\n                }\n            };\n            // Override transport type if specified\n            if (config.transport) {\n                if (typeof config.transport === 'string') {\n                    serverConfig.transport.type = config.transport;\n                }\n                else if (typeof config.transport === 'object') {\n                    serverConfig.transport = { ...serverConfig.transport, ...config.transport };\n                }\n            }\n            addMCPServer(serverConfig);\n            console.log(chalk.green(`‚úì Added MCP server: ${name}`));\n            // Try to connect immediately\n            const manager = getMCPManager();\n            await manager.addServer(serverConfig);\n            console.log(chalk.green(`‚úì Connected to MCP server: ${name}`));\n            const tools = manager.getTools().filter(t => t.serverName === name);\n            console.log(chalk.blue(`  Available tools: ${tools.length}`));\n        }\n        catch (error) {\n            console.error(chalk.red(`Error adding MCP server: ${error.message}`));\n            process.exit(1);\n        }\n    });\n    // Remove server command\n    mcpCommand\n        .command('remove <name>')\n        .description('Remove an MCP server')\n        .action(async (name) => {\n        try {\n            const manager = getMCPManager();\n            await manager.removeServer(name);\n            removeMCPServer(name);\n            console.log(chalk.green(`‚úì Removed MCP server: ${name}`));\n        }\n        catch (error) {\n            console.error(chalk.red(`Error removing MCP server: ${error.message}`));\n            process.exit(1);\n        }\n    });\n    // List servers command\n    mcpCommand\n        .command('list')\n        .description('List configured MCP servers')\n        .action(() => {\n        const config = loadMCPConfig();\n        const manager = getMCPManager();\n        if (config.servers.length === 0) {\n            console.log(chalk.yellow('No MCP servers configured'));\n            return;\n        }\n        console.log(chalk.bold('Configured MCP servers:'));\n        console.log();\n        for (const server of config.servers) {\n            const isConnected = manager.getServers().includes(server.name);\n            const status = isConnected\n                ? chalk.green('‚úì Connected')\n                : chalk.red('‚úó Disconnected');\n            console.log(`${chalk.bold(server.name)}: ${status}`);\n            // Display transport information\n            if (server.transport) {\n                console.log(`  Transport: ${server.transport.type}`);\n                if (server.transport.type === 'stdio') {\n                    console.log(`  Command: ${server.transport.command} ${(server.transport.args || []).join(' ')}`);\n                }\n                else if (server.transport.type === 'http' || server.transport.type === 'sse') {\n                    console.log(`  URL: ${server.transport.url}`);\n                }\n            }\n            else if (server.command) {\n                // Legacy format\n                console.log(`  Command: ${server.command} ${(server.args || []).join(' ')}`);\n            }\n            if (isConnected) {\n                const transportType = manager.getTransportType(server.name);\n                if (transportType) {\n                    console.log(`  Active Transport: ${transportType}`);\n                }\n                const tools = manager.getTools().filter(t => t.serverName === server.name);\n                console.log(`  Tools: ${tools.length}`);\n                if (tools.length > 0) {\n                    tools.forEach(tool => {\n                        const displayName = tool.name.replace(`mcp__${server.name}__`, '');\n                        console.log(`    - ${displayName}: ${tool.description}`);\n                    });\n                }\n            }\n            console.log();\n        }\n    });\n    // Test server command\n    mcpCommand\n        .command('test <name>')\n        .description('Test connection to an MCP server')\n        .action(async (name) => {\n        try {\n            const config = loadMCPConfig();\n            const serverConfig = config.servers.find(s => s.name === name);\n            if (!serverConfig) {\n                console.error(chalk.red(`Server ${name} not found`));\n                process.exit(1);\n            }\n            console.log(chalk.blue(`Testing connection to ${name}...`));\n            const manager = getMCPManager();\n            await manager.addServer(serverConfig);\n            const tools = manager.getTools().filter(t => t.serverName === name);\n            console.log(chalk.green(`‚úì Successfully connected to ${name}`));\n            console.log(chalk.blue(`  Available tools: ${tools.length}`));\n            if (tools.length > 0) {\n                console.log('  Tools:');\n                tools.forEach(tool => {\n                    const displayName = tool.name.replace(`mcp__${name}__`, '');\n                    console.log(`    - ${displayName}: ${tool.description}`);\n                });\n            }\n        }\n        catch (error) {\n            console.error(chalk.red(`‚úó Failed to connect to ${name}: ${error.message}`));\n            process.exit(1);\n        }\n    });\n    return mcpCommand;\n}\n//# sourceMappingURL=mcp.js.map"
  },
  "package.json": {
    "path": "package.json",
    "hash": "19e3c835c0ff5d1beec8aa3c49ea9e862ac3e6a03c48667c85242f12fa447ea3",
    "size": 4403,
    "timestamp": 1764704879307,
    "content": "{\n  \"name\": \"@vibe-kit/grokinou-cli\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Grokinou - Enhanced fork of grok-cli with multi-provider AI support (Grok, Claude, OpenAI, Mistral, DeepSeek), advanced session management, and modern features\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"bin\": {\n    \"grokinou-cli\": \"dist/index.js\",\n    \"grokinou\": \"dist/index.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc && chmod +x dist/index.js\",\n    \"rebuild\": \"npm run build && npm link\",\n    \"build:bun\": \"bun run tsc && chmod +x dist/index.js\",\n    \"dev\": \"bun run src/index.ts\",\n    \"dev:node\": \"tsx src/index.ts\",\n    \"start\": \"node dist/index.js\",\n    \"start:bun\": \"bun run dist/index.js\",\n    \"lint\": \"eslint . --ext .js,.jsx,.ts,.tsx\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"install:bun\": \"bun install\",\n    \"test\": \"npm run build && npx tsc test/*.test.ts --outDir test --module esnext --skipLibCheck && npm run test:run\",\n    \"test:run\": \"node test/user-commands.test.js && node test/llm-tools.test.js\",\n    \"test:user-commands\": \"npm run build && npx tsc test/user-commands.test.ts --outDir test --module esnext --skipLibCheck && node test/user-commands.test.js\",\n    \"test:llm-tools\": \"npm run build && npx tsc test/llm-tools.test.ts --outDir test --module esnext --skipLibCheck && node test/llm-tools.test.js\",\n    \"test:all\": \"npm test\",\n    \"watch:integrity\": \"npm run build && tsx src/security/watcher-cli.ts\",\n    \"watch:integrity:llm\": \"npm run build && tsx src/security/watcher-cli.ts -- --mode llm\",\n    \"watch:integrity:dual\": \"npm run build && tsx src/security/watcher-cli.ts -- --mode dual\",\n    \"watch:baseline\": \"npm run build && tsx src/security/watcher-cli.ts -- --baseline\",\n    \"watch:alerts\": \"npm run build && tsx src/security/watcher-cli.ts -- --alerts\",\n    \"guard:start\": \"npm run build && tsx src/security/llm-guard-cli.ts\",\n    \"guard:logs\": \"npm run build && tsx src/security/llm-guard-cli.ts -- --logs\",\n    \"guard:stats\": \"npm run build && tsx src/security/llm-guard-cli.ts -- --stats\",\n    \"watcher:start\": \"npm run build && tsx src/security/watcher-daemon-cli.ts start\",\n    \"watcher:stop\": \"npm run build && tsx src/security/watcher-daemon-cli.ts stop\",\n    \"watcher:status\": \"npm run build && tsx src/security/watcher-daemon-cli.ts status\",\n    \"watcher:restart\": \"npm run build && tsx src/security/watcher-daemon-cli.ts restart\",\n    \"security:update-baseline\": \"tsx scripts/update-security-baseline.ts\",\n    \"security:verify\": \"tsx -e \\\"import {SelfIntegrityChecker} from './src/security/self-integrity.js'; const c = new SelfIntegrityChecker(); await c.verifyAll(); console.log(c.generateReport());\\\"\",\n    \"timeline:check\": \"tsx scripts/timeline-merkle-check.ts\",\n    \"timeline:rewind-test\": \"tsx scripts/timeline-rewind-test.ts\"\n  },\n  \"keywords\": [\n    \"cli\",\n    \"agent\",\n    \"text-editor\",\n    \"grok\",\n    \"grokinou\",\n    \"ai\",\n    \"multi-provider\",\n    \"openai\",\n    \"claude\",\n    \"mistral\",\n    \"deepseek\",\n    \"session-management\"\n  ],\n  \"author\": \"Zack, Claude, ChatGPT, Grok\",\n  \"license\": \"BSD-3-Clause AND GPL-3.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Kenchan1111/Grokinou.git\"\n  },\n  \"homepage\": \"https://github.com/Kenchan1111/Grokinou\",\n  \"bugs\": {\n    \"url\": \"https://github.com/Kenchan1111/Grokinou/issues\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.17.0\",\n    \"@types/better-sqlite3\": \"^7.6.13\",\n    \"@types/image-size\": \"^0.7.0\",\n    \"axios\": \"^1.7.0\",\n    \"better-sqlite3\": \"^12.5.0\",\n    \"cfonts\": \"^3.3.0\",\n    \"chalk\": \"^5.3.0\",\n    \"chokidar\": \"^5.0.0\",\n    \"clipboardy\": \"^5.0.1\",\n    \"commander\": \"^12.0.0\",\n    \"dotenv\": \"^16.4.0\",\n    \"enquirer\": \"^2.4.1\",\n    \"fs-extra\": \"^11.2.0\",\n    \"image-size\": \"^2.0.2\",\n    \"ink\": \"^4.4.1\",\n    \"marked\": \"^15.0.12\",\n    \"marked-terminal\": \"^7.3.0\",\n    \"nanoid\": \"^5.1.6\",\n    \"openai\": \"^5.10.1\",\n    \"react\": \"^18.3.1\",\n    \"ripgrep-node\": \"^1.0.0\",\n    \"tiktoken\": \"^1.0.21\"\n  },\n  \"devDependencies\": {\n    \"@types/fs-extra\": \"^11.0.2\",\n    \"@types/node\": \"^20.8.0\",\n    \"@types/react\": \"^18.3.3\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.37.0\",\n    \"@typescript-eslint/parser\": \"^8.37.0\",\n    \"eslint\": \"^9.31.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.3.3\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"preferGlobal\": true\n}\n"
  },
  "tsconfig.json": {
    "path": "tsconfig.json",
    "hash": "b91b28799230a51ef466dac4dd9ae90ec658ec7c7131d5556d74f06afa41f6d9",
    "size": 540,
    "timestamp": 1764704879307,
    "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": false,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"resolveJsonModule\": true,\n    \"jsx\": \"react\",\n    \"moduleResolution\": \"Bundler\",\n    \"allowSyntheticDefaultImports\": true,\n    \"noImplicitAny\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
  }
}